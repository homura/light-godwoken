{"version":3,"sources":["light-godwoken/godwoken-v1/src/schema_v1/index.js","light-godwoken/godwoken-v1/src/types.ts","light-godwoken/godwoken-v1/src/index.ts","light-godwoken/godwoken-v1/src/normalizer.ts","light-godwoken/constants/localLayer2Config.ts","light-godwoken/constants/index.ts","light-godwoken/constants/providerConfig.ts","light-godwoken/godwoken/normalizer.ts","light-godwoken/schemas/index.esm.js","light-godwoken/godwoken/godwoken.ts","light-godwoken/omni-lock/omni.js","light-godwoken/constants/layer1ConfigUtils.ts","light-godwoken/lightGodwokenProvider.ts","light-godwoken/constants/sudtErc20ProxyAbi.ts","light-godwoken/lightGodwoken.ts","light-godwoken/constants/tokens.ts","light-godwoken/LightGodwokenV0.ts","light-godwoken/lightGodwokenType.ts","light-godwoken/LightGodwokenV1.ts","contexts/LightGodwokenContext.tsx","hooks/useLightGodwoken.ts","utils/formatTokenAmount.ts","views/NumericalInput.tsx","views/CKBInputPanel.tsx","components/Address/index.tsx","components/ConnectButton/index.tsx","views/PageHeader.tsx","views/Page.tsx","views/Deposit.tsx","App.js","reportWebVitals.js","index.js","light-godwoken/godwoken-v1/schemas/index.js"],"names":["dataLengthError","actual","required","Error","assertDataLength","assertArrayBuffer","reader","Object","toArrayBuffer","Function","ArrayBuffer","serializeTable","buffers","itemCount","length","totalSize","offsets","i","push","byteLength","buffer","array","Uint8Array","view","DataView","setUint32","set","SerializeWithdrawalRequest","value","Uint32","size","Uint64","Uint128","Byte32","SerializeUint32","nonce","SerializeUint64","chain_id","capacity","SerializeUint128","amount","SerializeByte32","sudt_script_hash","account_script_hash","owner_lock_hash","fee","SerializeRawWithdrawalRequestV1","raw","SerializeBytes","signature","SerializeWithdrawalRequestExtra","request","SerializeScript","owner_lock","constructor","validate","this","indexAt","getUint8","toBigEndianUint32","getUint32","toLittleEndianUint32","item","code_hash","hashTypeView","setUint8","hash_type","args","Status","Godwoken","url","rpc","RPC","result","console","debug","method_name","name","l2tx","data","Reader","core","NormalizeL2Transaction","serializeJson","rpcCall","_send","rawL2Tx","hex","NormalizeRawL2Transaction","NormalizeWithdrawalRequest","reqExtra","normalizer","address","sudt_id","sudt_id_hex","toString","balance","BigInt","account_id","getScriptHash","slice","getBalance","key","account_id_hex","script_hash","id","undefined","parseInt","data_hash","l2_tx_hash","normalizeHexNumber","debugPath","intValue","start","substr","normalizeRawData","normalizeObject","obj","keys","f","entries","toNormalize","normalize","rawL2Transaction","from_id","to_id","l2Transaction","NormalizeRawWithdrawalRequest","raw_request","sell_amount","sell_capacity","payment_lock_hash","NormalizeFee","NormalizeRawWithdrawalRequestV1","raw_request_v1","NormalizeWithdrawalRequestV1","request_v1","NormalizeWithdrawalReqExtra","withdrawalReqExtra","normalizers","NormalizeScript","NormalizeCreateAccount","createAccount","script","SCRIPTS","eth_account_lock","script_type_hash","cell_dep","out_point","tx_hash","index","dep_type","deposit_lock","polyjuice_generator","l2_sudt_validator","meta_contract_validator","custodian_lock","l2_sudt_generator","state_validator_lock","challenge_lock","meta_contract_generator","always_success","state_validator","polyjuice_validator","poa_state","stake_lock","withdrawal_lock","tron_account_lock","ROLLUP_CONFIG","rollup_type_hash","rollup_type_script","genesis","timestamp","meta_contract_validator_type_hash","rollup_config","l1_sudt_script_type_hash","custodian_script_type_hash","deposit_script_type_hash","withdrawal_script_type_hash","challenge_script_type_hash","stake_script_type_hash","l2_sudt_validator_script_type_hash","burn_lock_hash","required_staking_capacity","challenge_maturity_blocks","finality_blocks","reward_burn_rate","allowed_eoa_type_hashes","allowed_contract_type_hashes","secp_data_dep","rpc_client","indexer_url","ckb_url","SCRIPTS_V0","ROLLUP_CONFIG_V0","SCRIPTS_V1","omni_lock","secp256k1_blake160","short_id","sudt","ROLLUP_CONFIG_V1","getLayer2Config","env","log","LocalLayer2Config","PROVIDER_CONFIG","CKB_INDEXER_URL","CKB_RPC_URL","GW_POLYJUICE_RPC_URL","SerializeRawWithdrawalRequest","Fee","SerializeFee","SerializeDepositLockArgs","layer2_lock","cancel_timeout","SerializeUnlockWithdrawalViaFinalize","getSudtId","getAmount","compatible","toBigEndianBigUint64","getBigUint64","toLittleEndianBigUint64","GodwokenClient","scriptHash","shortAddress","txHash","accountId","SerializeRcIdentity","SerializeIdentity","identity","map","maskView","mask","SerializeSmtProof","proof","SerializeSmtProofEntry","SerializeSmtProofEntryVec","proofs","SerializeRcLockWitnessLock","SerializeBytesOpt","SerializeRcIdentityOpt","rc_identity","preimage","LAYER1_CONFIG","OMNI_LOCK_CELL_DEP","SECP256K1_BLACK160_CELL_DEP","SUDT_CELL_DEP","POLYJUICE_CONFIG","web3Url","abiItems","inputs","internalType","type","stateMutability","anonymous","indexed","outputs","polyjuiceProvider","PolyjuiceHttpProvider","DefaultLightGodwokenProvider","ethAddress","ethereum","l2Address","l1Address","ckbIndexer","web3","godwokenClient","config","configObj","initializeConfig","predefined","AGGRON4","LINA","Indexer","generateL1Address","on","accounts","Web3","withdrawalRequest","submitWithdrawalRequest","getL2Address","getL1Address","version","isMetaMask","method","then","catch","error","code","omniLock","substring","helpers","generateAddress","tx","send_transaction","txSkeleton","message","generateMessage","signedMessage","params","selectedAddress","v","Number","padStart","signedWitness","toolkit","SerializeWitnessArgs","lock","update","witnesses","createTransactionFromSkeleton","hasher","utils","CKBHasher","rawTxHash","ckbHash","SerializeRawTransaction","NormalizeRawTransaction","serializedWitness","repeat","hashWitness","digestHex","witness","lengthBuffer","setBigUint64","get_transaction","asyncSleep","getLastSubmittedInfo","transaction_hash","getPendingTransaction","rollupIndex","transaction","findIndex","o","computeScriptHash","queryOptions","collector","rollupCell","cell","collect","getLayer2LockScript","toLowerCase","getLayer2LockScriptHash","accountScriptHash","getLayer1LockScriptHash","ownerCKBLock","parseAddress","ownerLock","ownerLockHash","getRollupCell","globalState","godwokenCore","GlobalState","lastFinalizedBlockNumber","getLastFinalizedBlockNumber","ms","Promise","r","setTimeout","DefaultLightGodwoken","provider","payload","neededCapacity","neededSudtAmount","collectedCapatity","collectedSudtAmount","collectedCells","cell_output","sudtType","readBigUInt128LECompatible","toBigInt","outputCell","generateDepositOutputCell","TransactionSkeleton","cellProvider","cell_deps","signedTx","signL1Transaction","sendL1Transaction","depositLockArgs","depositLockArgsHexString","NormalizeDepositLockArgs","depositLock","sumCapacity","reduce","acc","sumSustAmount","readBigUInt128LE","exchangeCapacity","exchangeCell","toBigUInt128LE","sudtData","exchangeSudtCell","sudtCapacity","minimalCellCapacity","getBlockProduceTime","getWithdrawal","signMessage","privateKey","signObject","secp256k1","signatureBuffer","signatureArray","recid","generateWithdrawalMessageToSign","rawWithdrawalRequest","rollupTypeHash","serializedRawWithdrawalRequest","minimalWithdrawalCapacity","isSudt","dummyHash","dummyHexNumber","dummyRollupTypeHash","dummyWithdrawalLockArgs","withdrawal_block_hash","withdrawal_block_number","serialized","SerializeWithdrawalLockArgs","withdrawal_lock_args","NormalizeWithdrawalLockArgs","eth","outputDataLenRange","collectedSum","balances","promises","addresses","usdcBalancePromise","Contract","methods","balanceOf","call","all","values","forEach","types","fromScript","changeOutput","TOKEN_LIST","symbol","decimals","tokenURI","issuerLockHash","l1Lock","DefaultLightGodwokenV0","getVersion","getBuiltinErc20List","token","tokenL1Script","tokenScriptHash","getBuiltinSUDTList","searchParams","getWithdrawalCellSearchParams","rawLockArgs","lockArgs","WithdrawalLockArgs","withdrawBlock","getWithdrawalBlockNumber","containsOwnerLock","includes","erc20","sudtTypeHash","find","e","withdrawalBlockNumber","remainingBlockNumber","Math","max","sortedWithdrawals","sort","a","b","startsWith","script_type","withdrawWithEvent","eventEmitter","EventEmitter","withdraw","emit","ethAccountTypeHash","withdrawal_address","l2AccountScript","fromId","getAccountIdByScriptHash","minCapacity","getNonce","paymentLockHash","signatureMetamaskPersonalSign","signMessageMetamaskPersonalSign","loop","nIntervId","setInterval","async","withdrawal","status","clearInterval","outputCells","dummySudtCell","capacityLeft","newWitnessArgs","NormalizeWitnessArgs","withdrawalWitness","withdrawalLockDep","rollupCellDep","getRollupCellDep","injectCapacity","LightGodwokenContext","createContext","Provider","props","lightGodwoken","setLightGodwoken","useState","useEffect","detectEthereumProvider","chainId","chainName","nativeCurrency","rpcUrls","blockExplorerUrls","addNetwork","instance","children","useLightGodwoken","useContext","getDisplayAmount","valueStr","intPart","unit","decPart","round","toFixed","replace","StyledInput","styled","input","align","inputRegex","RegExp","Input","React","memo","onUserInput","placeholder","rest","onChange","event","nextUserInput","target","test","inputMode","title","autoComplete","autoCorrect","pattern","minLength","maxLength","spellCheck","StyleWrapper","div","Row","CKBInputPanel","label","isL1","showMaxButton","setShowMaxButton","ckbBalance","setCkbBalance","getL1CkbBalance","getL2CkbBalance","fetchData","className","Text","NumericalInput","val","onClick","src","alt","TipWrapper","truncateMiddle","str","first","last","Address","useMemo","htmlFor","Group","compact","style","width","icon","CopyOutlined","navigator","clipboard","writeText","Button","ConnectButton","StyledPage","PageHeader","Page","Typography","PageContent","PageMain","WithDrawalButton","ConfirmModal","Modal","L2Balance","useQuery","enabled","LoadingOutlined","FaucetTip","faucetTip","setFaucetTip","BI","from","eq","success","window","location","href","Deposit","ckbInput","setCkbInput","outputValue","setOutputValue","isModalVisible","setIsModalVisible","submitButtonDisable","setSubmitButtonDisable","selectedSudt","setSelectedSudt","InfoCircleOutlined","verticalAlign","disabled","pow","hash","deposit","notification","visible","onCancel","footer","App","client","QueryClient","path","element","reportWebVitals","onPerfEntry","import","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","exports","verifyAndExtractOffsets","expectedFieldCount","requiredByteLength","firstOffset","Uint32Vec","SerializeUint32Vec","itemBuffer","BlockMerkleState","getMerkleRoot","getCount","SerializeBlockMerkleState","merkle_root","count","AccountMerkleState","SerializeAccountMerkleState","GlobalStateV0","getRollupConfigHash","getAccount","getBlock","getRevertedBlockRoot","getTipBlockHash","getStatus","SerializeGlobalStateV0","rollup_config_hash","account","block","reverted_block_root","tip_block_hash","last_finalized_block_number","getTipBlockTimestamp","SerializeGlobalState","tip_block_timestamp","RollupConfig","Byte32Vec","getL1SudtScriptTypeHash","offset","offset_end","getCustodianScriptTypeHash","getDepositScriptTypeHash","getWithdrawalScriptTypeHash","getChallengeScriptTypeHash","getStakeScriptTypeHash","getL2SudtValidatorScriptTypeHash","getBurnLockHash","getRequiredStakingCapacity","getChallengeMaturityBlocks","getFinalityBlocks","getRewardBurnRate","getAllowedEoaTypeHashes","getAllowedContractTypeHashes","SerializeRollupConfig","rewardBurnRateView","SerializeByte32Vec","RawL2Transaction","Bytes","getFromId","getToId","getArgs","SerializeRawL2Transaction","L2Transaction","getRaw","getSignature","SerializeL2Transaction","L2TransactionVec","SerializeL2TransactionVec","SubmitTransactions","getTxWitnessRoot","getTxCount","getPrevStateCheckpoint","SerializeSubmitTransactions","tx_witness_root","tx_count","prev_state_checkpoint","SubmitWithdrawals","getWithdrawalWitnessRoot","getWithdrawalCount","SerializeSubmitWithdrawals","withdrawal_witness_root","withdrawal_count","RawL2Block","getNumber","getBlockProducerId","getParentBlockHash","getStakeCellOwnerLockHash","getTimestamp","getPrevAccount","getPostAccount","getStateCheckpointList","getSubmitWithdrawals","getSubmitTransactions","SerializeRawL2Block","number","block_producer_id","parent_block_hash","stake_cell_owner_lock_hash","prev_account","post_account","state_checkpoint_list","submit_withdrawals","submit_transactions","RawL2BlockVec","SerializeRawL2BlockVec","L2Block","KVPairVec","WithdrawalRequestVec","getKvState","getKvStateProof","getTransactions","getBlockProof","getWithdrawals","SerializeL2Block","SerializeKVPairVec","kv_state","kv_state_proof","transactions","block_proof","SerializeWithdrawalRequestVec","withdrawals","DepositRequest","Script","getCapacity","getSudtScriptHash","getScript","SerializeDepositRequest","DepositRequestVec","SerializeDepositRequestVec","RawWithdrawalRequest","getAccountScriptHash","getSellAmount","getSellCapacity","getOwnerLockHash","getPaymentLockHash","getFee","WithdrawalRequest","KVPair","getK","getV","SerializeKVPair","k","BlockInfo","SerializeBlockInfo","DepositLockArgs","getLayer2Lock","getCancelTimeout","CustodianLockArgs","getDepositLockArgs","getDepositBlockHash","getDepositBlockNumber","SerializeCustodianLockArgs","deposit_lock_args","deposit_block_hash","deposit_block_number","UnlockCustodianViaRevertWitness","getDepositLockHash","SerializeUnlockCustodianViaRevertWitness","deposit_lock_hash","getWithdrawalBlockHash","UnlockWithdrawalWitness","t","UnlockWithdrawalViaFinalize","UnlockWithdrawalViaRevert","UnlockWithdrawalViaTrade","unionType","SerializeUnlockWithdrawalWitness","SerializeUnlockWithdrawalViaRevert","SerializeUnlockWithdrawalViaTrade","getCustodianLockHash","custodian_lock_hash","getOwnerLock","StakeLockArgs","getStakeBlockNumber","SerializeStakeLockArgs","stake_block_number","MetaContractArgs","CreateAccount","SerializeMetaContractArgs","SerializeCreateAccount","SUDTArgs","SUDTQuery","SUDTTransfer","SerializeSUDTArgs","SerializeSUDTQuery","SerializeSUDTTransfer","getShortAddress","short_address","getTo","to","ChallengeTarget","getBlockHash","getTargetIndex","getTargetType","SerializeChallengeTarget","block_hash","target_index","target_type","ChallengeLockArgs","getTarget","getRewardsReceiverLock","SerializeChallengeLockArgs","rewards_receiver_lock","ChallengeWitness","getRawL2Block","SerializeChallengeWitness","raw_l2block","ScriptVec","SerializeScriptVec","BlockHashEntry","getHash","SerializeBlockHashEntry","BlockHashEntryVec","SerializeBlockHashEntryVec","VerifyTransactionContext","BytesVec","getAccountCount","getLoadData","getScripts","getReturnDataHash","getBlockHashes","SerializeVerifyTransactionContext","account_count","SerializeBytesVec","load_data","scripts","return_data_hash","block_hashes","CKBMerkleProof","getIndices","getLemmas","SerializeCKBMerkleProof","indices","lemmas","VerifyTransactionWitness","getL2Tx","getTxProof","getBlockHashesProof","getContext","SerializeVerifyTransactionWitness","tx_proof","block_hashes_proof","context","VerifyTransactionSignatureContext","SerializeVerifyTransactionSignatureContext","VerifyTransactionSignatureWitness","SerializeVerifyTransactionSignatureWitness","VerifyWithdrawalWitness","getWithdrawalRequest","getWithdrawalProof","SerializeVerifyWithdrawalWitness","withdrawal_request","withdrawal_proof","RollupSubmitBlock","getRevertedBlockHashes","getRevertedBlockProof","SerializeRollupSubmitBlock","reverted_block_hashes","reverted_block_proof","RollupEnterChallenge","getWitness","SerializeRollupEnterChallenge","RollupCancelChallenge","SerializeRollupCancelChallenge","RollupRevert","getRevertedBlocks","getNewTipBlock","SerializeRollupRevert","reverted_blocks","new_tip_block","RollupAction","SerializeRollupAction","Uint16","toBigEndianUint16","getUint16","toLittleEndianUint16","SerializeUint16","Uint256","SerializeUint256","BytesOpt","hasValue","ScriptOpt","SerializeScriptOpt","ProposalShortId","SerializeProposalShortId","UncleBlockVec","UncleBlock","SerializeUncleBlockVec","SerializeUncleBlock","TransactionVec","Transaction","SerializeTransactionVec","SerializeTransaction","ProposalShortIdVec","SerializeProposalShortIdVec","CellDepVec","CellDep","SerializeCellDepVec","SerializeCellDep","CellInputVec","CellInput","SerializeCellInputVec","SerializeCellInput","CellOutputVec","CellOutput","SerializeCellOutputVec","SerializeCellOutput","getCodeHash","getHashType","OutPoint","getTxHash","getIndex","SerializeOutPoint","getSince","getPreviousOutput","since","previous_output","getLock","getType","type_","getOutPoint","getDepType","RawTransaction","getCellDeps","getHeaderDeps","getInputs","getOutputs","getOutputsData","header_deps","outputs_data","getWitnesses","RawHeader","getCompactTarget","getEpoch","getParentHash","getTransactionsRoot","getProposalsHash","getExtraHash","getDao","SerializeRawHeader","compact_target","epoch","parent_hash","transactions_root","proposals_hash","extra_hash","dao","Header","SerializeHeader","getHeader","getProposals","header","proposals","Block","getUncles","SerializeBlock","uncles","BlockV1","getExtension","SerializeBlockV1","extension","CellbaseWitness","getMessage","SerializeCellbaseWitness","WitnessArgs","getInputType","getOutputType","input_type","output_type","defineProperty","factory"],"mappings":"sHAAA,SAASA,EAAgBC,EAAQC,GAC/B,MAAM,IAAIC,MAAJ,yCAA4CD,EAA5C,qBAAiED,IAGzE,SAASG,EAAiBH,EAAQC,GAC5BD,IAAWC,GACbF,EAAgBC,EAAQC,GAI5B,SAASG,EAAkBC,GAIzB,GAHIA,aAAkBC,QAAUD,EAAOE,yBAAyBC,WAC9DH,EAASA,EAAOE,mBAEZF,aAAkBI,aACtB,MAAM,IAAIP,MAAM,iFAElB,OAAOG,EA0CT,SAASK,EAAeC,GACtB,MAAMC,EAAYD,EAAQE,OAC1B,IAAIC,EAAY,GAAKF,EAAY,GACjC,MAAMG,EAAU,GAEhB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAWI,IAC7BD,EAAQE,KAAKH,GACbA,GAAaH,EAAQK,GAAGE,WAG1B,MAAMC,EAAS,IAAIV,YAAYK,GACzBM,EAAQ,IAAIC,WAAWF,GACvBG,EAAO,IAAIC,SAASJ,GAE1BG,EAAKE,UAAU,EAAGV,GAAW,GAC7B,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAWI,IAC7BM,EAAKE,UAAU,EAAQ,EAAJR,EAAOD,EAAQC,IAAI,GACtCI,EAAMK,IAAI,IAAIJ,WAAWV,EAAQK,IAAKD,EAAQC,IAEhD,OAAOG,EA9ET,kCA2+CO,SAASO,EAA2BC,GACzC,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAzGH,SAAyCU,GAC9C,MAAMP,EAAQ,IAAIC,WAChB,EACEO,EAAOC,OACPC,EAAOD,OACPC,EAAOD,OACPE,EAAQF,OACRG,EAAOH,OACPG,EAAOH,OACPG,EAAOH,OACPC,EAAOD,QAuBX,OArBa,IAAIN,SAASH,EAAMD,QAChCC,EAAMK,IAAI,IAAIJ,WAAWY,EAAgBN,EAAMO,QAAS,GACxDd,EAAMK,IAAI,IAAIJ,WAAWc,EAAgBR,EAAMS,WAAY,EAAIR,EAAOC,QACtET,EAAMK,IAAI,IAAIJ,WAAWc,EAAgBR,EAAMU,WAAY,EAAIT,EAAOC,OAASC,EAAOD,QACtFT,EAAMK,IAAI,IAAIJ,WAAWiB,EAAiBX,EAAMY,SAAU,EAAIX,EAAOC,OAASC,EAAOD,OAASC,EAAOD,QACrGT,EAAMK,IACJ,IAAIJ,WAAWmB,EAAgBb,EAAMc,mBACrC,EAAIb,EAAOC,OAASC,EAAOD,OAASC,EAAOD,OAASE,EAAQF,QAE9DT,EAAMK,IACJ,IAAIJ,WAAWmB,EAAgBb,EAAMe,sBACrC,EAAId,EAAOC,OAASC,EAAOD,OAASC,EAAOD,OAASE,EAAQF,OAASG,EAAOH,QAE9ET,EAAMK,IACJ,IAAIJ,WAAWmB,EAAgBb,EAAMgB,kBACrC,EAAIf,EAAOC,OAASC,EAAOD,OAASC,EAAOD,OAASE,EAAQF,OAASG,EAAOH,OAASG,EAAOH,QAE9FT,EAAMK,IACJ,IAAIJ,WAAWc,EAAgBR,EAAMiB,MACrC,EAAIhB,EAAOC,OAASC,EAAOD,OAASC,EAAOD,OAASE,EAAQF,OAASG,EAAOH,OAASG,EAAOH,OAASG,EAAOH,QAEvGT,EAAMD,OAwEA0B,CAAgClB,EAAMmB,MACnDnC,EAAQM,KAAK8B,EAAepB,EAAMqB,YAC3BtC,EAAeC,GAgCjB,SAASsC,EAAgCtB,GAC9C,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAKS,EAA2BC,EAAMuB,UAC9CvC,EAAQM,KAAKkC,EAAgBxB,EAAMyB,aAC5B1C,EAAeC,GA+uDjB,MAAMiB,EACXyB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,GAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGnBuC,oBACE,OAAOH,KAAKjC,KAAKqC,UAAU,GAAG,GAGhCC,uBACE,OAAOL,KAAKjC,KAAKqC,UAAU,GAAG,GAGrB,cACT,OAAO,GAIJ,SAAS1B,EAAgBN,GAC9B,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,GAC7BC,EAGF,MAAMW,EACXuB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,GAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGR,cACT,OAAO,GAIJ,SAASgB,EAAgBR,GAC9B,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,GAC7BC,EAGF,MAAMY,EACXsB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,IAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGR,cACT,OAAO,IAIJ,SAASmB,EAAiBX,GAC/B,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,IAC7BC,EAGF,MAAMa,EACXqB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,IAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGR,cACT,OAAO,IAIJ,SAASqB,EAAgBb,GAC9B,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,IAC7BC,EA+DF,SAAS4B,EAAepB,GAC7B,MAAMkC,EAAOzD,EAAkBuB,GACzBP,EAAQ,IAAIC,WAAW,EAAIwC,EAAK3C,YAGtC,OAFA,IAAIK,SAASH,EAAMD,QAAQK,UAAU,EAAGqC,EAAK3C,YAAY,GACzDE,EAAMK,IAAI,IAAIJ,WAAWwC,GAAO,GACzBzC,EAAMD,OAkcR,SAASgC,EAAgBxB,GAC9B,MAAMhB,EAAU,GAChBA,EAAQM,KAAKuB,EAAgBb,EAAMmC,YACnC,MAAMC,EAAe,IAAIxC,SAAS,IAAId,YAAY,IAIlD,OAHAsD,EAAaC,SAAS,EAAGrC,EAAMsC,WAC/BtD,EAAQM,KAAK8C,EAAa5C,QAC1BR,EAAQM,KAAK8B,EAAepB,EAAMuC,OAC3BxD,EAAeC,K,iCClyHjB,IAAKwD,G,SAAAA,K,kBAAAA,E,mBAAAA,M,wCC9GZ,wGAqEO,MAAMC,EAGXf,YAAYgB,GAAc,KAFlBC,SAEiB,EACvBf,KAAKe,IAAM,IAAIC,MAAIF,GAQL,mBACd,MAAMG,QAAejB,KAAKe,IAAL,cAErB,OADAG,QAAQC,MAAM,YAAaF,GACpBA,EAGY,cAACG,GACpB,MAAMC,EAAO,MAAQD,EADkD,2BAA3BT,EAA2B,iCAA3BA,EAA2B,kBAGvE,aADqBX,KAAKe,IAAIM,MAASV,GAI9B,YAACW,EAAqBF,GAC/B,MAAMG,EAAO,IAAIC,SAAOC,yBAA4BC,YAAuBJ,KAAQK,gBACnF,aAAa3B,KAAK4B,QAAQR,EAAaG,GAGf,2BAACD,GACzB,OAAOtB,KAAK6B,MAAMP,EAAM,yBAGD,0BAACA,GACxB,OAAOtB,KAAK6B,MAAMP,EAAM,wBAGG,8BAACQ,GAC5B,MAAMC,EAAM,IAAIP,SAAOC,4BAA+BO,YAA0BF,KAAWH,gBAC3F,aAAa3B,KAAK4B,QAAQ,4BAA6BG,GAG5B,8BAACpC,GAC5B,MAAM4B,EAAO,IAAIC,SAAOC,6BAAgCQ,YAA2BtC,KAAWgC,gBAC9F,aAAa3B,KAAK4B,QAAQ,4BAA6BL,GAG9B,4BAACW,GAC1B,MAAMX,EAAO,IAAIC,SACf9B,YAAgCyC,IAAuCD,KACvEP,gBACF,aAAa3B,KAAK4B,QAAQ,4BAA6BL,GAQxB,kCAACa,GAChC,aAAapC,KAAK4B,QAAQ,mCAAoCQ,GAIhD,iBAACC,EAAiBD,GAChC,MAAME,EAAW,cAAUD,GAASE,SAAS,KACvCC,QAAgBxC,KAAK4B,QAAQ,cAAeQ,EAASE,GAC3D,OAAOG,OAAOD,GAGI,qBAACH,EAAiBK,GACpC,MACMN,SADmBpC,KAAK2C,cAAcD,IACjBE,MAAM,EAAG,IAEpC,aADsB5C,KAAK6C,WAAWR,EAASD,GAI/B,mBAACM,EAAoBI,GACrC,MAAMC,EAAc,YAAQL,EAAWH,SAAS,KAChD,aAAavC,KAAK4B,QAAQ,iBAAkBmB,EAAgBD,GAGhC,+BAACE,GAC7B,MAAMC,QAAWjD,KAAK4B,QAAQ,gCAAiCoB,GAC/D,OAAOC,GAAMA,OAAKC,EAGN,eAACR,GACb,MAAMK,EAAc,YAAQL,EAAWH,SAAS,KAC1C5D,QAAcqB,KAAK4B,QAAQ,YAAamB,GAC9C,OAAOI,SAASxE,GAGH,gBAACqE,GACd,aAAahD,KAAK4B,QAAQ,aAAcoB,GAGvB,oBAACN,GAClB,MAAMK,EAAc,YAAQL,EAAWH,SAAS,KAChD,aAAavC,KAAK4B,QAAQ,kBAAmBmB,GAGlC,cAACK,GACZ,aAAapD,KAAK4B,QAAQ,WAAYwB,GAGvB,kBAACA,GAChB,aAAapD,KAAK4B,QAAQ,gBAAiBwB,GAGlB,4BAACC,GAC1B,aAAarD,KAAK4B,QAAQ,0BAA2ByB,GAG7B,6BACxB,aAAarD,KAAK4B,QAAQ,+B,0cCvL9B,wNAKA,SAAS0B,EAAmBhG,GAC1B,OAAO,SAAUiG,EAAmBnF,GAClC,KAAMA,aAAiBlB,aAAc,CACnC,IAAIsG,EAAWf,OAAOrE,GAAOmE,SAAS,IAItC,GAHIiB,EAASlG,OAAS,IAAM,IAC1BkG,EAAW,IAAMA,GAEfA,EAASlG,OAAS,EAAIA,EACxB,MAAM,IAAIX,MAAJ,UAAa4G,EAAb,eAA6BC,EAASlG,OAAS,EAA/C,2CAAmFA,EAAnF,MAER,MAAMS,EAAO,IAAIC,SAAS,IAAId,YAAYI,IAC1C,IAAK,IAAIG,EAAI,EAAGA,EAAI+F,EAASlG,OAAS,EAAGG,IAAK,CAC5C,MAAMgG,EAAQD,EAASlG,OAAmB,GAATG,EAAI,GACrCM,EAAK0C,SAAShD,EAAG0F,SAASK,EAASE,OAAOD,EAAO,GAAI,KAEvDrF,EAAQL,EAAKH,OAEf,GAAIQ,EAAMT,WAAaL,EAAQ,CAC7B,MAAMO,EAAQ,IAAIC,WAAWR,GAC7BO,EAAMK,IAAI,IAAIJ,WAAWM,GAAQ,GACjCA,EAAQP,EAAMD,OAEhB,OAAOQ,GAIX,SAASuF,EAAiBrG,GACxB,OAAO,SAAUiG,EAAmBnF,GAElC,GADAA,EAAQ,IAAIoD,SAAOpD,GAAOpB,gBACtBM,EAAS,GAAKc,EAAMT,aAAeL,EACrC,MAAM,IAAIX,MAAJ,UAAa4G,EAAb,+BAA6CnF,EAAMT,WAAnD,uBAA4EL,IAEpF,OAAOc,GAIX,SAASwF,EAAgBL,EAAmBM,EAAUC,GACpD,MAAM7C,EAAc,GAEpB,IAAK,MAAO6B,EAAKiB,KAAMhH,OAAOiH,QAAQF,GAAO,CAC3C,MAAM1F,EAAQyF,EAAIf,GAClB,QAAcI,IAAV9E,GAAiC,OAAVA,EACzB,MAAM,IAAIzB,MAAJ,UAAa4G,EAAb,uBAAqCT,EAArC,MAER7B,EAAO6B,GAAOiB,EAAE,GAAD,OAAIR,EAAJ,YAAiBT,GAAO1E,GAEzC,OAAO6C,EAGT,SAASgD,EAAYC,GACnB,OAAO,SAAUX,EAAmBnF,GAClC,OAAO8F,EAAU9F,EAAO,CACtBmF,eA6DC,SAASvB,EAA0BmC,GAAsE,IAA5C,UAAEZ,EAAY,sBAA6B,uDAAJ,GACzG,OAAOK,EAAgBL,EAAWY,EAAkB,CAClDC,QAASd,EAAmB,GAC5Be,MAAOf,EAAmB,GAC1B3E,MAAO2E,EAAmB,GAC1B3C,KAAMgD,GAAkB,KAIrB,SAASjC,EAAuB4C,GAAsE,IAAxC,UAAEf,EAAY,kBAAyB,uDAAJ,GACtG,OAAOK,EAAgBL,EAAWe,EAAe,CAC/C/E,IAAK0E,EAAYjC,GACjBvC,UAAWkE,GAAkB,KAI1B,SAASY,EAA8BC,GAAqE,IAAhD,UAAEjB,EAAY,0BAAiC,uDAAJ,GAC5G,OAAOK,EAAgBL,EAAWiB,EAAa,CAC7C7F,MAAO2E,EAAmB,GAC1BxE,SAAUwE,EAAmB,GAC7BtE,OAAQsE,EAAmB,IAC3BpE,iBAAkByE,EAAiB,IACnCxE,oBAAqBwE,EAAiB,IACtCc,YAAanB,EAAmB,IAChCoB,cAAepB,EAAmB,GAClClE,gBAAiBuE,EAAiB,IAClCgB,kBAAmBhB,EAAiB,IACpCtE,IAAK4E,EAAYW,KAId,SAASC,EAAgCC,GAAwE,IAAhD,UAAEvB,EAAY,0BAAiC,uDAAJ,GACjH,OAAOK,EAAgBL,EAAWuB,EAAgB,CAChDnG,MAAO2E,EAAmB,GAC1BzE,SAAUyE,EAAmB,GAE7BxE,SAAUwE,EAAmB,GAE7BtE,OAAQsE,EAAmB,IAC3BpE,iBAAkByE,EAAiB,IAEnCxE,oBAAqBwE,EAAiB,IAEtCvE,gBAAiBuE,EAAiB,IAElCtE,IAAKiE,EAAmB,KAIrB,SAASyB,EACdC,GAEC,IADD,UAAEzB,EAAY,sBACd,uDADuC,GAEvC,OAAOK,EAAgBL,EAAWyB,EAAY,CAC5CzF,IAAK0E,EAAYY,GACjBpF,UAAWkE,EAAiB,MAIzB,SAASsB,EACdC,GAEC,IADD,UAAE3B,EAAY,sBACd,uDADuC,GAEvC,OAAOK,EAAgBL,EAAW2B,EAAoB,CACpDvF,QAASsE,EAAYc,GACrBlF,WAAYoE,EAAYkB,cAAYC,mBAIjC,SAASnD,EAA2BtC,GAAwE,IAA5C,UAAE4D,EAAY,sBAA6B,uDAAJ,GAC5G,OAAOK,EAAgBL,EAAW5D,EAAS,CACzCJ,IAAK0E,EAAYM,GACjB9E,UAAWkE,EAAiB,MASzB,SAASiB,EAAavF,GAA0C,IAA7B,UAAEkE,EAAY,OAAc,uDAAJ,GAChE,OAAOK,EAAgBL,EAAWlE,EAAK,CACrCgD,QAASiB,EAAmB,GAC5BtE,OAAQsE,EAAmB,MAIxB,SAAS+B,EAAuBC,GAA+D,IAAxC,UAAE/B,EAAY,kBAAyB,uDAAJ,GAC/F,OAAOK,EAAgBL,EAAW+B,EAAe,CAC/CC,OAAQtB,EAAYkB,cAAYC,iBAChC/F,IAAK4E,EAAYW,O,gIClNd,MAAMY,EAAU,CACrBC,iBAAkB,CAChBC,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdC,aAAc,CACZN,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdE,oBAAqB,CACnBP,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdG,kBAAmB,CACjBR,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdI,wBAAyB,CACvBT,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdK,eAAgB,CACdV,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdM,kBAAmB,CACjBX,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdO,qBAAsB,CACpBZ,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdQ,eAAgB,CACdb,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdS,wBAAyB,CACvBd,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdU,eAAgB,CACdf,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdW,gBAAiB,CACfhB,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdY,oBAAqB,CACnBjB,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGda,UAAW,CACTlB,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdc,WAAY,CACVnB,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGde,gBAAiB,CACfpB,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdgB,kBAAmB,CACjBrB,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,UAKHiB,EAAgB,CAC3BC,iBAAkB,qEAClBC,mBAAoB,CAClB3G,UAAW,qEACXG,UAAW,OACXC,KAAM,sEAERwG,QAAS,CACPC,UAAW,cACXC,kCAAmC,qEACnCJ,iBAAkB,qEAClBK,cAAe,CACbC,yBAA0B,qEAC1BC,2BAA4B,qEAC5BC,yBAA0B,qEAC1BC,4BAA6B,qEAC7BC,2BAA4B,qEAC5BC,uBAAwB,qEACxBC,mCAAoC,qEACpCC,eAAgB,qEAChBC,0BAA2B,cAC3BC,0BAA2B,OAC3BC,gBAAiB,OACjBC,iBAAkB,OAClBC,wBAAyB,CACvB,qEACA,sEAEFC,6BAA8B,CAC5B,qEACA,qEACA,uEAGJC,cAAe,CACbtC,SAAU,OACVH,UAAW,CACTC,QAAS,qEACTC,MAAO,SAIbwC,WAAY,CACVC,YAAa,sBACbC,QAAS,oBCxNPC,EAAa,CACjBzC,aAAc,CACZN,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGde,gBAAiB,CACfpB,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdN,iBAAkB,CAChBC,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,UAIV2C,EAAmB,CACvBzB,iBAAkB,qEAClBC,mBAAoB,CAClB3G,UAAW,qEACXG,UAAW,OACXC,KAAM,uEAGJgI,EAAa,CACjB3C,aAAc,CACZN,iBAAkB,sEAEpBoB,gBAAiB,CACfpB,iBAAkB,qEAClBC,SAAU,CACRC,UAAW,CACTC,QAAS,qEACTC,MAAO,OAETC,SAAU,SAGdN,iBAAkB,CAChBC,iBAAkB,sEAEpBkD,UAAW,CACTrI,UAAW,qEACXG,UAAW,OACXmF,QAAS,qEACTC,MAAO,MACPC,SAAU,QAEZ8C,mBAAoB,CAClBtI,UAAW,qEACXG,UAAW,OACXmF,QAAS,qEACTC,MAAO,MACPC,SAAU,YACV+C,SAAU,GAEZC,KAAM,CACJxI,UAAW,qEACXG,UAAW,OACXmF,QAAS,qEACTC,MAAO,MACPC,SAAU,SAGRiD,EAAmB,CACvB/B,iBAAkB,qEAClBC,mBAAoB,CAClB3G,UAAW,qEACXG,UAAW,OACXC,KAAM,uEAmCGsI,EAAkB,WAAkD,IAAjDC,EAAgD,uDAA/B,aAG/C,GAFAhI,QAAQiI,IAAR,+BAAoCD,IAExB,eAARA,EACF,MAAO,CACL1D,QAASiD,EACTzB,cAAe0B,GAEZ,GAAY,eAARQ,EACT,MAAO,CACL1D,QAASmD,EACT3B,cAAegC,GAEZ,GAAY,UAARE,EACT,MAAO,CACL1D,QAAS4D,EACTpC,cAAeoC,GAEZ,GAAY,YAARF,EACT,MAAO,CACL1D,QAASmD,EACT3B,cAAegC,GAGnB,MAAM,IAAIrM,MAAM,gB,oBCjJX,MAAM0M,EACL,CAEJC,gBAAiB,kCACjBC,YAAa,0BACbC,qBAAsB,gDALbH,EAOH,CACNC,gBAAiB,kCACjBC,YAAa,0BACbC,qBAAsB,gDAVbH,EAYE,CACXC,gBAAiB,kCACjBC,YAAa,0BACbC,qBAAsB,mD,yBCV1B,SAASlG,EAAmBhG,GAC1B,OAAO,SAAUiG,EAAmBnF,GAClC,KAAMA,aAAiBlB,aAAc,CACnC,IAAIsG,EAAWf,OAAOrE,GAAOmE,SAAS,IAItC,GAHIiB,EAASlG,OAAS,IAAM,IAC1BkG,EAAW,IAAMA,GAEfA,EAASlG,OAAS,EAAIA,EACxB,MAAM,IAAIX,MAAJ,UAAa4G,EAAb,eAA6BC,EAASlG,OAAS,EAA/C,2CAAmFA,EAAnF,MAER,MAAMS,EAAO,IAAIC,SAAS,IAAId,YAAYI,IAC1C,IAAK,IAAIG,EAAI,EAAGA,EAAI+F,EAASlG,OAAS,EAAGG,IAAK,CAC5C,MAAMgG,EAAQD,EAASlG,OAAmB,GAATG,EAAI,GACrCM,EAAK0C,SAAShD,EAAG0F,SAASK,EAASE,OAAOD,EAAO,GAAI,KAEvDrF,EAAQL,EAAKH,OAEf,GAAIQ,EAAMT,WAAaL,EAAQ,CAC7B,MAAMO,EAAQ,IAAIC,WAAWR,GAC7BO,EAAMK,IAAI,IAAIJ,WAAWM,GAAQ,GACjCA,EAAQP,EAAMD,OAEhB,OAAOQ,GAIX,SAASuF,EAAiBrG,GACxB,OAAO,SAAUiG,EAAmBnF,GAElC,GADAA,EAAQ,IAAIoD,SAAOpD,GAAOpB,gBACtBM,EAAS,GAAKc,EAAMT,aAAeL,EACrC,MAAM,IAAIX,MAAJ,UAAa4G,EAAb,+BAA6CnF,EAAMT,WAAnD,uBAA4EL,IAEpF,OAAOc,GAIX,SAASwF,EAAgBL,EAAmBM,EAAUC,GACpD,MAAM7C,EAAc,GAEpB,IAAK,MAAO6B,EAAKiB,KAAMhH,OAAOiH,QAAQF,GAAO,CAC3C,MAAM1F,EAAQyF,EAAIf,GAClB,QAAcI,IAAV9E,GAAiC,OAAVA,EACzB,MAAM,IAAIzB,MAAJ,UAAa4G,EAAb,uBAAqCT,EAArC,MAER7B,EAAO6B,GAAOiB,EAAE,GAAD,OAAIR,EAAJ,YAAiBT,GAAO1E,GAEzC,OAAO6C,EAGT,SAASgD,EAAYC,GACnB,OAAO,SAAUX,EAAmBnF,GAClC,OAAO8F,EAAU9F,EAAO,CACtBmF,eA4BC,SAASqB,EAAavF,GAA0C,IAA7B,UAAEkE,EAAY,OAAc,uDAAJ,GAChE,OAAOK,EAAgBL,EAAWlE,EAAK,CACrCgD,QAASiB,EAAmB,GAC5BtE,OAAQsE,EAAmB,MA2BxB,SAASiB,EAA8BC,GAAqE,IAAhD,UAAEjB,EAAY,0BAAiC,uDAAJ,GAC5G,OAAOK,EAAgBL,EAAWiB,EAAa,CAC7C7F,MAAO2E,EAAmB,GAC1BxE,SAAUwE,EAAmB,GAC7BtE,OAAQsE,EAAmB,IAC3BpE,iBAAkByE,EAAiB,IACnCxE,oBAAqBwE,EAAiB,IACtCc,YAAanB,EAAmB,IAChCoB,cAAepB,EAAmB,GAClClE,gBAAiBuE,EAAiB,IAClCgB,kBAAmBhB,EAAiB,IACpCtE,IAAK4E,EAAYW,KC7HrB,SAASpI,EAAgBC,EAAQC,GAC/B,MAAM,IAAIC,MAAJ,yCAA4CD,EAA5C,qBAAiED,IAGzE,SAASG,EAAiBH,EAAQC,GAC5BD,IAAWC,GACbF,EAAgBC,EAAQC,GAI5B,SAASG,EAAkBC,GAIzB,GAHIA,aAAkBC,QAAUD,EAAOE,yBAAyBC,WAC9DH,EAASA,EAAOE,mBAEZF,aAAkBI,aACtB,MAAM,IAAIP,MAAM,iFAElB,OAAOG,EA0CT,SAASK,EAAeC,GACtB,MAAMC,EAAYD,EAAQE,OAC1B,IAAIC,EAAY,GAAKF,EAAY,GACjC,MAAMG,EAAU,GAEhB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAWI,IAC7BD,EAAQE,KAAKH,GACbA,GAAaH,EAAQK,GAAGE,WAG1B,MAAMC,EAAS,IAAIV,YAAYK,GACzBM,EAAQ,IAAIC,WAAWF,GACvBG,EAAO,IAAIC,SAASJ,GAE1BG,EAAKE,UAAU,EAAGV,GAAW,GAC7B,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAWI,IAC7BM,EAAKE,UAAU,EAAQ,EAAJR,EAAOD,EAAQC,IAAI,GACtCI,EAAMK,IAAI,IAAIJ,WAAWV,EAAQK,IAAKD,EAAQC,IAEhD,OAAOG,EA8xCF,SAAS6L,EAA8BrL,GAC5C,MAAMP,EAAQ,IAAIC,WAChB,EACEO,EAAOC,OACPC,EAAOD,OACPE,EAAQF,OACRG,EAAOH,OACPG,EAAOH,OACPE,EAAQF,OACRC,EAAOD,OACPG,EAAOH,OACPG,EAAOH,OACPoL,EAAIpL,QAEK,IAAIN,SAASH,EAAMD,QAiDhC,OAhDAC,EAAMK,IAAI,IAAIJ,WAAWY,EAAgBN,EAAMO,QAAS,GACxDd,EAAMK,IAAI,IAAIJ,WAAWc,EAAgBR,EAAMU,WAAY,EAAIT,EAAOC,QACtET,EAAMK,IAAI,IAAIJ,WAAWiB,EAAiBX,EAAMY,SAAU,EAAIX,EAAOC,OAASC,EAAOD,QACrFT,EAAMK,IACJ,IAAIJ,WAAWmB,EAAgBb,EAAMc,mBACrC,EAAIb,EAAOC,OAASC,EAAOD,OAASE,EAAQF,QAE9CT,EAAMK,IACJ,IAAIJ,WAAWmB,EAAgBb,EAAMe,sBACrC,EAAId,EAAOC,OAASC,EAAOD,OAASE,EAAQF,OAASG,EAAOH,QAE9DT,EAAMK,IACJ,IAAIJ,WAAWiB,EAAiBX,EAAMqG,cACtC,EAAIpG,EAAOC,OAASC,EAAOD,OAASE,EAAQF,OAASG,EAAOH,OAASG,EAAOH,QAE9ET,EAAMK,IACJ,IAAIJ,WAAWc,EAAgBR,EAAMsG,gBACrC,EAAIrG,EAAOC,OAASC,EAAOD,OAASE,EAAQF,OAASG,EAAOH,OAASG,EAAOH,OAASE,EAAQF,QAE/FT,EAAMK,IACJ,IAAIJ,WAAWmB,EAAgBb,EAAMgB,kBACrC,EAAIf,EAAOC,OAASC,EAAOD,OAASE,EAAQF,OAASG,EAAOH,OAASG,EAAOH,OAASE,EAAQF,OAASC,EAAOD,QAE/GT,EAAMK,IACJ,IAAIJ,WAAWmB,EAAgBb,EAAMuG,oBACrC,EACEtG,EAAOC,OACPC,EAAOD,OACPE,EAAQF,OACRG,EAAOH,OACPG,EAAOH,OACPE,EAAQF,OACRC,EAAOD,OACPG,EAAOH,QAEXT,EAAMK,IACJ,IAAIJ,WAAW6L,EAAavL,EAAMiB,MAClC,EACEhB,EAAOC,OACPC,EAAOD,OACPE,EAAQF,OACRG,EAAOH,OACPG,EAAOH,OACPE,EAAQF,OACRC,EAAOD,OACPG,EAAOH,OACPG,EAAOH,QAEJT,EAAMD,OAsER,SAASO,EAA2BC,GACzC,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAK+L,EAA8BrL,EAAMmB,MACjDnC,EAAQM,KAAK8B,EAAepB,EAAMqB,YAC3BtC,EAAeC,GA+JjB,SAASwM,EAAyBxL,GACvC,MAAMhB,EAAU,GAIhB,OAHAA,EAAQM,KAAKuB,EAAgBb,EAAMgB,kBACnChC,EAAQM,KAAKkC,EAAgBxB,EAAMyL,cACnCzM,EAAQM,KAAKkB,EAAgBR,EAAM0L,iBAC5B3M,EAAeC,GAgVjB,SAAS2M,EAAqC3L,GAEnD,OAAOjB,EADS,IAyJX,MAAMuM,EACX5J,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITiK,YACE,OAAO,IAAI3L,EAAO2B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAIvE,EAAOC,QAAS,CAAEyB,UAAU,IAG9EkK,YACE,OAAO,IAAIzL,EAAQwB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAIvE,EAAOC,OAAQ,EAAID,EAAOC,OAASE,EAAQF,QAAS,CAChGyB,UAAU,IAIdA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAY+L,EAAIpL,QAC3C0B,KAAKgK,YAAYjK,SAASmK,GAC1BlK,KAAKiK,YAAYlK,SAASmK,GAEjB,cACT,OAAO,EAAI7L,EAAOC,OAASE,EAAQF,QAIhC,SAASqL,EAAavL,GAC3B,MAAMP,EAAQ,IAAIC,WAAW,EAAIO,EAAOC,OAASE,EAAQF,QAC5C,IAAIN,SAASH,EAAMD,QAGhC,OAFAC,EAAMK,IAAI,IAAIJ,WAAWY,EAAgBN,EAAMiE,UAAW,GAC1DxE,EAAMK,IAAI,IAAIJ,WAAWiB,EAAiBX,EAAMY,SAAU,EAAIX,EAAOC,QAC9DT,EAAMD,OA0gCR,MAAMS,EACXyB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,GAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGnBuC,oBACE,OAAOH,KAAKjC,KAAKqC,UAAU,GAAG,GAGhCC,uBACE,OAAOL,KAAKjC,KAAKqC,UAAU,GAAG,GAGrB,cACT,OAAO,GAIJ,SAAS1B,EAAgBN,GAC9B,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,GAC7BC,EAGF,MAAMW,EACXuB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,GAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGnBuM,uBACE,OAAOnK,KAAKjC,KAAKqM,aAAa,GAAG,GAGnCC,0BACE,OAAOrK,KAAKjC,KAAKqM,aAAa,GAAG,GAGxB,cACT,OAAO,GAIJ,SAASxL,EAAgBR,GAC9B,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,GAC7BC,EAGF,MAAMY,EACXsB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,IAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGR,cACT,OAAO,IAIJ,SAASmB,EAAiBX,GAC/B,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,IAC7BC,EAGF,MAAMa,EACXqB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,IAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGR,cACT,OAAO,IAIJ,SAASqB,EAAgBb,GAC9B,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,IAC7BC,EA+DF,SAAS4B,EAAepB,GAC7B,MAAMkC,EAAOzD,EAAkBuB,GACzBP,EAAQ,IAAIC,WAAW,EAAIwC,EAAK3C,YAGtC,OAFA,IAAIK,SAASH,EAAMD,QAAQK,UAAU,EAAGqC,EAAK3C,YAAY,GACzDE,EAAMK,IAAI,IAAIJ,WAAWwC,GAAO,GACzBzC,EAAMD,OAkcR,SAASgC,EAAgBxB,GAC9B,MAAMhB,EAAU,GAChBA,EAAQM,KAAKuB,EAAgBb,EAAMmC,YACnC,MAAMC,EAAe,IAAIxC,SAAS,IAAId,YAAY,IAIlD,OAHAsD,EAAaC,SAAS,EAAGrC,EAAMsC,WAC/BtD,EAAQM,KAAK8C,EAAa5C,QAC1BR,EAAQM,KAAK8B,EAAepB,EAAMuC,OAC3BxD,EAAeC,GC1zHjB,MAAMkN,EAGXxK,YAAYgB,GAAc,KAFlBC,SAEiB,EACvBf,KAAKe,IAAM,IAAIC,MAAIF,GAGA,cAACM,GACpB,MAAMC,EAAO,MAAQD,EADkD,2BAA3BT,EAA2B,iCAA3BA,EAA2B,kBAGvE,aADqBX,KAAKe,IAAIM,MAASV,GAUZ,8BAAChB,GAC5B,MAAM4B,EAAO,IAAIC,SAAOrD,EFmGrB,SAAoCwB,GAAwE,IAA5C,UAAE4D,EAAY,sBAA6B,uDAAJ,GAC5G,OAAOK,EAAgBL,EAAW5D,EAAS,CACzCJ,IAAK0E,EAAYM,GACjB9E,UAAWkE,EAAiB,MEtGuB1B,CAA2BtC,KAAWgC,gBACzF,aAAa3B,KAAK4B,QAAQ,4BAA6BL,GAQ3B,+BAACgJ,GAE7B,aADiBvK,KAAK4B,QAAQ,gCAAiC2I,GAShC,kCAACC,GAEhC,aADyBxK,KAAK4B,QAAQ,mCAAoC4I,GAQzD,oBAACC,GAElB,aADyBzK,KAAK4B,QAAQ,iBAAkB6I,GAQ5C,eAACC,GAEb,aADoB1K,KAAK4B,QAAQ,YAAa8I,GAItB,6BACxB,aAAa1K,KAAK4B,QAAQ,2BAOT,oBAAC8I,GAClB,aAAa1K,KAAK4B,QAAQ,kBAAmB8I,I,sBC7EjD,SAASlO,GAAgBC,EAAQC,GAC/B,MAAM,IAAIC,MAAJ,yCAA4CD,EAA5C,qBAAiED,IAGzE,SAASG,GAAiBH,EAAQC,GAC5BD,IAAWC,GACbF,GAAgBC,EAAQC,GAI5B,SAASG,GAAkBC,GAKzB,GAJIA,aAAkBC,QAAUD,EAAOE,yBAAyBC,WAC9DH,EAASA,EAAOE,mBAGZF,aAAkBI,aACtB,MAAM,IAAIP,MAAM,iFAGlB,OAAOG,EAuDT,SAASK,GAAeC,GACtB,MAAMC,EAAYD,EAAQE,OAC1B,IAAIC,EAAY,GAAKF,EAAY,GACjC,MAAMG,EAAU,GAEhB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAWI,IAC7BD,EAAQE,KAAKH,GACbA,GAAaH,EAAQK,GAAGE,WAG1B,MAAMC,EAAS,IAAIV,YAAYK,GACzBM,EAAQ,IAAIC,WAAWF,GACvBG,EAAO,IAAIC,SAASJ,GAC1BG,EAAKE,UAAU,EAAGV,GAAW,GAE7B,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAWI,IAC7BM,EAAKE,UAAU,EAAQ,EAAJR,EAAOD,EAAQC,IAAI,GACtCI,EAAMK,IAAI,IAAIJ,WAAWV,EAAQK,IAAKD,EAAQC,IAGhD,OAAOG,EAyET,SAAS+M,GAAoBvM,GAC3B,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KA9CV,SAA2BU,GACzB,MAAMR,EAASf,GAAkBuB,GAEjC,OADAxB,GAAiBgB,EAAOD,WAAY,IAC7BC,EA2CMgN,CAAkBxM,EAAMyM,WACrCzN,EAAQM,KA8gBV,SAAmCU,GACjC,OAAOjB,GAAeiB,EAAM0M,KAAKxK,GApDnC,SAAgClC,GAC9B,MAAMhB,EAAU,GACV2N,EAAW,IAAI/M,SAAS,IAAId,YAAY,IAI9C,OAHA6N,EAAStK,SAAS,EAAGrC,EAAM4M,MAC3B5N,EAAQM,KAAKqN,EAASnN,QACtBR,EAAQM,KAAKuN,GAAkB7M,EAAM8M,QAC9B/N,GAAeC,GA8CoB+N,CAAuB7K,MA/gBpD8K,CAA0BhN,EAAMiN,SACtClO,GAAeC,GAuFjB,SAASkO,GAA2BlN,GACzC,MAAMhB,EAAU,GAIhB,OAHAA,EAAQM,KAAK6N,GAAkBnN,EAAMqB,YACrCrC,EAAQM,KA7DV,SAAgCU,GAC9B,OAAIA,EACKuM,GAAoBvM,GAEpB,IAAIlB,YAAY,GAyDZsO,CAAuBpN,EAAMqN,cAC1CrO,EAAQM,KAAK6N,GAAkBnN,EAAMsN,WAC9BvO,GAAeC,GAgVxB,SAAS6N,GAAkB7M,GACzB,MAAMkC,EAAOzD,GAAkBuB,GACzBP,EAAQ,IAAIC,WAAW,EAAIwC,EAAK3C,YAGtC,OAFA,IAAIK,SAASH,EAAMD,QAAQK,UAAU,EAAGqC,EAAK3C,YAAY,GACzDE,EAAMK,IAAI,IAAIJ,WAAWwC,GAAO,GACzBzC,EAAMD,OAodf,SAAS4B,GAAepB,GACtB,MAAMkC,EAAOzD,GAAkBuB,GACzBP,EAAQ,IAAIC,WAAW,EAAIwC,EAAK3C,YAGtC,OAFA,IAAIK,SAASH,EAAMD,QAAQK,UAAU,EAAGqC,EAAK3C,YAAY,GACzDE,EAAMK,IAAI,IAAIJ,WAAWwC,GAAO,GACzBzC,EAAMD,OA6Bf,SAAS2N,GAAkBnN,GACzB,OAAIA,EACKoB,GAAepB,GAEf,IAAIlB,YAAY,GCzlCpB,MAAMyO,GACA,CACTpL,UAAW,qEACXG,UAAW,OACXmF,QAAS,qEACTC,MAAO,MACPC,SAAU,QAND4F,GAQS,CAClBpL,UAAW,qEACXG,UAAW,OACXmF,QAAS,qEACTC,MAAO,MACPC,SAAU,YACV+C,SAAU,GAdD6C,GAgBL,CACJpL,UAAW,qEACXG,UAAW,OACXmF,QAAS,qEACTC,MAAO,MACPC,SAAU,QAID6F,GAA8B,CACzChG,UAAW,CACTC,QAAS8F,GAAwB9F,QACjCC,MAAO6F,GAAwB7F,OAEjCC,SAAU4F,GAAwB5F,UAGvB8F,GAAuC,CAClDjG,UAAW,CACTC,QAAS8F,GAAiC9F,QAC1CC,MAAO6F,GAAiC7F,OAE1CC,SAAU4F,GAAiC5F,UAGhC+F,GAAyB,CACpClG,UAAW,CACTC,QAAS8F,GAAmB9F,QAC5BC,MAAO6F,GAAmB7F,OAE5BC,SAAU4F,GAAmB5F,WCjBvBP,QAAF,GAAWwB,cAAX,IAA6BiC,IAEtB8C,GAAmB,CAC9BC,QAAS3C,EAA4BG,qBACrCyC,SCnCkC,CAClC,CACEC,OAAQ,CACN,CACEC,aAAc,SACd9K,KAAM,QACN+K,KAAM,UAER,CACED,aAAc,SACd9K,KAAM,UACN+K,KAAM,UAER,CACED,aAAc,UACd9K,KAAM,eACN+K,KAAM,WAER,CACED,aAAc,UACd9K,KAAM,UACN+K,KAAM,WAER,CACED,aAAc,QACd9K,KAAM,YACN+K,KAAM,UAGVC,gBAAiB,aACjBD,KAAM,eAER,CACEE,WAAW,EACXJ,OAAQ,CACN,CACEK,SAAS,EACTJ,aAAc,UACd9K,KAAM,QACN+K,KAAM,WAER,CACEG,SAAS,EACTJ,aAAc,UACd9K,KAAM,UACN+K,KAAM,WAER,CACEG,SAAS,EACTJ,aAAc,UACd9K,KAAM,QACN+K,KAAM,YAGV/K,KAAM,WACN+K,KAAM,SAER,CACEE,WAAW,EACXJ,OAAQ,CACN,CACEK,SAAS,EACTJ,aAAc,UACd9K,KAAM,OACN+K,KAAM,WAER,CACEG,SAAS,EACTJ,aAAc,UACd9K,KAAM,KACN+K,KAAM,WAER,CACEG,SAAS,EACTJ,aAAc,UACd9K,KAAM,QACN+K,KAAM,YAGV/K,KAAM,WACN+K,KAAM,SAER,CACEF,OAAQ,GACR7K,KAAM,SACNmL,QAAS,CACP,CACEL,aAAc,UACd9K,KAAM,GACN+K,KAAM,YAGVC,gBAAiB,OACjBD,KAAM,YAER,CACEF,OAAQ,GACR7K,KAAM,OACNmL,QAAS,CACP,CACEL,aAAc,SACd9K,KAAM,GACN+K,KAAM,WAGVC,gBAAiB,OACjBD,KAAM,YAER,CACEF,OAAQ,GACR7K,KAAM,SACNmL,QAAS,CACP,CACEL,aAAc,SACd9K,KAAM,GACN+K,KAAM,WAGVC,gBAAiB,OACjBD,KAAM,YAER,CACEF,OAAQ,GACR7K,KAAM,WACNmL,QAAS,CACP,CACEL,aAAc,QACd9K,KAAM,GACN+K,KAAM,UAGVC,gBAAiB,OACjBD,KAAM,YAER,CACEF,OAAQ,GACR7K,KAAM,cACNmL,QAAS,CACP,CACEL,aAAc,UACd9K,KAAM,GACN+K,KAAM,YAGVC,gBAAiB,OACjBD,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACd9K,KAAM,UACN+K,KAAM,YAGV/K,KAAM,YACNmL,QAAS,CACP,CACEL,aAAc,UACd9K,KAAM,GACN+K,KAAM,YAGVC,gBAAiB,aACjBD,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACd9K,KAAM,YACN+K,KAAM,WAER,CACED,aAAc,UACd9K,KAAM,SACN+K,KAAM,YAGV/K,KAAM,WACNmL,QAAS,CACP,CACEL,aAAc,OACd9K,KAAM,GACN+K,KAAM,SAGVC,gBAAiB,aACjBD,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACd9K,KAAM,QACN+K,KAAM,WAER,CACED,aAAc,UACd9K,KAAM,UACN+K,KAAM,YAGV/K,KAAM,YACNmL,QAAS,CACP,CACEL,aAAc,UACd9K,KAAM,GACN+K,KAAM,YAGVC,gBAAiB,aACjBD,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACd9K,KAAM,UACN+K,KAAM,WAER,CACED,aAAc,UACd9K,KAAM,SACN+K,KAAM,YAGV/K,KAAM,UACNmL,QAAS,CACP,CACEL,aAAc,OACd9K,KAAM,GACN+K,KAAM,SAGVC,gBAAiB,aACjBD,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACd9K,KAAM,SACN+K,KAAM,WAER,CACED,aAAc,UACd9K,KAAM,YACN+K,KAAM,WAER,CACED,aAAc,UACd9K,KAAM,SACN+K,KAAM,YAGV/K,KAAM,eACNmL,QAAS,CACP,CACEL,aAAc,OACd9K,KAAM,GACN+K,KAAM,SAGVC,gBAAiB,aACjBD,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACd9K,KAAM,UACN+K,KAAM,WAER,CACED,aAAc,UACd9K,KAAM,aACN+K,KAAM,YAGV/K,KAAM,oBACNmL,QAAS,CACP,CACEL,aAAc,OACd9K,KAAM,GACN+K,KAAM,SAGVC,gBAAiB,aACjBD,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACd9K,KAAM,UACN+K,KAAM,WAER,CACED,aAAc,UACd9K,KAAM,kBACN+K,KAAM,YAGV/K,KAAM,oBACNmL,QAAS,CACP,CACEL,aAAc,OACd9K,KAAM,GACN+K,KAAM,SAGVC,gBAAiB,aACjBD,KAAM,cDnRGK,GAAoB,IAAIC,wBACnCX,GAAiBC,QACjBD,IAGa,MAAMY,GAUnB7M,YAAY8M,EAAqBC,EAAe3D,GAAmC,KATnF4D,UAAqB,GAS6D,KARlFC,UAAqB,GAQ6D,KAPlFC,gBAOkF,OANlFjM,SAMkF,OALlF8L,cAKkF,OAJlFI,UAIkF,OAHlFC,oBAGkF,OAFlFC,YAEkF,EAChF,IAAIC,EAAY/D,EAChB,GAAY,OAARH,EACFiE,SAAOE,iBAAiBF,SAAOG,WAAWC,SAC1CH,EAAY/D,OACP,GAAY,OAARH,EACTiE,SAAOE,iBAAiBF,SAAOG,WAAWC,SAC1CH,EAAY/D,MACP,IAAY,YAARH,EAIT,MAAM,IAAIvM,MAAM,+CAHhBwQ,SAAOE,iBAAiBF,SAAOG,WAAWE,MAC1CJ,EAAY/D,EAIdnI,QAAQiI,IAAI,YAAaiE,GAEzBpN,KAAKmN,OAASC,EACdpN,KAAKgN,WAAa,IAAIS,UAAQL,EAAU9D,gBAAiB8D,EAAU7D,aACnEvJ,KAAKe,IAAM,IAAIC,MAAIoM,EAAU7D,aAC7BvJ,KAAKkN,eAAiB,IAAI5C,EAAe8C,EAAU5D,sBAEnDxJ,KAAK6M,SAAWA,EAChB7M,KAAK8M,UAAYF,EACjB5M,KAAK+M,UAAY/M,KAAK0N,kBAAkB1N,KAAK8M,WAC7CD,EAASc,GAAG,mBAAoBC,IAC9B1M,QAAQiI,IAAI,uBAAwByE,GACpC5N,KAAK8M,UAAYc,EAAS,GAC1B5N,KAAK+M,UAAY/M,KAAK0N,kBAAkB1N,KAAK8M,cAG/C9M,KAAKiN,KAAO,IAAIY,IAAKpB,IAGM,8BAACqB,GAE5B,aADqB9N,KAAKkN,eAAea,wBAAwBD,GAInEE,eACE,OAAOhO,KAAK8M,UAEdmB,eACE,OAAOjO,KAAK+M,UAGa,4BAACF,EAAeqB,GACzC,IAAKrB,IAAaA,EAASsB,WACzB,MAAM,IAAIxR,MAAM,2CAElB,OAAOkQ,EACJlN,QAAQ,CAAEyO,OAAQ,wBAClBC,MAAMT,IACL1M,QAAQiI,IAAI,sBAAuByE,GAC5B,IAAIjB,GAA6BiB,EAAS,GAAIf,EAAUqB,MAEhEI,OAAOC,IACa,OAAfA,EAAMC,KAERtN,QAAQiI,IAAI,+BAEZjI,QAAQqN,MAAMA,MAKtBb,kBAAkBZ,GAChB,MAAM2B,EAAmB,CACvBlO,UAAWoL,GAAwBpL,UACnCG,UAAWiL,GAAwBjL,UAMnCC,KAAK,OAAD,OAASmM,EAAU4B,UAAU,GAA7B,OAEN,OAAOC,UAAQC,gBAAgBH,GAOV,wBAACI,GACtB,aAAa7O,KAAKe,IAAI+N,iBAAiBD,EAAI,eAGtB,wBAACE,GACtB,MAAMC,EAAUhP,KAAKiP,gBAAgBF,GACrC,IAAIG,QAAsBlP,KAAK6M,SAASlN,QAAQ,CAC9CyO,OAAQ,gBACRe,OAAQ,CAACnP,KAAK6M,SAASuC,gBAAiBJ,KAEtCK,EAAIC,OAAOnM,SAAS+L,EAActM,OAAO,GAAI,IAC7CyM,GAAK,KAAIA,GAAK,IAClBH,EAAgB,KAAOA,EAActM,MAAM,GAAI,GAAKyM,EAAE9M,SAAS,IAAIgN,SAAS,EAAG,KAC/E,MAAMC,EAAgB,IAAIC,UAAQjO,OAChCC,OAAKiO,qBAAqB,CACxBC,KAAMrE,GAA2B,CAC/B7L,UAAW,IAAIgQ,UAAQjO,OAAO0N,QAGlCvN,gBACFoN,EAAaA,EAAWa,OAAO,aAAcC,GAAcA,EAAUnS,KAAV,UAAkB8R,MAE7E,OADiBb,UAAQmB,8BAA8Bf,GAIzDE,gBAAgBJ,GACd,MAAMkB,EAAS,IAAIC,QAAMC,UACnBC,EAAYF,QAAMG,QACtB1O,OAAK2O,wBACHX,UAAQtK,YAAYkL,wBAAwB1B,UAAQmB,8BAA8BjB,MAGhFyB,EAAoB7O,OAAKiO,qBAAqB,CAClDC,KAAM,IAAIF,UAAQjO,OAChB,KACE,KAAK+O,OACHjF,GAA2B,CACzB7L,UAAW,IAAIgQ,UAAQjO,OAAO,KAAO,KAAK+O,OAAO,OAChD5S,eAMX,OAFAoS,EAAOH,OAAOM,GACdlQ,KAAKwQ,YAAYT,EAAQO,GAClBP,EAAOU,YAGhBD,YAAYT,EAAyBW,GACnC,MAAMC,EAAe,IAAIzT,YAAY,GACxB,IAAIc,SAAS2S,GACrBC,aAAa,EAAGnO,OAAO,IAAIgN,UAAQjO,OAAOkP,GAASpT,WAAW,GACnEyS,EAAOH,OAAOe,GACdZ,EAAOH,OAAOc,GAGW,4BAACjG,GAC1B,IAAIoE,EAAmC,KAGvC,IAAK,IAAIpR,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAE3B,GADAoR,QAAW7O,KAAKe,IAAI8P,gBAAgBpG,GAC1B,MAANoE,EACF,OAAOA,QAEH7O,KAAK8Q,WAAW,KAExB,OAAO,KAGa,yBACpB,MACMrG,SADezK,KAAKkN,eAAe6D,wBACnBC,iBAChBnC,QAAW7O,KAAKiR,sBAAsBxG,GAE5C,GAAU,MAANoE,EACF,MAAM,IAAIlS,MAAM,gCAGlB,IAAIuU,EAAcrC,EAAGsC,YAAY3E,QAAQ4E,WAAWC,GAC3CA,EAAEjF,MAAQ4D,QAAMsB,kBAAkBD,EAAEjF,QAAUpF,GAAcC,mBAErE,MAAO,CACLrB,UAAW,CACTC,QAAS4E,EACT3E,MAAM,KAAD,OAAOoL,EAAY3O,SAAS,MAEnCwD,SAAU,QAIK,sBACjB,MAAMwL,EAAe,CACnBnF,KAAM,CACJ7L,UAAWyG,GAAcE,mBAAmB3G,UAC5CG,UAAWsG,GAAcE,mBAAmBxG,UAC5CC,KAAMqG,GAAcE,mBAAmBvG,OAGrC6Q,EAAYxR,KAAKgN,WAAWwE,UAAUD,GAC5C,IAAIE,EACJ,UAAW,MAAMC,KAAQF,EAAUG,UAAW,CAC5C,GAAa,OAATD,EACF,OAEAD,EAAaC,EACb,MAGJ,OAAOD,EAGTG,sBAME,MAL2B,CACzBrR,UAAWiF,GAAQC,iBAAiBC,iBACpChF,UAAW,OACXC,KAAMqG,GAAcC,iBAAmBjH,KAAK8M,UAAUlK,MAAM,GAAGiP,eAKnEC,0BACE,MAAMC,EAAoB/B,QAAMsB,kBAAkBtR,KAAK4R,uBAEvD,OADA1Q,QAAQiI,IAAI,oBAAqB4I,GAC1BA,EAGTC,0BACE,MAAMC,EAAetD,UAAQuD,aAAalS,KAAK+M,WACzCoF,EAAoB,CACxB5R,UAAW0R,EAAa1R,UACxBI,KAAMsR,EAAatR,KACnBD,UAAWuR,EAAavR,WAEpB0R,EAAgBpC,QAAMsB,kBAAkBa,GAE9C,OADAjR,QAAQiI,IAAI,gBAAiBiJ,GACtBA,EAGwB,oCAC/B,MAAMX,QAAmBzR,KAAKqS,gBAC9B,QAAoBnP,KAAfuO,EACH,OAAO,EAET,MAAMa,EAAc,IAAIC,OAAaC,YAAY,IAAI/C,UAAQjO,OAAOiQ,EAAYlQ,OAC1EkR,EAA2BnD,OAAOgD,EAAYI,8BAA8BrI,2BAElF,OADAnJ,QAAQiI,IAAI,gCAAiCsJ,GACtCA,EAGO,mBAAU,IAATE,EAAQ,uDAAH,EACpB,OAAO,IAAIC,SAASC,GAAMC,WAAWD,EAAGF,M,kCE5P5C,MAAQnN,QAAF,GAAWwB,cAAX,IAA6BiC,IAEpB,MAAe8J,GAG5BjT,YAAYkT,GAAkC,KAF9CA,cAE6C,EAC3ChT,KAAKgT,SAAWA,EAaL,cAACC,GACZ,MAAMC,EAAiBzQ,OAAOwQ,EAAQnU,UAChCqU,EAAmBF,EAAQjU,OAASyD,OAAOwQ,EAAQjU,QAAUyD,OAAO,GAC1E,IAAI2Q,EAAoB3Q,OAAO,GAC3B4Q,EAAsB5Q,OAAO,GACjC,MAAM6Q,EAAyB,GACzB9B,EAAYxR,KAAKgT,SAAShG,WAAWwE,UAAU,CAAE7B,KAAMhB,UAAQuD,aAAalS,KAAKgT,SAASjG,aAChG,UAAW,MAAM2E,KAAQF,EAAUG,UAAW,CAAC,IAAD,EAE5C,GADAzQ,QAAQiI,IAAIuI,GAETA,EAAK6B,YAAYnH,MAChBsF,EAAKnQ,MAAsB,OAAdmQ,EAAKnQ,MAA+B,QAAdmQ,EAAKnQ,QAC1C6R,EAAoBF,IAKf,GACLD,EAAQO,UACRP,EAAQO,SAAS7S,QAAjB,UAA0B+Q,EAAK6B,YAAYnH,YAA3C,aAA0B,EAAuBzL,OACjD0S,EAAsBF,IAEtBC,GAAqB3Q,OAAOiP,EAAK6B,YAAYzU,UAC7CuU,GAAuB5Q,OAAOuN,QAAMyD,2BAA2B/B,EAAKnQ,MAAMmS,YAC1EJ,EAAe5V,KAAKgU,GAChB0B,GAAqBF,GAAkBG,GAAuBF,GAAkB,WATpF,GAFAC,GAAqB3Q,OAAOiP,EAAK6B,YAAYzU,UAC7CwU,EAAe5V,KAAKgU,GAChB0B,GAAqBF,GAAkBG,GAAuBF,EAAkB,MAYxF,GAAIC,EAAoBF,EACtB,MAAM,IAAIvW,MAAJ,oCAAuCuW,EAAvC,qBAAkEE,EAAlE,MAER,GAAIC,EAAsBF,EACxB,MAAM,IAAIxW,MAAJ,qCAAwCwW,EAAxC,qBAAqEE,EAArE,MAGR,MAAMM,EAAa3T,KAAK4T,0BAA0BN,EAAgBL,GAClE,IAAIlE,EAAaJ,UAAQkF,oBAAoB,CAAEC,aAAc9T,KAAKgT,SAAShG,aAE3E+B,EAAaA,EACVa,OAAO,UAAW1D,GACVA,EAAOxO,QAAQ4V,KAEvB1D,OAAO,WAAYpD,GACXA,EAAQ9O,QAAQiW,KAExB/D,OAAO,YAAamE,GACZA,EAAUrW,KAAKkO,MAEvBgE,OAAO,YAAamE,GACZA,EAAUrW,KAAKmO,MAGtBoH,EAAQO,WACVzE,EAAaA,EAAWa,OAAO,YAAamE,GACnCA,EAAUrW,KAAKoO,OAI1B,MAAMkI,QAAiBhU,KAAKgT,SAASiB,kBAAkBlF,GAEvD,aADqB/O,KAAKgT,SAASkB,kBAAkBF,GAIvDJ,0BAA0BN,EAAwBL,GAChD,MAAMd,EAAoBxD,UAAQuD,aAAalS,KAAKgT,SAASjG,WAIvDoH,EAAkB,CACtB/U,gBAJ0B4Q,QAAMsB,kBAAkBa,GAKlDtI,YAJyB7J,KAAKgT,SAASpB,sBAKvC9H,eAAgB,sBAEZsK,EAAsC,IAAI3E,UAAQjO,OACtDoI,EP3DC,SAAkCjJ,GAAyD,IAA3C,UAAE4C,EAAY,qBAA4B,uDAAJ,GAC3F,OAAOK,EAAgBL,EAAW5C,EAAM,CACtCvB,gBAAiBuE,EAAiB,IAClCkG,YAAa5F,EAAYkB,cAAYC,iBACrC0E,eAAgBxG,EAAmB,KOuDR+Q,CAAyBF,KAClDxS,gBACI2S,EAAsB,CAC1B/T,UAAWiF,GAAQQ,aAAaN,iBAChChF,UAAW,OACXC,KAAMqG,GAAcC,iBAAmBmN,EAAyBxR,MAAM,IAElE2R,EAAcjB,EAAekB,QAAO,CAACC,EAAK/C,IAAS+C,EAAMhS,OAAOiP,EAAK6B,YAAYzU,WAAW2D,OAAO,IACnGiS,EAAgBpB,EAAekB,QAAO,CAACC,EAAK/C,IAC5CA,EAAK6B,YAAYnH,KACZqI,EAAMhS,OAAOuN,QAAM2E,iBAAiBjD,EAAKnQ,OAEzCkT,GAERhS,OAAO,IACJkR,EAAmB,CACvBJ,YAAa,CACXzU,SAAU,KAAO2D,OAAOwQ,EAAQnU,UAAUyD,SAAS,IACnDoN,KAAM2E,GAER/S,KAAM,MAIFqT,EAAmBnS,OAAO8R,EAAc9R,OAAOwQ,EAAQnU,UAAY2D,OAAO,MAC1EoS,EAAqB,CACzBtB,YAAa,CACXzU,SAAU,KAAO8V,EAAiBrS,SAAS,IAC3CoN,KAAMhB,UAAQuD,aAAalS,KAAKgT,SAASjG,YAE3CxL,KAAM,MAGR,GAAI0R,EAAQO,UAAYP,EAAQjU,QAA6B,OAAnBiU,EAAQjU,QAAsC,QAAnBiU,EAAQjU,OAAkB,CAC7F2U,EAAWJ,YAAYnH,KAAO6G,EAAQO,SACtCG,EAAWpS,KAAOyO,QAAM8E,eAAerS,OAAOwQ,EAAQjU,SAEtD,MAAM+V,EAAW/E,QAAM8E,eAAeJ,EAAgBjS,OAAOwQ,EAAQjU,SAC/DgW,EAAyB,CAC7BzB,YAAa,CACXzU,SAAU,MACV6Q,KAAMhB,UAAQuD,aAAalS,KAAKgT,SAASjG,WACzCX,KAAM6G,EAAQO,UAEhBjS,KAAMwT,GAEFE,EAAuBtG,UAAQuG,oBAAoBF,GAMzD,OAJAA,EAAiBzB,YAAYzU,SAAW,KAAOmW,EAAa1S,SAAS,IAGrEsS,EAAatB,YAAYzU,SAAzB,aAA0C8V,EAAmBK,GAAc1S,SAAS,KAC7E,CAACoR,EAAYkB,EAAcG,GAGpC,MAAO,CAACrB,EAAYkB,GAMtBM,sBACE,OAAO,KAGU,oBAAC1K,GAClB,MAAMxJ,QAAejB,KAAKgT,SAAS9F,eAAekI,cAAc3K,GAEhE,OADAvJ,QAAQiI,IAAI,wBAAyBlI,GAC9BA,EAG4B,sCAAC+N,GACpC,IAAIE,QAAsBlP,KAAKgT,SAASnG,SAASlN,QAAQ,CACvDyO,OAAQ,gBACRe,OAAQ,CAACnP,KAAKgT,SAASlG,UAAWkC,KAEhCK,EAAIC,OAAOnM,SAAS+L,EAActM,OAAO,GAAI,IAGjD,OAFIyM,GAAK,KAAIA,GAAK,IAClBH,EAAgB,KAAOA,EAActM,MAAM,GAAI,GAAKyM,EAAE9M,SAAS,IAAIgN,SAAS,EAAG,KACxEL,EAGuB,iCAACF,GAC/B,IAAIE,QAAsBlP,KAAKgT,SAASnG,SAASlN,QAAQ,CACvDyO,OAAQ,WACRe,OAAQ,CAACnP,KAAKgT,SAASlG,UAAWkC,KAEhCK,EAAIC,OAAOnM,SAAS+L,EAActM,OAAO,GAAI,IAGjD,OAFIyM,GAAK,KAAIA,GAAK,IAClBH,EAAgB,KAAOA,EAActM,MAAM,GAAI,GAAKyM,EAAE9M,SAAS,IAAIgN,SAAS,EAAG,KACxEL,EAGTmG,YAAYrG,EAAesG,GACzB,MAAMC,EAAaC,aACjB,IAAI1X,WAAW,IAAI2R,UAAQjO,OAAOwN,GAAShS,iBAC3C,IAAIc,WAAW,IAAI2R,UAAQjO,OAAO8T,GAAYtY,kBAE1CyY,EAAkB,IAAIvY,YAAY,IAClCwY,EAAiB,IAAI5X,WAAW2X,GACtCC,EAAexX,IAAIqX,EAAW9V,UAAW,GACzC,IAAI4P,EAAIkG,EAAWI,MACftG,GAAK,KACPA,GAAK,IAEPqG,EAAexX,IAAI,CAACmR,GAAI,IAGxB,OADkB,IAAII,UAAQjO,OAAOiU,GAAiB9T,gBAIxDiU,gCAAgCC,EAA4CC,GAC1E,MAAMC,EAA4C,IAAItG,UAAQjO,OAC5DiI,EAA8BlF,EAA8BsR,KAC5DlU,gBACIJ,EAAO,IAAIkO,UAAQjO,OAAOsU,EAAiBC,EAA+BnT,MAAM,IAAI5F,gBAE1F,OADgBgT,QAAMG,QAAQ5O,GAAMI,gBAItCqU,0BAA0BC,GAExB,MAAMC,EAAkB,KAAO,KAAK3F,OAAO,IACrC4F,EAA4B,MAC5BC,EAA4BF,EAC5BG,EAA8C,CAClDlX,oBAAqB+W,EACrBI,sBAAuBJ,EACvBK,wBAAyBJ,EACzBjX,iBAAkBgX,EAClBzR,YAAa0R,EACbzR,cAAeyR,EACf/W,gBAAiB8W,EACjBvR,kBAAmBuR,GAEfM,EAAwB,IAAI/G,UAAQjO,ON2lDvC,SAAqCpD,GAC1C,MAAMP,EAAQ,IAAIC,WAChB,EACEW,EAAOH,OACPG,EAAOH,OACPC,EAAOD,OACPG,EAAOH,OACPE,EAAQF,OACRC,EAAOD,OACPG,EAAOH,OACPG,EAAOH,QAuBX,OArBa,IAAIN,SAASH,EAAMD,QAChCC,EAAMK,IAAI,IAAIJ,WAAWmB,EAAgBb,EAAMe,sBAAuB,GACtEtB,EAAMK,IAAI,IAAIJ,WAAWmB,EAAgBb,EAAMkY,wBAAyB,EAAI7X,EAAOH,QACnFT,EAAMK,IAAI,IAAIJ,WAAWc,EAAgBR,EAAMmY,0BAA2B,EAAI9X,EAAOH,OAASG,EAAOH,QACrGT,EAAMK,IAAI,IAAIJ,WAAWmB,EAAgBb,EAAMc,mBAAoB,EAAIT,EAAOH,OAASG,EAAOH,OAASC,EAAOD,QAC9GT,EAAMK,IACJ,IAAIJ,WAAWiB,EAAiBX,EAAMqG,cACtC,EAAIhG,EAAOH,OAASG,EAAOH,OAASC,EAAOD,OAASG,EAAOH,QAE7DT,EAAMK,IACJ,IAAIJ,WAAWc,EAAgBR,EAAMsG,gBACrC,EAAIjG,EAAOH,OAASG,EAAOH,OAASC,EAAOD,OAASG,EAAOH,OAASE,EAAQF,QAE9ET,EAAMK,IACJ,IAAIJ,WAAWmB,EAAgBb,EAAMgB,kBACrC,EAAIX,EAAOH,OAASG,EAAOH,OAASC,EAAOD,OAASG,EAAOH,OAASE,EAAQF,OAASC,EAAOD,QAE9FT,EAAMK,IACJ,IAAIJ,WAAWmB,EAAgBb,EAAMuG,oBACrC,EAAIlG,EAAOH,OAASG,EAAOH,OAASC,EAAOD,OAASG,EAAOH,OAASE,EAAQF,OAASC,EAAOD,OAASG,EAAOH,QAEvGT,EAAMD,OM3nDT6Y,CP/GC,SACLC,GAEC,IADD,UAAEnT,EAAY,wBACd,uDADyC,GAEzC,OAAOK,EAAgBL,EAAWmT,EAAsB,CACtDvX,oBAAqBwE,EAAiB,IACtC2S,sBAAuB3S,EAAiB,IACxC4S,wBAAyBjT,EAAmB,GAC5CpE,iBAAkByE,EAAiB,IACnCc,YAAanB,EAAmB,IAChCoB,cAAepB,EAAmB,GAClClE,gBAAiBuE,EAAiB,IAClCgB,kBAAmBhB,EAAiB,MOmGNgT,CAA4BN,KACxD1U,gBAEIgO,EAAe,CACnBpP,UAAW2V,EACXxV,UAAW,OACXC,KAJWyV,EAAsBI,EAAW5T,MAAM,IAMpD,IAAIwJ,EACA7K,EAAO,KACP0U,IACF7J,EAAO,CACL7L,UAAW2V,EACXxV,UAAW,OACXC,KAAMuV,GAER3U,EAAO,KAAO,KAAKgP,OAAO,KAE5B,MAAMmB,EAAa,CACjB6B,YAAa,CACX5D,OACAvD,OACAtN,SAAUqX,GAEZ5U,QAGF,MAAO,KADkBoN,UAAQuG,oBAAoBxD,GAC9BnP,SAAS,IAGb,sBAAC0Q,GACpB,MAAMzQ,QAAgBxC,KAAKgT,SAAS/F,KAAK2J,IAAI/T,YAAkB,OAAPoQ,QAAO,IAAPA,OAAA,EAAAA,EAASnG,YAAa9M,KAAKgT,SAASlG,WAC5F,MAAO,KAAOwC,OAAO9M,GAASD,SAAS,IAGpB,sBAAC0Q,GACpB,MAAMzB,EAAYxR,KAAKgT,SAAShG,WAAWwE,UAAU,CACnD7B,KAAMhB,UAAQuD,aAAalS,KAAKgT,SAASjG,WACzCX,KAAM,QACNyK,mBAAoB,CAAC,MAAO,SAE9B,IAAIC,EAAerU,OAAO,GAC1B,UAAW,MAAMiP,KAAQF,EAAUG,UACjCmF,GAAgBrU,OAAOiP,EAAK6B,YAAYzU,UAE1C,MAAO,KAAOgY,EAAavU,SAAS,IAGhB,uBAAC0Q,GACrB,MAAMhS,EAAiC,CAAE8V,SAAU,IACnD,IAAIC,EAAW,GACf,IAAK,IAAIlR,EAAQ,EAAGA,EAAQmN,EAAQgE,UAAU3Z,OAAQwI,IAAS,CAC7D,MAAM1D,EAAU6Q,EAAQgE,UAAUnR,GAE5BoR,EADe,IAAIlX,KAAKgT,SAAS/F,KAAK2J,IAAIO,SAASpL,GAAiBE,SAAU7J,GAC5CgV,QAAQC,UAAUrX,KAAKgT,SAASlG,WAAWwK,OACnFN,EAAStZ,KAAKwZ,GAOhB,aALMtE,QAAQ2E,IAAIP,GAAU3I,MAAMmJ,IAChCA,EAAOC,SAASrZ,IACd6C,EAAO8V,SAASrZ,KAAK,KAAO4R,OAAOlR,GAAOmE,SAAS,WAGhDtB,EAGY,sBAACgS,GACpB,MAAMhS,EAAgC,CAAE8V,SAAU,IAClD,IAAK,IAAIjR,EAAQ,EAAGA,EAAQmN,EAAQyE,MAAMpa,OAAQwI,IAAS,CACzD,MAAMsG,EAAO6G,EAAQyE,MAAM5R,GACrB0L,EAAYxR,KAAKgT,SAAShG,WAAWwE,UAAU,CACnD7B,KAAMhB,UAAQuD,aAAalS,KAAKgT,SAASjG,WACzCX,SAEF,IAAI0K,EAAerU,OAAO,GAC1B,UAAW,MAAMiP,KAAQF,EAAUG,UACjCmF,GAAgBrU,OAAOuN,QAAMyD,2BAA2B/B,EAAKnQ,MAAMmS,YACnEoD,GAAgBrU,OAAO,GAEzBxB,EAAO8V,SAASrZ,KAAK,KAAOoZ,EAAavU,SAAS,KAEpD,OAAOtB,EAGW,qBAClB4N,EACA8I,EACA7Y,GAKA,MAAMoU,EAAiBpU,EAAW2D,OAAO,KACzC,IAAIqU,EAAerU,OAAO,GAC1B,MAAM6Q,EAAyB,GACzB9B,EAAYxR,KAAKgT,SAAShG,WAAWwE,UAAU,CAAE7B,KAAMgI,EAAYvL,KAAM,UAC/E,UAAW,MAAMsF,KAAQF,EAAUG,UACjC,KAAKD,EAAKnQ,MAAsB,OAAdmQ,EAAKnQ,MAA+B,QAAdmQ,EAAKnQ,MAAgC,SAAdmQ,EAAKnQ,QAClEuV,GAAgBrU,OAAOiP,EAAK6B,YAAYzU,UACxCwU,EAAe5V,KAAKgU,GAChBoF,GAAgB5D,GAAgB,MAGxC,GAAI4D,EAAe5D,EACjB,MAAM,IAAIvW,MAAJ,oCAAuCuW,EAAvC,qBAAkE4D,EAAlE,MAER,MAAMc,EAAqB,CACzBrE,YAAa,CACXzU,SAAU,KAAO2D,OAAOqU,EAAe5D,GAAgB3Q,SAAS,IAChEoN,KAAMgI,GAERpW,KAAM,MAIR,OADAsN,GADAA,EAAKA,EAAGe,OAAO,UAAW1D,GAAWA,EAAOxO,QAAQ4V,MAC5C1D,OAAO,WAAYpD,GAAYA,EAAQ9O,KAAKka,MCxXjD,MAAMC,GAAa,CACxB,CACEC,OAAQ,OACRzW,KAAM,WACN0W,SAAU,GACVC,SAAU,4DACV9Y,iBAAkB,GAClBkD,QAAS,6CACT6V,eAAgB,qEAChBC,OAAQ,CACN3X,UAAW,qEACXG,UAAW,OACXC,KAAM,uEAGV,CACEmX,OAAQ,MACRzW,KAAM,WACN0W,SAAU,GACVC,SAAU,2DACV9Y,iBAAkB,GAClBkD,QAAS,6CACT6V,eAAgB,qEAChBC,OAAQ,CACN3X,UAAW,qEACXG,UAAW,OACXC,KAAM,uEAGV,CACEmX,OAAQ,MACRzW,KAAM,eACN0W,SAAU,GACVC,SACE,ikCACF9Y,iBAAkB,GAClBkD,QAAS,6CACT6V,eAAgB,qEAChBC,OAAQ,CACN3X,UAAW,qEACXG,UAAW,OACXC,KAAM,yECRJ6E,QAAF,GAAWwB,cAAX,IAA6BiC,IAEpB,MAAMkP,WAA+BpF,GAClDqF,aACE,MAAO,KAGTC,sBACE,MAAMvN,EAAoB,GAiB1B,OAhBA+M,GAAWJ,SAASa,IAClB,MAAMC,EAAwB,CAC5BhY,UAAW+X,EAAMJ,OAAO3X,UACxBI,KAAM2X,EAAMJ,OAAOvX,KACnBD,UAAW4X,EAAMJ,OAAOxX,WAEpB8X,EAAkBxI,QAAMsB,kBAAkBiH,GAChDzN,EAAIpN,KAAK,CACP2D,KAAMiX,EAAMjX,KACZyW,OAAQQ,EAAMR,OACdC,SAAUO,EAAMP,SAChB3V,QAASkW,EAAMlW,QACf4V,SAAUM,EAAMN,SAChB9Y,iBAAkBsZ,OAGf1N,EAGT2N,qBACE,MAAM3N,EAAc,GAepB,OAdA+M,GAAWJ,SAASa,IAClB,MAAMC,EAAwB,CAC5BhY,UAAW+X,EAAMJ,OAAO3X,UACxBI,KAAM2X,EAAMJ,OAAOvX,KACnBD,UAAW4X,EAAMJ,OAAOxX,WAE1BoK,EAAIpN,KAAK,CACP0O,KAAMmM,EACNlX,KAAMiX,EAAMjX,KACZyW,OAAQQ,EAAMR,OACdC,SAAUO,EAAMP,SAChBC,SAAUM,EAAMN,cAGblN,EAGS,qBAChB,MAAM4N,EAAe1Y,KAAK2Y,8BAA8B3Y,KAAKgT,SAASlG,WACtE5L,QAAQiI,IAAI,mBAAoBuP,GAChC,MAAMpF,EAAmC,GACnC9B,EAAYxR,KAAKgT,SAAShG,WAAWwE,UAAU,CAAE7B,KAAM+I,EAAanT,SACpEkN,QAAiCzS,KAAKgT,SAASN,8BAE/CT,EAAetD,UAAQuD,aAAalS,KAAKgT,SAASjG,WAClDoF,EAAoB,CACxB5R,UAAW0R,EAAa1R,UACxBI,KAAMsR,EAAatR,KACnBD,UAAWuR,EAAavR,WAEpB0R,EAAgBpC,QAAMsB,kBAAkBa,GAC9CjR,QAAQiI,IAAI,oBAAqBiJ,GAEjC,UAAW,MAAMV,KAAQF,EAAUG,UAAW,CAC5C,MAAMiH,EAAclH,EAAK6B,YAAY5D,KAAKhP,KACpCkY,EAAW,IAAItG,OAAauG,mBAAmB,IAAIrJ,UAAQjO,OAAZ,YAAwBoX,EAAYhW,MAAM,OAE/F,GAAgB,MAAZiW,EACF,SAGF,MAAME,EAAgBzJ,OAAOuJ,EAASG,2BAA2B3O,2BAC3D4O,EAAoBvH,EAAK6B,YAAY5D,KAAKhP,KAAKuY,SAAS9G,EAAc1D,UAAU,IAEtF,IACIyK,EADAC,EAAe,KAAO,KAAK7I,OAAO,IAElCvR,EAAoB,MAExB,GAAI0S,EAAK6B,YAAYnH,KAAM,CACzB,MAAMoH,EAAmB,CACvBjT,UAAWmR,EAAK6B,YAAYnH,KAAK7L,UACjCI,KAAM+Q,EAAK6B,YAAYnH,KAAKzL,KAC5BD,UAAWgR,EAAK6B,YAAYnH,KAAK1L,WAEnC0Y,EAAepJ,QAAMsB,kBAAkBkC,GAEvC2F,EADyBnZ,KAAKqY,sBACLgB,MAAMC,GAAMA,EAAEpa,mBAAqBka,IAC5Dpa,EAAM,YAAQgR,QAAM2E,iBAAiBjD,EAAKnQ,MAAMgB,SAAS,KAGvD0W,GACF3F,EAAe5V,KAAK,CAClBgU,OACA6H,sBAAuBR,EACvBS,qBAAsBC,KAAKC,IAAI,EAAGX,EAAgBtG,GAClD3T,SAAU4S,EAAK6B,YAAYzU,SAC3BE,SACAE,iBAAkBka,EAClBD,UAIN,MAAMQ,EAAoBrG,EAAesG,MAAK,CAACC,EAAGC,IACzCD,EAAEN,sBAAwBO,EAAEP,wBAGrC,OADArY,QAAQiI,IAAI,wBAAyBwQ,GAC9BA,EAGThB,8BAA8B/L,GAC5B,GAA0B,KAAtBA,EAAWtP,SAAkBsP,EAAWmN,WAAW,MACrD,MAAM,IAAIpd,MAAM,6BAElB,MAAMoV,EAAoB/R,KAAKgT,SAASlB,0BAExC,MAAO,CACLvM,OAAQ,CACNhF,UAAWiF,GAAQsB,gBAAgBpB,iBACnChF,UAAW,OACXC,KAAK,GAAD,OAAKqG,GAAcC,kBAAnB,OAAsC8K,EAAkBnP,MAAM,KAEpEoX,YAAa,QAIjBC,kBAAkBhH,GAChB,MAAMiH,EAAe,IAAIC,KAEzB,OADAna,KAAKoa,SAASF,EAAcjH,GACrBiH,EAGK,eAACA,EAA4BjH,GACzCiH,EAAaG,KAAK,WAClB,MAAMvE,EAAiB9O,GAAcC,iBAC/BqT,EAAqB9U,GAAQC,iBAAiBC,iBACpDxE,QAAQiI,IAAI,+EAAgF8J,EAASjT,KAAKgT,UAE1G,MAAMb,EAAYxD,UAAQuD,aAAae,EAAQsH,oBAAsBva,KAAKgT,SAASjG,WAC7EqF,EAAgBpC,QAAMsB,kBAAkBa,GAExCqI,EAA0B,CAC9Bja,UAAW+Z,EACX5Z,UAAW,OACXC,KAAMmV,EAJW9V,KAAKgT,SAASlG,UAIGlK,MAAM,IAEpCmP,EAAoB/B,QAAMsB,kBAAkBkJ,GAClDtZ,QAAQiI,IAAI,uBAAwB4I,GACpC,MAAM0I,QAAeza,KAAKgT,SAAS9F,eAAewN,yBAAyB3I,GAC3E,IAAK0I,EACH,MAAM,IAAI9d,MAAM,qBAElB,MAAMsZ,EAAsC,uEAA7BhD,EAAQ/T,iBACjByb,EAAc3a,KAAKgW,0BAA0BC,GACnD,GAAIxT,OAAOwQ,EAAQnU,UAAY2D,OAAOkY,GACpC,MAAM,IAAIhe,MAAJ,8BACmB8F,OAAOkY,GAD1B,wCACsElY,OAAOwQ,EAAQnU,UADrF,MAIR,MAAMH,QAAyBqB,KAAKgT,SAAS9F,eAAe0N,SAASH,GACrEvZ,QAAQiI,IAAI,SAAUxK,GACtB,MAEMkc,EAA6B,KAAO,KAAKtK,OAAO,IAGhDsF,EAA6C,CACjDlX,MAAO,KAAO8D,OAAO9D,GAAO4D,SAAS,IACrCzD,SAAU,KAAO2D,OAAOwQ,EAAQnU,UAAUyD,SAAS,IACnDvD,OAAQ,KAAOyD,OAAOwQ,EAAQjU,QAAQuD,SAAS,IAC/CrD,iBAAkB+T,EAAQ/T,iBAC1BC,oBAAqB4S,EACrBtN,YAV4B,MAW5BC,cAZ8B,MAa9BtF,gBAAiBgT,EACjBzN,kBAAmBkW,EACnBxb,IAAK,CACHgD,QAbyB,MAczBrD,OAbyB,QAgB7BkC,QAAQiI,IAAI,wBAAyB0M,GACrC,MAAM7G,EAAUhP,KAAK4V,gCAAgCC,EAAsBC,GAC3E5U,QAAQiI,IAAI,WAAY6F,GACxB,MAAM8L,QAAiD9a,KAAK+a,gCAAgC/L,GAC5F9N,QAAQiI,IAAI,iCAAkC2R,GAC9C,MAAMhN,EAAuC,CAC3CvO,IAAKsW,EACLpW,UAAWqb,GAIb,IAAI7Z,EAFJC,QAAQiI,IAAI,qBAAsB2E,GAGlC,IACE7M,QAAejB,KAAKgT,SAAS9F,eAAea,wBAAwBD,GACpE,MAAOwL,GAEP,YADAY,EAAaG,KAAK,QAASf,GAG7BY,EAAaG,KAAK,OAAQpZ,GAC1BC,QAAQiI,IAAI,6BAA8BlI,GAE1C,IAAI+Z,EAAO,EACX,MAAMC,EAAYC,aAAYC,UAC5BH,IACA,MAAMI,QAAwBpb,KAAKoV,cAAcnU,GAC7Cma,GAAoC,YAAtBA,EAAWC,SAC3Bna,QAAQiI,IAAI,sBAAuBiS,GACnClB,EAAaG,KAAK,UAAWpZ,IAE3Bma,GAAoC,cAAtBA,EAAWC,SAC3Bna,QAAQiI,IAAI,wBAAyBiS,GACrClB,EAAaG,KAAK,UAAWpZ,GAC7Bqa,cAAcL,IAEG,OAAfG,GAAuBJ,EAdb,MAeZd,EAAaG,KAAK,OAAQpZ,GAC1Bqa,cAAcL,MAEf,KAGO,aAAChI,GACX,MAAMlG,EAAY/M,KAAKgT,SAASjG,UAC1BmL,EAASvJ,UAAQuD,aAAanF,GAC9BwO,EAAsB,GAC5B,GAAItI,EAAQvB,KAAK6B,YAAYnH,KAAM,CACjC,MAAMoP,EAAgB,CACpBjI,YAAa,CACXzU,SAAU,MACV6Q,KAAMuI,EACN9L,KAAM6G,EAAQvB,KAAK6B,YAAYnH,MAEjC7K,KAAM0R,EAAQvB,KAAKnQ,MAEf0T,EAAuBtG,UAAQuG,oBAAoBsG,GACnDC,EAAehZ,OAAOwQ,EAAQvB,KAAK6B,YAAYzU,UAAYmW,EAEjEsG,EAAY7d,KAAK,CACf6V,YAAa,CACXzU,SAAS,KAAD,OAAO2c,EAAalZ,SAAS,KACrCoN,KAAMuI,GAER3W,KAAM,OAERga,EAAY7d,KAAK,CACf6V,YAAa,CACXzU,SAAS,KAAD,OAAOmW,EAAa1S,SAAS,KACrCoN,KAAMuI,EACN9L,KAAM6G,EAAQvB,KAAK6B,YAAYnH,MAEjC7K,KAAM0R,EAAQvB,KAAKnQ,YAGrBga,EAAY7d,KAAK,CACf6V,YAAa,CACXzU,SAAUmU,EAAQvB,KAAK6B,YAAYzU,SACnC6Q,KAAMuI,EACN9L,KAAM6G,EAAQvB,KAAK6B,YAAYnH,MAEjC7K,KAAM0R,EAAQvB,KAAKnQ,OAGvB,MAKMma,EAA8B,CAClC/L,KALA,aACA,IAAIF,UAAQjO,OAAOuI,EAAqC0F,UAAQtK,YAAYwW,qBAAqB,MAC9Fha,gBACAiB,MAAM,IAILgZ,EAAoB,IAAInM,UAAQjO,OACpCC,OAAKiO,qBAAqBD,UAAQtK,YAAYwW,qBAAqBD,KACnE/Z,gBAEF,IAAIoN,EAAaJ,UAAQkF,oBAAoB,CAAEC,aAAc9T,KAAKgT,SAAShG,aAC3E,MAAM6O,EAA6B,CACjCjW,UAAW,CACTC,QAASL,GAAQsB,gBAAgBnB,SAASC,UAAUC,QACpDC,MAAON,GAAQsB,gBAAgBnB,SAASC,UAAUE,OAEpDC,SAAUP,GAAQsB,gBAAgBnB,SAASI,UAEvC+V,QAA+B9b,KAAKgT,SAAS+I,mBACnDhN,EAAaA,EACVa,OAAO,UAAW1D,GACVA,EAAOxO,KAAKuV,EAAQvB,QAE5B9B,OAAO,WAAYpD,GACXA,EAAQ9O,QAAQ6d,KAExB3L,OAAO,YAAamE,GACZA,EAAUrW,KAAKme,KAEvBjM,OAAO,YAAamE,GACZA,EAAUrW,KAAKoe,KAEvBlM,OAAO,YAAamE,GACZA,EAAUrW,KAAKkO,MAEvBgE,OAAO,YAAamE,GACZA,EAAUrW,KAAKmO,MAEvB+D,OAAO,aAAcC,GACbA,EAAUnS,KAAKke,KAGtB3I,EAAQvB,KAAK6B,YAAYnH,OAC3B2C,EAAaA,EAAWa,OAAO,YAAamE,GACnCA,EAAUrW,KAAKoO,OAI1BiD,QAAmB/O,KAAKgc,eAAejN,EAAYmJ,EAAQzV,OAAO,IAElE,MAAMuR,QAAiBhU,KAAKgT,SAASiB,kBAAkBlF,GAEvD,aADqB/O,KAAKgT,SAASkB,kBAAkBF,I,OCtPlD,MClFCxO,QAAF,GAAWwB,cAAX,IAA6BiC,I,YCd5B,MAAMgT,GAAuBC,wBAAoC,MAuB3DC,GAAsBC,IACjC,MAAOC,EAAeC,GAAoBC,qBAwB1C,OAtBAC,qBAAU,KACRC,MAAyBpO,MAAMxB,IAzBfA,KAelBA,EACGlN,QAAQ,CAAEyO,OAAQ,0BAA2Be,OAfjC,CACb,CACEuN,QAAS,kBACTC,UAAW,aACXC,eAAgB,CACdvb,KAAM,OACNyW,OAAQ,OACRC,SAAU,IAEZ8E,QAAS,CAAC,mDACVC,kBAAmB,CAAC,qCAMrBzO,MAAK,IAAMnN,QAAQiI,IAAI,aACvBmF,OAAOC,GAAiBrN,QAAQiI,IAAI,QAASoF,EAAMS,YAQlD+N,CAAWlQ,GAEXA,EAASlN,QAAQ,CAAEyO,OAAQ,iBAAkBC,MAAMT,IACjD,IAAKA,IAAaA,EAAS,GAAI,OAE/B,MAAMoP,EAAW,IAAIjK,GAAqB,IAAIpG,GAA6BiB,EAAS,GAAIf,EAAU,OAClGyP,EAAiBU,MAGnBnQ,EAASc,GAAG,mBAAoBC,IAC9B,IAAKA,IAAaA,EAAS,GAAI,OAAO0O,OAAiBpZ,GAEvD,MAAM8P,EAAW,IAAID,GACnB,IAAIpG,GAA6BE,EAASuC,gBAAiBvC,EAAU,OAEvEyP,EAAiBtJ,WAGpB,IAEI,eAACiJ,GAAqBE,SAAtB,CAA+B/d,MAAOie,GAAiB,KAAvD,SAA8DD,EAAMa,Y,qGClDtE,MAAMC,GAAmB,IACRC,qBAAWlB,ICLtBmB,GAAmB,SAAC5a,GAAmC,IAAlBuV,EAAiB,uDAAN,EAC3D,MAAMsF,EAAW7a,EAAQD,WACzB,GAAiB,IAAbwV,EACF,OAAOsF,EAGT,MAAMC,EAAUD,EAASza,MAAM,GAAImV,IAAa,IAC1CwF,EAAmB,MAAZD,EAAkB,IAAM,IACrC,IAAIE,EAAUH,EACXza,OAAOmV,GACPxI,SAASwI,EAAU,KACnBnV,MAAM,EAAe,MAAZ0a,EAAkB,EAAI,GAMlC,OALAE,GAAW/D,KAAKgE,MAAMnO,OAAO,KAAD,OAAMkO,IAAaD,GAAQA,GACpDG,QAAoB,MAAZJ,EAAkB,EAAI,GAC9BK,QAAQ,UAAW,MACnB/a,MAAM,GAEH,GAAN,OAAU0a,GAAV,OAAgC,MAAZE,EAAkB,GAAlB,WAA2BA,K,OCdjD,MAAMI,GAAcC,KAAOC,MAAV,wmBASD,QAAC,MAAEC,GAAH,SAAeA,GAASA,KA4BxC,MAAMC,GAAaC,OAAO,0BA4CXC,I,MAAAA,GA1CMC,IAAMC,MAAK,YAWyC,IAXrB,MAClDhgB,EADkD,YAElDigB,EAFkD,YAGlDC,KACGC,GAOmE,EAOtE,OACE,eAACX,GAAD,IACMW,EACJngB,MAAOA,EACPogB,SAAWC,IAVGC,OACM,MADNA,EAYHD,EAAME,OAAOvgB,MAAMuf,QAAQ,KAAM,OAXlBK,GAAWY,KAAkBF,EAjB7Cf,QAAQ,sBAAuB,WAkBzCU,EAAYK,IAaZG,UAAU,UACVC,MAAM,eACNC,aAAa,MACbC,YAAY,MAEZ5S,KAAK,OACL6S,QAAQ,sBACRX,YAAaA,GAAe,MAC5BY,UAAW,EACXC,UAAW,GACXC,WAAW,aCxEjB,MAAMC,GAAexB,KAAOyB,IAAV,oWAiBZC,GAAM1B,KAAOyB,IAAV,8dAgCM,SAASE,GAAT,GAAiF,IAA1D,MAAEphB,EAAF,YAASigB,EAAT,MAAsBoB,EAAtB,KAA6BC,GAA4B,EAC7F,MAAOC,EAAeC,GAAoBrD,oBAAS,IAC5CsD,EAAYC,GAAiBvD,mBAAS,IACvCF,EAAgBa,KAEtBV,qBAAU,KACUrB,WAChB,MAAM3Y,EAAUkd,QACX,OAAMrD,QAAN,IAAMA,OAAN,EAAMA,EAAe0D,oBAAsB,SAC3C,OAAM1D,QAAN,IAAMA,OAAN,EAAMA,EAAe2D,oBAAsB,GAChDF,EAActd,IAEhByd,KACC,CAAC5D,EAAeqD,IAEnBlD,qBAAU,KACJpe,IAAUgf,GAAiB3a,OAAOod,GAAa,GACjDD,GAAiB,GAEjBA,GAAiB,KAElB,CAACxhB,EAAOyhB,IAMX,OACE,gBAACR,GAAD,WACE,gBAACE,GAAD,CAAKW,UAAU,YAAf,UACE,eAAC,KAAWC,KAAZ,UAAkBV,IAClB,gBAAC,KAAWU,KAAZ,uBAA2B/C,GAAiB3a,OAAOod,GAAa,IAAM,SAExE,gBAACN,GAAD,CAAKW,UAAU,gBAAf,UACE,eAACE,GAAD,CACEF,UAAU,qBACV9hB,MAAOA,EACPkgB,YAAY,kBACZD,YAAcgC,IACZhC,EAAYgC,MAGfV,GACC,eAAC,KAAWQ,KAAZ,CAAiBD,UAAU,aAAaI,QApBzB,KACrBjC,EAAYjB,GAAiB3a,OAAOod,GAAcpd,OAAO,GAAK,IAAM,GAAI,IACxEmd,GAAiB,IAkBX,iBAIF,sBAAKM,UAAU,WAAWK,IAAI,mBAAmBC,IAAI,KACrD,eAAC,KAAWL,KAAZ,wB,2BClGR,MAAMM,GAAa5C,KAAOyB,IAAV,6HAQhB,SAASoB,GAAeC,GAA2C,IAA9BC,EAA6B,uDAArB,EAAGC,EAAkB,uDAAX,EACrD,OAAOF,EAAIjS,UAAU,EAAGkS,GAAS,MAAQD,EAAIjS,UAAUiS,EAAIrjB,OAASujB,GAG/D,MAAMC,GAAoB,KAC/B,MAAMzE,EAAgBa,KAEhBpQ,EAAYiU,mBAAQ,KACxB,GAAK1E,EACL,OAAOA,EAAcrJ,SAAShF,iBAC7B,CAACqO,IAEJ,IAAKA,IAAkBvP,EAAW,OAAO,KAOzC,OACE,eAAC,KAAD,CACEgS,MACE,gBAAC2B,GAAD,WACE,uBAAKP,UAAU,kBAAf,UACE,wBAAOc,QAAQ,GAAf,yBACA,gBAAC,KAAMC,MAAP,CAAaC,SAAO,EAApB,UACE,eAAC,KAAD,CAAOC,MAAO,CAAEC,MAAO,qBAAuBhjB,MAAOie,EAAcrJ,SAAShF,iBAC5E,eAAC,KAAD,CAAS8Q,MAAM,eAAf,SACE,eAAC,KAAD,CAAQuC,KAAM,eAACC,GAAA,EAAD,IAAkBhB,QAZxB,KACpBiB,UAAUC,UAAUC,WAAuB,OAAbpF,QAAa,IAAbA,OAAA,EAAAA,EAAerJ,SAAShF,iBAAkB,eAmBlE,uBAAKkS,UAAU,kBAAf,UACE,wBAAOc,QAAQ,GAAf,+BACA,gBAAC,KAAMC,MAAP,CAAaC,SAAO,EAApB,UACE,eAAC,KAAD,CAAOC,MAAO,CAAEC,MAAO,qBAAuBhjB,MAAOie,EAAcrJ,SAAS/E,iBAC5E,eAAC,KAAD,CAAS6Q,MAAM,eAAf,SACE,eAAC,KAAD,CAAQuC,KAAM,eAACC,GAAA,EAAD,IAAkBhB,QA5BxB,KACpBiB,UAAUC,UAAUC,WAAuB,OAAbpF,QAAa,IAAbA,OAAA,EAAAA,EAAerJ,SAAS/E,iBAAkB,kBAMxE,SA4BGyS,GAAe5T,M,OCzDtB,MAAMuS,GAAexB,aAAO6D,KAAP7D,CAAH,gHAML8D,GAA0B,KACrC,MAAMtF,EAAgBa,KAUtB,OACE,eAAC,GAAD,CAAc9Q,KAAK,UAAUkU,QAT/B,WACMjE,GAEJI,MAAyBpO,MAAMxB,IAC7BA,EAASlN,QAAQ,CAAEyO,OAAQ,4BAK7B,SACGiO,EAAgB,eAACyE,GAAD,IAAc,a,OCpBrC,MAAMc,GAAa/D,KAAOyB,IAAV,+XA8BDuC,I,GAAAA,GAXoD,IAE/D,gBAACD,GAAD,WACE,sBAAK1B,UAAU,QAAf,4BACA,sBAAKA,UAAU,UAAf,SACE,eAACyB,GAAD,SCxBR,MAAMC,GAAa/D,KAAOyB,IAAV,4PAkBDwC,I,kBAAAA,GAT8C,IAA6B,IAA5B,SAAE7E,KAAab,GAAY,EACvF,OACE,gBAAC,GAAD,IAAgBA,EAAhB,UACE,eAAC,GAAD,IACCa,M,UCLP,MAAM,KAAEkD,IAAS4B,KAEXC,GAAcnE,KAAOyB,IAAV,yHAMXuC,GAAahE,KAAOyB,IAAV,gUAqBV2C,GAAWpE,KAAOyB,IAAV,ocAgER4C,IApCkBrE,KAAOyB,IAAV,yjBAoCIzB,KAAOyB,IAAV,67BAyChB6C,GAAetE,aAAOuE,KAAPvE,CAAH,whCAoElB,SAASwE,KACP,MAAMhG,EAAgBa,KAEhBpQ,EAAS,OAAGuP,QAAH,IAAGA,OAAH,EAAGA,EAAerJ,SAASlG,WAClCvL,KAAMiB,GAAY8f,oBACxB,CAAC,iBAAkB,CAAElgB,QAAS0K,KAC9B,IACE,OAAOuP,QAAP,IAAOA,OAAP,EAAOA,EAAe2D,mBAExB,CACEuC,UAAWlG,IAIf,OAAKvP,EACAtK,EAOE,iDAAmB4a,GAAiB3a,OAAOD,GAAU,GAArD,UALH,gCACE,eAACggB,GAAA,EAAD,MAJiB,KAWzB,SAASC,KACP,MAAOC,EAAWC,GAAgBpG,oBAAS,GACrCF,EAAgBa,KAYtB,OAVAV,qBAAU,KACHH,GAELA,EAAc0D,kBAAkB1R,MAAM7L,IAChCogB,KAAGC,KAAKrgB,GAASsgB,GAAG,IACtBH,GAAa,QAGhB,CAACtG,IAGF,iCACE,+BACE,2CADF,sGAGA,0IAEEA,EAGA,eAAC,KAAD,CACEjQ,KAAK,UACLkU,QAASnF,gBACDoG,UAAUC,UAAUC,WAAuB,OAAbpF,QAAa,IAAbA,OAAA,EAAAA,EAAerJ,SAAS/E,iBAAkB,IAC9Ee,KAAQ+T,QAAQ,kCAChBC,OAAOC,SAASC,KAAO,6BAL3B,mDAFA,eAACvB,GAAD,OAiBO,SAASwB,KACtB,MAAOC,EAAUC,GAAe9G,mBAAS,KAClC+G,EAAaC,GAAkBhH,mBAAS,KACxCiH,EAAgBC,GAAqBlH,oBAAS,IAC9CmH,EAAqBC,GAA0BpH,oBAAS,IACxDqH,EAAcC,GAAmBtH,qBAClCF,EAAgBa,KAwBtBV,qBAAU,KACJlN,OAAO8T,IAAa,IACtBO,GAAuB,GAEvBA,GAAuB,KAExB,CAACP,IAUJ,OACE,gBAAC,GAAD,WACE,gBAACpB,GAAD,WACE,gBAAC,GAAD,CAAY9B,UAAU,SAAtB,UACE,eAACC,GAAD,CAAMD,UAAU,QAAhB,+BACA,eAACuC,GAAD,OAEF,gBAACR,GAAD,CAAU/B,UAAU,OAApB,UACE,eAACV,GAAD,CACEphB,MAAOglB,EACP/E,YAAagF,EACb5D,MACE,gDAEE,eAAC,KAAD,CAASX,MAAM,+HAAf,SACE,eAACgF,GAAA,EAAD,CAAoB3C,MAAO,CAAE4C,cAAe,iBAIlDrE,MAAI,IAGN,eAACwC,GAAD,UACE,eAAC,KAAD,CAAQhC,UAAU,gBAAgB8D,SAAUN,EAAqBpD,QA7DzDnF,UAEhB,GADAsI,GAAkB,GACdpH,EAAe,CACjB,MAAMvd,EAAW2D,OAAO6M,OAAO8T,GAAY3J,KAAKwK,IAAI,GAAI,IACxD,IAAIjlB,EAAS,MACT4kB,IACF5kB,EAAS,KAAOyD,OAAO6M,OAAOgU,GAAe7J,KAAKwK,IAAI,GAAIL,EAAa7L,WAAWxV,SAAS,KAE7F,MAAM2hB,QAAa7H,EAAc8H,QAAQ,CACvCrlB,SAAU,KAAOA,EAASyD,SAAS,IACnCvD,OAAQA,EACRwU,SAAQ,OAAEoQ,QAAF,IAAEA,OAAF,EAAEA,EAAcxX,OAE1BgY,KAAarB,QAAQ,CAAE/T,QAAQ,cAAD,OAAgBkV,EAAhB,qBAC9BT,GAAkB,KA+CZ,uBAKF,+BACE,eAACpB,GAAD,SAGJ,sBAAKnC,UAAU,cAEjB,gBAACiC,GAAD,CAAcrD,MAAM,sBAAsBuF,QAASb,EAAgBc,SAtDlD,KACnBb,GAAkB,IAqD2Ec,OAAQ,KAAnG,UACE,sBAAKrE,UAAU,iBAAf,SACE,eAACsC,GAAA,EAAD,MAEF,eAACrC,GAAD,uCACA,gBAACA,GAAD,yBACcmD,EADd,WAC4BM,QAD5B,IAC4BA,OAD5B,EAC4BA,EAAc9L,OAD1C,QACuDsL,EADvD,UAGA,sBAAKlD,UAAU,OAAf,2DCxVOsE,OAff,WACE,OACE,eAAC,uBAAD,CAAqBC,OAAQ,IAAIC,eAAjC,SACE,eAAC,GAAD,UACE,eAAC,IAAD,UACE,gBAAC,IAAD,WACE,eAAC,IAAD,CAAOC,KAAK,IAAIC,QAAS,eAACzB,GAAD,MACzB,eAAC,IAAD,CAAOwB,KAAK,WAAWC,QAAS,eAACzB,GAAD,gBCF7B0B,OAZUC,IACnBA,GAAeA,aAAuB7nB,UACxC8nB,OAAO,cAAc1W,MAAK,IAAkD,IAAjD,OAAE2W,EAAF,OAAUC,EAAV,OAAkBC,EAAlB,OAA0BC,EAA1B,QAAkCC,GAAc,EACzEJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,O,OCCd3X,SAAOE,iBAAiBF,SAAOG,WAAWC,SAE1C8X,IAASC,OACP,eAAC,IAAMC,WAAP,UACE,eAAC,GAAD,MAEFC,SAASC,eAAe,SAM1BZ,M,oBCbS,SAAUa,GACjB,aAEA,SAASlpB,EAAgBC,EAAQC,GAC/B,MAAM,IAAIC,MAAJ,yCAA4CD,EAA5C,qBAAiED,IAGzE,SAASG,EAAiBH,EAAQC,GAC5BD,IAAWC,GACbF,EAAgBC,EAAQC,GAI5B,SAASG,EAAkBC,GAIzB,GAHIA,aAAkBC,QAAUD,EAAOE,yBAAyBC,WAC9DH,EAASA,EAAOE,mBAEZF,aAAkBI,aACtB,MAAM,IAAIP,MAAM,iFAElB,OAAOG,EAGT,SAAS6oB,EAAwB5nB,EAAM6nB,EAAoB1b,GACrDnM,EAAKJ,WAAa,GACpBnB,EAAgBuB,EAAKJ,WAAY,MAEnC,MAAMkoB,EAAqB9nB,EAAKqC,UAAU,GAAG,GAE7C,GADAxD,EAAiBmB,EAAKJ,WAAYkoB,GACP,IAAvBA,EACF,MAAO,CAACA,GAENA,EAAqB,GACvBrpB,EAAgBuB,EAAKJ,WAAY,MAEnC,MAAMmoB,EAAc/nB,EAAKqC,UAAU,GAAG,GACtC,GAAI0lB,EAAc,IAAM,GAAKA,EAAc,EACzC,MAAM,IAAInpB,MAAJ,gCAAmCmpB,IAE3C,MAAMzoB,EAAYyoB,EAAc,EAAI,EACpC,GAAIzoB,EAAYuoB,EACd,MAAM,IAAIjpB,MAAJ,2CAA8CipB,EAA9C,qBAA6EvoB,IAC9E,IAAK6M,GAAc7M,EAAYuoB,EACpC,MAAM,IAAIjpB,MAAJ,sDAAyDipB,EAAzD,qBAAwFvoB,IAEhG,GAAIwoB,EAAqBC,EACvB,MAAM,IAAInpB,MAAJ,mDAAsDmpB,IAE9D,MAAMtoB,EAAU,GAChB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAWI,IAAK,CAClC,MAAMgG,EAAQ,EAAQ,EAAJhG,EAClBD,EAAQE,KAAKK,EAAKqC,UAAUqD,GAAO,IAErCjG,EAAQE,KAAKmoB,GACb,IAAK,IAAIpoB,EAAI,EAAGA,EAAID,EAAQF,OAAS,EAAGG,IACtC,GAAID,EAAQC,GAAKD,EAAQC,EAAI,GAC3B,MAAM,IAAId,MAAJ,uBAA0Bc,EAA1B,aAAgCD,EAAQC,GAAxC,wCAA0EA,EAAI,EAA9E,aAAoFD,EAAQC,EAAI,KAG1G,OAAOD,EAGT,SAASL,EAAeC,GACtB,MAAMC,EAAYD,EAAQE,OAC1B,IAAIC,EAAY,GAAKF,EAAY,GACjC,MAAMG,EAAU,GAEhB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAWI,IAC7BD,EAAQE,KAAKH,GACbA,GAAaH,EAAQK,GAAGE,WAG1B,MAAMC,EAAS,IAAIV,YAAYK,GACzBM,EAAQ,IAAIC,WAAWF,GACvBG,EAAO,IAAIC,SAASJ,GAE1BG,EAAKE,UAAU,EAAGV,GAAW,GAC7B,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAWI,IAC7BM,EAAKE,UAAU,EAAQ,EAAJR,EAAOD,EAAQC,IAAI,GACtCI,EAAMK,IAAI,IAAIJ,WAAWV,EAAQK,IAAKD,EAAQC,IAEhD,OAAOG,EAGT,MAAMmoB,EACJjmB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WAA8B,IAArBmK,EAAoB,wDACvBlK,KAAKjC,KAAKJ,WAAa,GACzBnB,EAAgBwD,KAAKjC,KAAKJ,WAAY,MAExC,MAAMkoB,EAAqB7lB,KAAK1C,SAAWe,GAAOC,OAAS,EAC3D1B,EAAiBoD,KAAKjC,KAAKJ,WAAYkoB,GACvC,IAAK,IAAIpoB,EAAI,EAAGA,EAAI,EAAGA,IACRuC,KAAKC,QAAQxC,GACrBsC,SAASmK,GAIlBjK,QAAQxC,GACN,OAAO,IAAIY,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInF,EAAIY,GAAOC,OAAQ,GAAKb,EAAI,GAAKY,GAAOC,QAAS,CAC5FyB,UAAU,IAIdzC,SACE,OAAO0C,KAAKjC,KAAKqC,UAAU,GAAG,IAIlC,SAAS4lB,EAAmB5nB,GAC1B,MAAMP,EAAQ,IAAIC,WAAW,EAAIO,GAAOC,OAASF,EAAMd,QACvD,IAAIU,SAASH,EAAMD,QAAQK,UAAU,EAAGG,EAAMd,QAAQ,GACtD,IAAK,IAAIG,EAAI,EAAGA,EAAIW,EAAMd,OAAQG,IAAK,CACrC,MAAMwoB,EAAavnB,GAAgBN,EAAMX,IACzCI,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,EAAIxoB,EAAIY,GAAOC,QAEvD,OAAOT,EAAMD,OAGf,MAAMsoB,EACJpmB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITomB,gBACE,OAAO,IAAI1nB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAInE,GAAOH,QAAS,CAAEyB,UAAU,IAG9EqmB,WACE,OAAO,IAAI7nB,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInE,GAAOH,OAAQ,EAAIG,GAAOH,OAASC,GAAOD,QAAS,CAC9FyB,UAAU,IAIdA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAYuoB,EAAiB5nB,QACxD0B,KAAKmmB,gBAAgBpmB,SAASmK,GAC9BlK,KAAKomB,WAAWrmB,SAASmK,GAEhB,cACT,OAAO,EAAIzL,GAAOH,OAASC,GAAOD,QAItC,SAAS+nB,EAA0BjoB,GACjC,MAAMP,EAAQ,IAAIC,WAAW,EAAIW,GAAOH,OAASC,GAAOD,QAIxD,OAHA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAMkoB,cAAe,GAC9DzoB,EAAMK,IAAI,IAAIJ,WAAWc,GAAgBR,EAAMmoB,QAAS,EAAI9nB,GAAOH,QAC5DT,EAAMD,OAGf,MAAM4oB,EACJ1mB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITomB,gBACE,OAAO,IAAI1nB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAInE,GAAOH,QAAS,CAAEyB,UAAU,IAG9EqmB,WACE,OAAO,IAAI/nB,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInE,GAAOH,OAAQ,EAAIG,GAAOH,OAASD,GAAOC,QAAS,CAC9FyB,UAAU,IAIdA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAY6oB,EAAmBloB,QAC1D0B,KAAKmmB,gBAAgBpmB,SAASmK,GAC9BlK,KAAKomB,WAAWrmB,SAASmK,GAEhB,cACT,OAAO,EAAIzL,GAAOH,OAASD,GAAOC,QAItC,SAASmoB,EAA4BroB,GACnC,MAAMP,EAAQ,IAAIC,WAAW,EAAIW,GAAOH,OAASD,GAAOC,QAIxD,OAHA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAMkoB,cAAe,GAC9DzoB,EAAMK,IAAI,IAAIJ,WAAWY,GAAgBN,EAAMmoB,QAAS,EAAI9nB,GAAOH,QAC5DT,EAAMD,OAGf,MAAM8oB,EACJ5mB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAIT4mB,sBACE,OAAO,IAAIloB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAInE,GAAOH,QAAS,CAAEyB,UAAU,IAG9E6mB,aACE,OAAO,IAAIJ,EACTxmB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInE,GAAOH,OAAQ,EAAIG,GAAOH,OAASkoB,EAAmBloB,QACjF,CAAEyB,UAAU,IAIhB8mB,WACE,OAAO,IAAIX,EACTlmB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASkoB,EAAmBloB,OACvC,EAAIG,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,QAEnE,CAAEyB,UAAU,IAIhB+mB,uBACE,OAAO,IAAIroB,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OACjE,EAAIG,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,QAEnF,CAAEyB,UAAU,IAIhBgnB,kBACE,OAAO,IAAItoB,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,OACjF,EAAIG,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,OAASG,GAAOH,QAEnG,CAAEyB,UAAU,IAIhB2S,8BACE,OAAO,IAAInU,GACTyB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,OAASG,GAAOH,OACjG,EACEG,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,QAEX,CAAEyB,UAAU,IAIhBinB,YACE,OAAOhnB,KAAKjC,KAAKmC,SACf,EACEzB,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,QAIbyB,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAY+oB,EAAcpoB,QACrD0B,KAAK2mB,sBAAsB5mB,SAASmK,GACpClK,KAAK4mB,aAAa7mB,SAASmK,GAC3BlK,KAAK6mB,WAAW9mB,SAASmK,GACzBlK,KAAK8mB,uBAAuB/mB,SAASmK,GACrClK,KAAK+mB,kBAAkBhnB,SAASmK,GAChClK,KAAK0S,8BAA8B3S,SAASmK,GAEnC,cACT,OACE,EACAzL,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACP,GAKN,SAAS2oB,EAAuB7oB,GAC9B,MAAMP,EAAQ,IAAIC,WAChB,EACEW,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACP,GAEEP,EAAO,IAAIC,SAASH,EAAMD,QA0BhC,OAzBAC,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAM8oB,qBAAsB,GACrErpB,EAAMK,IAAI,IAAIJ,WAAW2oB,EAA4BroB,EAAM+oB,UAAW,EAAI1oB,GAAOH,QACjFT,EAAMK,IAAI,IAAIJ,WAAWuoB,EAA0BjoB,EAAMgpB,QAAS,EAAI3oB,GAAOH,OAASkoB,EAAmBloB,QACzGT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAMipB,sBACrC,EAAI5oB,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,QAEnET,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAMkpB,iBACrC,EAAI7oB,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,QAEnFT,EAAMK,IACJ,IAAIJ,WAAWc,GAAgBR,EAAMmpB,8BACrC,EAAI9oB,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,OAASG,GAAOH,QAEnGP,EAAK0C,SACH,EACEhC,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACTF,EAAMid,QAEDxd,EAAMD,OAGf,MAAM4U,EACJ1S,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAIT4mB,sBACE,OAAO,IAAIloB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAInE,GAAOH,QAAS,CAAEyB,UAAU,IAG9E6mB,aACE,OAAO,IAAIJ,EACTxmB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInE,GAAOH,OAAQ,EAAIG,GAAOH,OAASkoB,EAAmBloB,QACjF,CAAEyB,UAAU,IAIhB8mB,WACE,OAAO,IAAIX,EACTlmB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASkoB,EAAmBloB,OACvC,EAAIG,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,QAEnE,CAAEyB,UAAU,IAIhB+mB,uBACE,OAAO,IAAIroB,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OACjE,EAAIG,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,QAEnF,CAAEyB,UAAU,IAIhBgnB,kBACE,OAAO,IAAItoB,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,OACjF,EAAIG,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,OAASG,GAAOH,QAEnG,CAAEyB,UAAU,IAIhBynB,uBACE,OAAO,IAAIjpB,GACTyB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,OAASG,GAAOH,OACjG,EACEG,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,QAEX,CAAEyB,UAAU,IAIhB2S,8BACE,OAAO,IAAInU,GACTyB,KAAKjC,KAAKH,OAAOgF,MACf,EACEnE,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACT,EACEG,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPC,GAAOD,QAEX,CAAEyB,UAAU,IAIhBinB,YACE,OAAOhnB,KAAKjC,KAAKmC,SACf,EACEzB,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPC,GAAOD,QAIb8Z,aACE,OAAOpY,KAAKjC,KAAKmC,SACf,EACEzB,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPC,GAAOD,OACP,GAINyB,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAY6U,EAAYlU,QACnD0B,KAAK2mB,sBAAsB5mB,SAASmK,GACpClK,KAAK4mB,aAAa7mB,SAASmK,GAC3BlK,KAAK6mB,WAAW9mB,SAASmK,GACzBlK,KAAK8mB,uBAAuB/mB,SAASmK,GACrClK,KAAK+mB,kBAAkBhnB,SAASmK,GAChClK,KAAKwnB,uBAAuBznB,SAASmK,GACrClK,KAAK0S,8BAA8B3S,SAASmK,GAEnC,cACT,OACE,EACAzL,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPC,GAAOD,OACP,EACA,GAKN,SAASmpB,EAAqBrpB,GAC5B,MAAMP,EAAQ,IAAIC,WAChB,EACEW,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPC,GAAOD,OACP,EACA,GAEEP,EAAO,IAAIC,SAASH,EAAMD,QAiDhC,OAhDAC,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAM8oB,qBAAsB,GACrErpB,EAAMK,IAAI,IAAIJ,WAAW2oB,EAA4BroB,EAAM+oB,UAAW,EAAI1oB,GAAOH,QACjFT,EAAMK,IAAI,IAAIJ,WAAWuoB,EAA0BjoB,EAAMgpB,QAAS,EAAI3oB,GAAOH,OAASkoB,EAAmBloB,QACzGT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAMipB,sBACrC,EAAI5oB,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,QAEnET,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAMkpB,iBACrC,EAAI7oB,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,QAEnFT,EAAMK,IACJ,IAAIJ,WAAWc,GAAgBR,EAAMspB,sBACrC,EAAIjpB,GAAOH,OAASkoB,EAAmBloB,OAAS4nB,EAAiB5nB,OAASG,GAAOH,OAASG,GAAOH,QAEnGT,EAAMK,IACJ,IAAIJ,WAAWc,GAAgBR,EAAMmpB,8BACrC,EACE9oB,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,QAEXP,EAAK0C,SACH,EACEhC,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPC,GAAOD,OACTF,EAAMid,QAERtd,EAAK0C,SACH,EACEhC,GAAOH,OACPkoB,EAAmBloB,OACnB4nB,EAAiB5nB,OACjBG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPC,GAAOD,OACP,EACFF,EAAM8P,SAEDrQ,EAAMD,OAGf,MAAM+pB,EACJ7nB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GAYtD,GAXA,IAAIU,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIxB,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIxB,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,KAAM,CAAEuC,UAAU,IAASA,WACjF,IAAIxB,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,IAAKA,EAAQ,KAAM,CAAEuC,UAAU,IAASA,WAC9EvC,EAAQ,IAAMA,EAAQ,MAAQ,EAChC,MAAM,IAAIb,MAAJ,+CAAkDa,EAAQ,IAA1D,cAAmEA,EAAQ,MAEnF,IAAIoqB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,IAAKA,EAAQ,KAAM,CAAEuC,UAAU,IAASA,WACrF,IAAI6nB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,IAAKA,EAAQ,KAAM,CAAEuC,UAAU,IAASA,WAGvF8nB,0BACE,MAAMpkB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EioB,6BACE,MAAMvkB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EkoB,2BACE,MAAMxkB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EmoB,8BACE,MAAMzkB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EooB,6BACE,MAAM1kB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EqoB,yBACE,MAAM3kB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EsoB,mCACE,MAAM5kB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EuoB,kBACE,MAAM7kB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EwoB,6BACE,MAAM9kB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIlF,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EyoB,6BACE,MAAM/kB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIlF,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E0oB,oBACE,MAAMhlB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIlF,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E2oB,oBACE,MAAMjlB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIzF,SAASgC,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,IAAa7nB,SAAS,GAG3EyoB,0BACE,MAAMllB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAImkB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG/E6oB,+BACE,MAAMnlB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIiqB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIjF,SAAS8oB,EAAsBzqB,GAC7B,MAAMhB,EAAU,GAChBA,EAAQM,KAAKuB,GAAgBb,EAAMmJ,2BACnCnK,EAAQM,KAAKuB,GAAgBb,EAAMoJ,6BACnCpK,EAAQM,KAAKuB,GAAgBb,EAAMqJ,2BACnCrK,EAAQM,KAAKuB,GAAgBb,EAAMsJ,8BACnCtK,EAAQM,KAAKuB,GAAgBb,EAAMuJ,6BACnCvK,EAAQM,KAAKuB,GAAgBb,EAAMwJ,yBACnCxK,EAAQM,KAAKuB,GAAgBb,EAAMyJ,qCACnCzK,EAAQM,KAAKuB,GAAgBb,EAAM0J,iBACnC1K,EAAQM,KAAKkB,GAAgBR,EAAM2J,4BACnC3K,EAAQM,KAAKkB,GAAgBR,EAAM4J,4BACnC5K,EAAQM,KAAKkB,GAAgBR,EAAM6J,kBACnC,MAAM6gB,EAAqB,IAAI9qB,SAAS,IAAId,YAAY,IAKxD,OAJA4rB,EAAmBroB,SAAS,EAAGrC,EAAM8J,kBACrC9K,EAAQM,KAAKorB,EAAmBlrB,QAChCR,EAAQM,KAAKqrB,GAAmB3qB,EAAM+J,0BACtC/K,EAAQM,KAAKqrB,GAAmB3qB,EAAMgK,+BAC/BjL,EAAeC,GAGxB,MAAM4rB,EACJlpB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIM,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAI1B,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAI1B,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGjFmpB,YACE,MAAMzlB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIpF,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EopB,UACE,MAAM1lB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIpF,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E6a,WACE,MAAMnX,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIpF,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EqpB,UACE,MAAM3lB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIsrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI7E,SAASspB,EAA0BjrB,GACjC,MAAMhB,EAAU,GAKhB,OAJAA,EAAQM,KAAKgB,GAAgBN,EAAMgG,UACnChH,EAAQM,KAAKgB,GAAgBN,EAAMiG,QACnCjH,EAAQM,KAAKgB,GAAgBN,EAAMO,QACnCvB,EAAQM,KAAK8B,GAAepB,EAAMuC,OAC3BxD,EAAeC,GAGxB,MAAMksB,EACJxpB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIirB,EAAiBhpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC1F,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGjFwpB,SACE,MAAM9lB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIulB,EAAiBhpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGtFypB,eACE,MAAM/lB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIsrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI7E,SAAS0pB,EAAuBrrB,GAC9B,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAK2rB,EAA0BjrB,EAAMmB,MAC7CnC,EAAQM,KAAK8B,GAAepB,EAAMqB,YAC3BtC,EAAeC,GAGxB,MAAMssB,EACJ5pB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAK,IAAIN,EAAI,EAAGA,EAAID,EAAQF,OAAS,EAAGG,IACtC,IAAI6rB,EAActpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQC,GAAID,EAAQC,EAAI,IAAK,CAAEsC,UAAU,IAASA,WAI/FzC,SACE,OAAI0C,KAAKjC,KAAKJ,WAAa,EAClB,EAEAqC,KAAKjC,KAAKqC,UAAU,GAAG,GAAQ,EAAI,EAI9CH,QAAQxC,GACN,MAAMgG,EAAQ,EAAQ,EAAJhG,EACZqqB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GAC1C,IAAIskB,EAAa/nB,KAAKjC,KAAKJ,WAI3B,OAHIF,EAAI,EAAIuC,KAAK1C,WACfyqB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,IAEvC,IAAI6lB,EAActpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIrF,SAAS4pB,EAA0BvrB,GACjC,OAAOjB,EAAeiB,EAAM0M,KAAKxK,GAASmpB,EAAuBnpB,MAGnE,MAAMspB,EACJ9pB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIU,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAI1B,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGlF8pB,mBACE,MAAMpmB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E+pB,aACE,MAAMrmB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIpF,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EgqB,yBACE,MAAMtmB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIc,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI9E,SAASiqB,EAA4B5rB,GACnC,MAAMhB,EAAU,GAIhB,OAHAA,EAAQM,KAAKuB,GAAgBb,EAAM6rB,kBACnC7sB,EAAQM,KAAKgB,GAAgBN,EAAM8rB,WACnC9sB,EAAQM,KAAKuB,GAAgBb,EAAM+rB,wBAC5BhtB,EAAeC,GAGxB,MAAMgtB,EACJtqB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITsqB,2BACE,OAAO,IAAI5rB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAInE,GAAOH,QAAS,CAAEyB,UAAU,IAG9EuqB,qBACE,OAAO,IAAIjsB,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInE,GAAOH,OAAQ,EAAIG,GAAOH,OAASD,GAAOC,QAAS,CAC9FyB,UAAU,IAIdA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAYysB,EAAkB9rB,QACzD0B,KAAKqqB,2BAA2BtqB,SAASmK,GACzClK,KAAKsqB,qBAAqBvqB,SAASmK,GAE1B,cACT,OAAO,EAAIzL,GAAOH,OAASD,GAAOC,QAItC,SAASisB,EAA2BnsB,GAClC,MAAMP,EAAQ,IAAIC,WAAW,EAAIW,GAAOH,OAASD,GAAOC,QAIxD,OAHA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAMosB,0BAA2B,GAC1E3sB,EAAMK,IAAI,IAAIJ,WAAWY,GAAgBN,EAAMqsB,mBAAoB,EAAIhsB,GAAOH,QACvET,EAAMD,OAGf,MAAM8sB,EACJ5qB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIQ,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAI1B,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIxB,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIymB,EAAmBxmB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC5F,IAAIymB,EAAmBxmB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC5F,IAAI6nB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACnF,IAAIqqB,EAAkBpqB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC3F,IAAI6pB,EAAmB5pB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,KAAM,CAAEuC,UAAU,IAASA,WAG/F4qB,YACE,MAAMlnB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIlF,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E6qB,qBACE,MAAMnnB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIpF,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E8qB,qBACE,MAAMpnB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E+qB,4BACE,MAAMrnB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EgrB,eACE,MAAMtnB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIlF,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EirB,iBACE,MAAMvnB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI+iB,EAAmBxmB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGxFkrB,iBACE,MAAMxnB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI+iB,EAAmBxmB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGxFmrB,yBACE,MAAMznB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAImkB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG/EorB,uBACE,MAAM1nB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI2mB,EAAkBpqB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGvFqrB,wBACE,MAAM3nB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIisB,EAAmB5pB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI1F,SAASsrB,EAAoBjtB,GAC3B,MAAMhB,EAAU,GAWhB,OAVAA,EAAQM,KAAKkB,GAAgBR,EAAMktB,SACnCluB,EAAQM,KAAKgB,GAAgBN,EAAMmtB,oBACnCnuB,EAAQM,KAAKuB,GAAgBb,EAAMotB,oBACnCpuB,EAAQM,KAAKuB,GAAgBb,EAAMqtB,6BACnCruB,EAAQM,KAAKkB,GAAgBR,EAAMgJ,YACnChK,EAAQM,KAAK+oB,EAA4BroB,EAAMstB,eAC/CtuB,EAAQM,KAAK+oB,EAA4BroB,EAAMutB,eAC/CvuB,EAAQM,KAAKqrB,GAAmB3qB,EAAMwtB,wBACtCxuB,EAAQM,KAAK6sB,EAA2BnsB,EAAMytB,qBAC9CzuB,EAAQM,KAAKssB,EAA4B5rB,EAAM0tB,sBACxC3uB,EAAeC,GAGxB,MAAM2uB,EACJjsB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAK,IAAIN,EAAI,EAAGA,EAAID,EAAQF,OAAS,EAAGG,IACtC,IAAIitB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQC,GAAID,EAAQC,EAAI,IAAK,CAAEsC,UAAU,IAASA,WAI5FzC,SACE,OAAI0C,KAAKjC,KAAKJ,WAAa,EAClB,EAEAqC,KAAKjC,KAAKqC,UAAU,GAAG,GAAQ,EAAI,EAI9CH,QAAQxC,GACN,MAAMgG,EAAQ,EAAQ,EAAJhG,EACZqqB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GAC1C,IAAIskB,EAAa/nB,KAAKjC,KAAKJ,WAI3B,OAHIF,EAAI,EAAIuC,KAAK1C,WACfyqB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,IAEvC,IAAIinB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIlF,SAASisB,EAAuB5tB,GAC9B,OAAOjB,EAAeiB,EAAM0M,KAAKxK,GAAS+qB,EAAoB/qB,MAGhE,MAAM2rB,EACJnsB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAI2sB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACpF,IAAImsB,EAAUlsB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACnF,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC/E,IAAI2pB,EAAiB1pB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC1F,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC/E,IAAIosB,EAAqBnsB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGhGwpB,SACE,MAAM9lB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIinB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGhFqsB,aACE,MAAM3oB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIyoB,EAAUlsB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG/EssB,kBACE,MAAM5oB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIwlB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG3EusB,kBACE,MAAM7oB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIimB,EAAiB1pB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGtFwsB,gBACE,MAAM9oB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIwlB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG3EysB,iBACE,MAAM/oB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIwuB,EAAqBnsB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI5F,SAAS0sB,EAAiBruB,GACxB,MAAMhB,EAAU,GAOhB,OANAA,EAAQM,KAAK2tB,EAAoBjtB,EAAMmB,MACvCnC,EAAQM,KAAKgvB,EAAmBtuB,EAAMuuB,WACtCvvB,EAAQM,KAAK8B,GAAepB,EAAMwuB,iBAClCxvB,EAAQM,KAAKisB,EAA0BvrB,EAAMyuB,eAC7CzvB,EAAQM,KAAK8B,GAAepB,EAAM0uB,cAClC1vB,EAAQM,KAAKqvB,EAA8B3uB,EAAM4uB,cAC1C7vB,EAAeC,GAGxB,MAAM6vB,EACJntB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIQ,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIvB,GAAQwB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACjF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAImtB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGlFotB,cACE,MAAM1pB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIlF,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EkK,YACE,MAAMxG,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIjF,GAAQwB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG7EqtB,oBACE,MAAM3pB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EstB,YACE,MAAM5pB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIuvB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI9E,SAASutB,EAAwBlvB,GAC/B,MAAMhB,EAAU,GAKhB,OAJAA,EAAQM,KAAKkB,GAAgBR,EAAMU,WACnC1B,EAAQM,KAAKqB,GAAiBX,EAAMY,SACpC5B,EAAQM,KAAKuB,GAAgBb,EAAMc,mBACnC9B,EAAQM,KAAKkC,GAAgBxB,EAAMmH,SAC5BpI,EAAeC,GAGxB,MAAMmwB,EACJztB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAK,IAAIN,EAAI,EAAGA,EAAID,EAAQF,OAAS,EAAGG,IACtC,IAAIwvB,EAAejtB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQC,GAAID,EAAQC,EAAI,IAAK,CAAEsC,UAAU,IAASA,WAIhGzC,SACE,OAAI0C,KAAKjC,KAAKJ,WAAa,EAClB,EAEAqC,KAAKjC,KAAKqC,UAAU,GAAG,GAAQ,EAAI,EAI9CH,QAAQxC,GACN,MAAMgG,EAAQ,EAAQ,EAAJhG,EACZqqB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GAC1C,IAAIskB,EAAa/nB,KAAKjC,KAAKJ,WAI3B,OAHIF,EAAI,EAAIuC,KAAK1C,WACfyqB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,IAEvC,IAAIwpB,EAAejtB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAItF,SAASytB,EAA2BpvB,GAClC,OAAOjB,EAAeiB,EAAM0M,KAAKxK,GAASgtB,EAAwBhtB,MAGpE,MAAMmtB,EACJ3tB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAIT6a,WACE,OAAO,IAAIvc,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAIvE,GAAOC,QAAS,CAAEyB,UAAU,IAG9EotB,cACE,OAAO,IAAI5uB,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAIvE,GAAOC,OAAQ,EAAID,GAAOC,OAASC,GAAOD,QAAS,CAC9FyB,UAAU,IAIdkK,YACE,OAAO,IAAIzL,GACTwB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAIvE,GAAOC,OAASC,GAAOD,OAAQ,EAAID,GAAOC,OAASC,GAAOD,OAASE,GAAQF,QACtG,CAAEyB,UAAU,IAIhBqtB,oBACE,OAAO,IAAI3uB,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EAAIvE,GAAOC,OAASC,GAAOD,OAASE,GAAQF,OAC5C,EAAID,GAAOC,OAASC,GAAOD,OAASE,GAAQF,OAASG,GAAOH,QAE9D,CAAEyB,UAAU,IAIhB2tB,uBACE,OAAO,IAAIjvB,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EAAIvE,GAAOC,OAASC,GAAOD,OAASE,GAAQF,OAASG,GAAOH,OAC5D,EAAID,GAAOC,OAASC,GAAOD,OAASE,GAAQF,OAASG,GAAOH,OAASG,GAAOH,QAE9E,CAAEyB,UAAU,IAIhB4tB,gBACE,OAAO,IAAInvB,GACTwB,KAAKjC,KAAKH,OAAOgF,MACf,EAAIvE,GAAOC,OAASC,GAAOD,OAASE,GAAQF,OAASG,GAAOH,OAASG,GAAOH,OAC5E,EAAID,GAAOC,OAASC,GAAOD,OAASE,GAAQF,OAASG,GAAOH,OAASG,GAAOH,OAASE,GAAQF,QAE/F,CAAEyB,UAAU,IAIhB6tB,kBACE,OAAO,IAAIrvB,GACTyB,KAAKjC,KAAKH,OAAOgF,MACf,EAAIvE,GAAOC,OAASC,GAAOD,OAASE,GAAQF,OAASG,GAAOH,OAASG,GAAOH,OAASE,GAAQF,OAC7F,EACED,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,QAEX,CAAEyB,UAAU,IAIhB8tB,mBACE,OAAO,IAAIpvB,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EACEvE,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACT,EACED,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,QAEX,CAAEyB,UAAU,IAIhB+tB,qBACE,OAAO,IAAIrvB,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EACEvE,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,OACT,EACED,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,QAEX,CAAEyB,UAAU,IAIhBguB,SACE,OAAO,IAAIrkB,GACT1J,KAAKjC,KAAKH,OAAOgF,MACf,EACEvE,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACT,EACED,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPoL,GAAIpL,QAER,CAAEyB,UAAU,IAIhBA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAY8vB,EAAqBnvB,QAC5D0B,KAAK4a,WAAW7a,SAASmK,GACzBlK,KAAKmtB,cAAcptB,SAASmK,GAC5BlK,KAAKiK,YAAYlK,SAASmK,GAC1BlK,KAAKotB,oBAAoBrtB,SAASmK,GAClClK,KAAK0tB,uBAAuB3tB,SAASmK,GACrClK,KAAK2tB,gBAAgB5tB,SAASmK,GAC9BlK,KAAK4tB,kBAAkB7tB,SAASmK,GAChClK,KAAK6tB,mBAAmB9tB,SAASmK,GACjClK,KAAK8tB,qBAAqB/tB,SAASmK,GACnClK,KAAK+tB,SAAShuB,SAASmK,GAEd,cACT,OACE,EACA7L,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPoL,GAAIpL,QAKV,SAASmL,EAA8BrL,GACrC,MAAMP,EAAQ,IAAIC,WAChB,EACEO,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPoL,GAAIpL,QA0DR,OAxDA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWY,GAAgBN,EAAMO,QAAS,GACxDd,EAAMK,IAAI,IAAIJ,WAAWc,GAAgBR,EAAMU,WAAY,EAAIT,GAAOC,QACtET,EAAMK,IAAI,IAAIJ,WAAWiB,GAAiBX,EAAMY,SAAU,EAAIX,GAAOC,OAASC,GAAOD,QACrFT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAMc,mBACrC,EAAIb,GAAOC,OAASC,GAAOD,OAASE,GAAQF,QAE9CT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAMe,sBACrC,EAAId,GAAOC,OAASC,GAAOD,OAASE,GAAQF,OAASG,GAAOH,QAE9DT,EAAMK,IACJ,IAAIJ,WAAWiB,GAAiBX,EAAMqG,cACtC,EAAIpG,GAAOC,OAASC,GAAOD,OAASE,GAAQF,OAASG,GAAOH,OAASG,GAAOH,QAE9ET,EAAMK,IACJ,IAAIJ,WAAWc,GAAgBR,EAAMsG,gBACrC,EAAIrG,GAAOC,OAASC,GAAOD,OAASE,GAAQF,OAASG,GAAOH,OAASG,GAAOH,OAASE,GAAQF,QAE/FT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAMgB,kBACrC,EACEf,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,QAEXT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAMuG,oBACrC,EACEtG,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,QAEXT,EAAMK,IACJ,IAAIJ,WAAW6L,GAAavL,EAAMiB,MAClC,EACEhB,GAAOC,OACPC,GAAOD,OACPE,GAAQF,OACRG,GAAOH,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,QAEJT,EAAMD,OA8Cf,MAAMuuB,EACJrsB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAK,IAAIN,EAAI,EAAGA,EAAID,EAAQF,OAAS,EAAGG,IACtC,IAAIuwB,EAAkBhuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQC,GAAID,EAAQC,EAAI,IAAK,CAAEsC,UAAU,IAASA,WAInGzC,SACE,OAAI0C,KAAKjC,KAAKJ,WAAa,EAClB,EAEAqC,KAAKjC,KAAKqC,UAAU,GAAG,GAAQ,EAAI,EAI9CH,QAAQxC,GACN,MAAMgG,EAAQ,EAAQ,EAAJhG,EACZqqB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GAC1C,IAAIskB,EAAa/nB,KAAKjC,KAAKJ,WAI3B,OAHIF,EAAI,EAAIuC,KAAK1C,WACfyqB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,IAEvC,IAAIuqB,EAAkBhuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIzF,SAASgtB,EAA8B3uB,GACrC,OAAOjB,EAAeiB,EAAM0M,KAAKxK,GAASnC,EAA2BmC,MAGvE,MAAM0tB,EACJluB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAI0vB,EAAqBztB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC9F,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGjFwpB,SACE,MAAM9lB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIgqB,EAAqBztB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG1FypB,eACE,MAAM/lB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIsrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI7E,SAAS5B,EAA2BC,GAClC,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAK+L,EAA8BrL,EAAMmB,MACjDnC,EAAQM,KAAK8B,GAAepB,EAAMqB,YAC3BtC,EAAeC,GAGxB,MAAM6wB,EACJnuB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIU,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGlFmuB,OACE,MAAMzqB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EouB,OACE,MAAM1qB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIc,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI9E,SAASquB,EAAgBhwB,GACvB,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAKuB,GAAgBb,EAAMiwB,IACnCjxB,EAAQM,KAAKuB,GAAgBb,EAAMiR,IAC5BlS,EAAeC,GAGxB,MAAM8uB,EACJpsB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAK,IAAIN,EAAI,EAAGA,EAAID,EAAQF,OAAS,EAAGG,IACtC,IAAIwwB,EAAOjuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQC,GAAID,EAAQC,EAAI,IAAK,CAAEsC,UAAU,IAASA,WAIxFzC,SACE,OAAI0C,KAAKjC,KAAKJ,WAAa,EAClB,EAEAqC,KAAKjC,KAAKqC,UAAU,GAAG,GAAQ,EAAI,EAI9CH,QAAQxC,GACN,MAAMgG,EAAQ,EAAQ,EAAJhG,EACZqqB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GAC1C,IAAIskB,EAAa/nB,KAAKjC,KAAKJ,WAI3B,OAHIF,EAAI,EAAIuC,KAAK1C,WACfyqB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,IAEvC,IAAIwqB,EAAOjuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI9E,SAAS2sB,EAAmBtuB,GAC1B,OAAOjB,EAAeiB,EAAM0M,KAAKxK,GAAS8tB,EAAgB9tB,MAG5D,MAAMguB,EACJxuB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAIT6qB,qBACE,OAAO,IAAIvsB,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAIvE,GAAOC,QAAS,CAAEyB,UAAU,IAG9E4qB,YACE,OAAO,IAAIpsB,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAIvE,GAAOC,OAAQ,EAAID,GAAOC,OAASC,GAAOD,QAAS,CAC9FyB,UAAU,IAIdgrB,eACE,OAAO,IAAIxsB,GACTyB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAIvE,GAAOC,OAASC,GAAOD,OAAQ,EAAID,GAAOC,OAASC,GAAOD,OAASC,GAAOD,QACrG,CAAEyB,UAAU,IAIhBA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAY2wB,EAAUhwB,QACjD0B,KAAK4qB,qBAAqB7qB,SAASmK,GACnClK,KAAK2qB,YAAY5qB,SAASmK,GAC1BlK,KAAK+qB,eAAehrB,SAASmK,GAEpB,cACT,OAAO,EAAI7L,GAAOC,OAASC,GAAOD,OAASC,GAAOD,QAItD,SAASiwB,EAAmBnwB,GAC1B,MAAMP,EAAQ,IAAIC,WAAW,EAAIO,GAAOC,OAASC,GAAOD,OAASC,GAAOD,QAKxE,OAJA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWY,GAAgBN,EAAMmtB,oBAAqB,GACpE1tB,EAAMK,IAAI,IAAIJ,WAAWc,GAAgBR,EAAMktB,SAAU,EAAIjtB,GAAOC,QACpET,EAAMK,IAAI,IAAIJ,WAAWc,GAAgBR,EAAMgJ,YAAa,EAAI/I,GAAOC,OAASC,GAAOD,QAChFT,EAAMD,OAGf,MAAM4wB,EACJ1uB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIU,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAImtB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIxB,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGlF8tB,mBACE,MAAMpqB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E0uB,gBACE,MAAMhrB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIypB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E2uB,mBACE,MAAMjrB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIY,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI9E,SAAS6J,EAAyBxL,GAChC,MAAMhB,EAAU,GAIhB,OAHAA,EAAQM,KAAKuB,GAAgBb,EAAMgB,kBACnChC,EAAQM,KAAKkC,GAAgBxB,EAAMyL,cACnCzM,EAAQM,KAAKkB,GAAgBR,EAAM0L,iBAC5B3M,EAAeC,GAGxB,MAAMuxB,EACJ7uB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIywB,EAAgBxuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACzF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIxB,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGlF6uB,qBACE,MAAMnrB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI+qB,EAAgBxuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGrF8uB,sBACE,MAAMprB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E+uB,wBACE,MAAMrrB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIY,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI9E,SAASgvB,EAA2B3wB,GAClC,MAAMhB,EAAU,GAIhB,OAHAA,EAAQM,KAAKkM,EAAyBxL,EAAM4wB,oBAC5C5xB,EAAQM,KAAKuB,GAAgBb,EAAM6wB,qBACnC7xB,EAAQM,KAAKkB,GAAgBR,EAAM8wB,uBAC5B/xB,EAAeC,GAGxB,MAAM+xB,GACJrvB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITqvB,qBACE,OAAO,IAAI3wB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAInE,GAAOH,QAAS,CAAEyB,UAAU,IAG9EA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAYwxB,GAAgC7wB,QACvE0B,KAAKovB,qBAAqBrvB,SAASmK,GAE1B,cACT,OAAO,EAAIzL,GAAOH,QAItB,SAAS+wB,GAAyCjxB,GAChD,MAAMP,EAAQ,IAAIC,WAAW,EAAIW,GAAOH,QAGxC,OAFA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAMkxB,oBAAqB,GAC7DzxB,EAAMD,OAGf,MAAMkb,GACJhZ,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAIT2tB,uBACE,OAAO,IAAIjvB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAInE,GAAOH,QAAS,CAAEyB,UAAU,IAG9EwvB,yBACE,OAAO,IAAI9wB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInE,GAAOH,OAAQ,EAAIG,GAAOH,OAASG,GAAOH,QAAS,CAC9FyB,UAAU,IAIdiZ,2BACE,OAAO,IAAIza,GACTyB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInE,GAAOH,OAASG,GAAOH,OAAQ,EAAIG,GAAOH,OAASG,GAAOH,OAASC,GAAOD,QACrG,CAAEyB,UAAU,IAIhBqtB,oBACE,OAAO,IAAI3uB,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASG,GAAOH,OAASC,GAAOD,OAC3C,EAAIG,GAAOH,OAASG,GAAOH,OAASC,GAAOD,OAASG,GAAOH,QAE7D,CAAEyB,UAAU,IAIhB4tB,gBACE,OAAO,IAAInvB,GACTwB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASG,GAAOH,OAASC,GAAOD,OAASG,GAAOH,OAC3D,EAAIG,GAAOH,OAASG,GAAOH,OAASC,GAAOD,OAASG,GAAOH,OAASE,GAAQF,QAE9E,CAAEyB,UAAU,IAIhB6tB,kBACE,OAAO,IAAIrvB,GACTyB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASG,GAAOH,OAASC,GAAOD,OAASG,GAAOH,OAASE,GAAQF,OAC5E,EAAIG,GAAOH,OAASG,GAAOH,OAASC,GAAOD,OAASG,GAAOH,OAASE,GAAQF,OAASC,GAAOD,QAE9F,CAAEyB,UAAU,IAIhB8tB,mBACE,OAAO,IAAIpvB,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EAAInE,GAAOH,OAASG,GAAOH,OAASC,GAAOD,OAASG,GAAOH,OAASE,GAAQF,OAASC,GAAOD,OAC5F,EACEG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,QAEX,CAAEyB,UAAU,IAIhB+tB,qBACE,OAAO,IAAIrvB,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EACEnE,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,OACT,EACEG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,QAEX,CAAEyB,UAAU,IAIhBA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAYmb,GAAmBxa,QAC1D0B,KAAK0tB,uBAAuB3tB,SAASmK,GACrClK,KAAKuvB,yBAAyBxvB,SAASmK,GACvClK,KAAKgZ,2BAA2BjZ,SAASmK,GACzClK,KAAKotB,oBAAoBrtB,SAASmK,GAClClK,KAAK2tB,gBAAgB5tB,SAASmK,GAC9BlK,KAAK4tB,kBAAkB7tB,SAASmK,GAChClK,KAAK6tB,mBAAmB9tB,SAASmK,GACjClK,KAAK8tB,qBAAqB/tB,SAASmK,GAE1B,cACT,OACE,EACAzL,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,QAKb,SAASmY,GAA4BrY,GACnC,MAAMP,EAAQ,IAAIC,WAChB,EACEW,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,QAiCX,OA/BA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAMe,sBAAuB,GACtEtB,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAMkY,wBAAyB,EAAI7X,GAAOH,QACnFT,EAAMK,IAAI,IAAIJ,WAAWc,GAAgBR,EAAMmY,0BAA2B,EAAI9X,GAAOH,OAASG,GAAOH,QACrGT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAMc,mBACrC,EAAIT,GAAOH,OAASG,GAAOH,OAASC,GAAOD,QAE7CT,EAAMK,IACJ,IAAIJ,WAAWiB,GAAiBX,EAAMqG,cACtC,EAAIhG,GAAOH,OAASG,GAAOH,OAASC,GAAOD,OAASG,GAAOH,QAE7DT,EAAMK,IACJ,IAAIJ,WAAWc,GAAgBR,EAAMsG,gBACrC,EAAIjG,GAAOH,OAASG,GAAOH,OAASC,GAAOD,OAASG,GAAOH,OAASE,GAAQF,QAE9ET,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAMgB,kBACrC,EAAIX,GAAOH,OAASG,GAAOH,OAASC,GAAOD,OAASG,GAAOH,OAASE,GAAQF,OAASC,GAAOD,QAE9FT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAMuG,oBACrC,EACElG,GAAOH,OACPG,GAAOH,OACPC,GAAOD,OACPG,GAAOH,OACPE,GAAQF,OACRC,GAAOD,OACPG,GAAOH,QAEJT,EAAMD,OAGf,MAAM4xB,GACJ1vB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACMC,KAAKjC,KAAKJ,WAAa,GACzBf,EAAiBoD,KAAKjC,KAAKJ,WAAY,MAEzC,MAAM8xB,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,OAAQqvB,GACN,KAAK,EACH,IAAIC,GAA4B1vB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAASA,WAChF,MACF,KAAK,EACH,IAAI4vB,GAA0B3vB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAASA,WAC9E,MACF,KAAK,EACH,IAAI6vB,GAAyB5vB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAASA,WAC7E,MACF,QACE,MAAM,IAAIpD,MAAJ,wBAA2B8yB,KAIvCI,YACE,MAAMJ,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,OAAQqvB,GACN,KAAK,EACH,MAAO,8BACT,KAAK,EACH,MAAO,4BACT,KAAK,EACH,MAAO,2BACT,QACE,MAAM,IAAI9yB,MAAJ,wBAA2B8yB,KAIvCrxB,QACE,MAAMqxB,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,OAAQqvB,GACN,KAAK,EACH,OAAO,IAAIC,GAA4B1vB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAChF,KAAK,EACH,OAAO,IAAI4vB,GAA0B3vB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAC9E,KAAK,EACH,OAAO,IAAI6vB,GAAyB5vB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAC7E,QACE,MAAM,IAAIpD,MAAJ,wBAA2B8yB,MAKzC,SAASK,GAAiC1xB,GACxC,OAAQA,EAAMgO,MACZ,IAAK,8BAA+B,CAClC,MAAM6Z,EAAalc,GAAqC3L,EAAMA,OACxDP,EAAQ,IAAIC,WAAW,EAAImoB,EAAWtoB,YAI5C,OAHa,IAAIK,SAASH,EAAMD,QAC3BK,UAAU,EAAG,GAAG,GACrBJ,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,GAC/BpoB,EAAMD,OAEf,IAAK,4BAA6B,CAChC,MAAMqoB,EAAa8J,GAAmC3xB,EAAMA,OACtDP,EAAQ,IAAIC,WAAW,EAAImoB,EAAWtoB,YAI5C,OAHa,IAAIK,SAASH,EAAMD,QAC3BK,UAAU,EAAG,GAAG,GACrBJ,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,GAC/BpoB,EAAMD,OAEf,IAAK,2BAA4B,CAC/B,MAAMqoB,EAAa+J,GAAkC5xB,EAAMA,OACrDP,EAAQ,IAAIC,WAAW,EAAImoB,EAAWtoB,YAI5C,OAHa,IAAIK,SAASH,EAAMD,QAC3BK,UAAU,EAAG,GAAG,GACrBJ,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,GAC/BpoB,EAAMD,OAEf,QACE,MAAM,IAAIjB,MAAJ,wBAA2ByB,EAAMgO,QAI7C,MAAMsjB,GACJ5vB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE4lB,EAAwB3lB,KAAKjC,KAAM,GAAG,IAI1C,SAASgM,GAAqC3L,GAE5C,OAAOjB,EADS,IAIlB,MAAMwyB,GACJ7vB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITkwB,uBACE,OAAO,IAAIxxB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAInE,GAAOH,QAAS,CAAEyB,UAAU,IAG9EA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAYgyB,GAA0BrxB,QACjE0B,KAAKiwB,uBAAuBlwB,SAASmK,GAE5B,cACT,OAAO,EAAIzL,GAAOH,QAItB,SAASyxB,GAAmC3xB,GAC1C,MAAMP,EAAQ,IAAIC,WAAW,EAAIW,GAAOH,QAGxC,OAFA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAM8xB,sBAAuB,GAC/DryB,EAAMD,OAGf,MAAMgyB,GACJ9vB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAImvB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGlFowB,eACE,MAAM1sB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIuvB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI9E,SAASiwB,GAAkC5xB,GACzC,MAAMhB,EAAU,GAEhB,OADAA,EAAQM,KAAKkC,GAAgBxB,EAAMyB,aAC5B1C,EAAeC,GAGxB,MAAMgzB,GACJtwB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAIT8tB,mBACE,OAAO,IAAIpvB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAInE,GAAOH,QAAS,CAAEyB,UAAU,IAG9EswB,sBACE,OAAO,IAAI9xB,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInE,GAAOH,OAAQ,EAAIG,GAAOH,OAASC,GAAOD,QAAS,CAC9FyB,UAAU,IAIdA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAYyyB,GAAc9xB,QACrD0B,KAAK6tB,mBAAmB9tB,SAASmK,GACjClK,KAAKqwB,sBAAsBtwB,SAASmK,GAE3B,cACT,OAAO,EAAIzL,GAAOH,OAASC,GAAOD,QAItC,SAASgyB,GAAuBlyB,GAC9B,MAAMP,EAAQ,IAAIC,WAAW,EAAIW,GAAOH,OAASC,GAAOD,QAIxD,OAHA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAMgB,kBAAmB,GAClEvB,EAAMK,IAAI,IAAIJ,WAAWc,GAAgBR,EAAMmyB,qBAAsB,EAAI9xB,GAAOH,QACzET,EAAMD,OAGf,MAAM4yB,GACJ1wB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACMC,KAAKjC,KAAKJ,WAAa,GACzBf,EAAiBoD,KAAKjC,KAAKJ,WAAY,MAEzC,MAAM8xB,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,GACO,IADCqvB,EAKJ,MAAM,IAAI9yB,MAAJ,wBAA2B8yB,IAHjC,IAAIgB,GAAczwB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAASA,WAOxE8vB,YACE,MAAMJ,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,GACO,IADCqvB,EAEJ,MAAO,gBAEP,MAAM,IAAI9yB,MAAJ,wBAA2B8yB,IAIvCrxB,QACE,MAAMqxB,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,GACO,IADCqvB,EAEJ,OAAO,IAAIgB,GAAczwB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAEhE,MAAM,IAAIpD,MAAJ,wBAA2B8yB,KAKzC,SAASiB,GAA0BtyB,GACjC,GACO,kBADCA,EAAMgO,KACU,CACpB,MAAM6Z,EAAa0K,GAAuBvyB,EAAMA,OAC1CP,EAAQ,IAAIC,WAAW,EAAImoB,EAAWtoB,YAI5C,OAHa,IAAIK,SAASH,EAAMD,QAC3BK,UAAU,EAAG,GAAG,GACrBJ,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,GAC/BpoB,EAAMD,OAGb,MAAM,IAAIjB,MAAJ,wBAA2ByB,EAAMgO,OAI7C,MAAM1C,GACJ5J,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITiK,YACE,OAAO,IAAI3L,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAIvE,GAAOC,QAAS,CAAEyB,UAAU,IAG9EkK,YACE,OAAO,IAAIzL,GAAQwB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAIvE,GAAOC,OAAQ,EAAID,GAAOC,OAASE,GAAQF,QAAS,CAChGyB,UAAU,IAIdA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAY+L,GAAIpL,QAC3C0B,KAAKgK,YAAYjK,SAASmK,GAC1BlK,KAAKiK,YAAYlK,SAASmK,GAEjB,cACT,OAAO,EAAI7L,GAAOC,OAASE,GAAQF,QAIvC,SAASqL,GAAavL,GACpB,MAAMP,EAAQ,IAAIC,WAAW,EAAIO,GAAOC,OAASE,GAAQF,QAIzD,OAHA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWY,GAAgBN,EAAMiE,UAAW,GAC1DxE,EAAMK,IAAI,IAAIJ,WAAWiB,GAAiBX,EAAMY,SAAU,EAAIX,GAAOC,QAC9DT,EAAMD,OAGf,MAAM6yB,GACJ3wB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAImvB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAI2J,GAAI1J,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAG/EstB,YACE,MAAM5pB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIypB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EguB,SACE,MAAMtqB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAI+L,GAAI1J,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI3E,SAAS4wB,GAAuBvyB,GAC9B,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAKkC,GAAgBxB,EAAMmH,SACnCnI,EAAQM,KAAKiM,GAAavL,EAAMiB,MACzBlC,EAAeC,GAGxB,MAAMwzB,GACJ9wB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACMC,KAAKjC,KAAKJ,WAAa,GACzBf,EAAiBoD,KAAKjC,KAAKJ,WAAY,MAEzC,MAAM8xB,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,OAAQqvB,GACN,KAAK,EACH,IAAIoB,GAAU7wB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAASA,WAC9D,MACF,KAAK,EACH,IAAI+wB,GAAa9wB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAASA,WACjE,MACF,QACE,MAAM,IAAIpD,MAAJ,wBAA2B8yB,KAIvCI,YACE,MAAMJ,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,OAAQqvB,GACN,KAAK,EACH,MAAO,YACT,KAAK,EACH,MAAO,eACT,QACE,MAAM,IAAI9yB,MAAJ,wBAA2B8yB,KAIvCrxB,QACE,MAAMqxB,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,OAAQqvB,GACN,KAAK,EACH,OAAO,IAAIoB,GAAU7wB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAC9D,KAAK,EACH,OAAO,IAAI+wB,GAAa9wB,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IACjE,QACE,MAAM,IAAIpD,MAAJ,wBAA2B8yB,MAKzC,SAASsB,GAAkB3yB,GACzB,OAAQA,EAAMgO,MACZ,IAAK,YAAa,CAChB,MAAM6Z,EAAa+K,GAAmB5yB,EAAMA,OACtCP,EAAQ,IAAIC,WAAW,EAAImoB,EAAWtoB,YAI5C,OAHa,IAAIK,SAASH,EAAMD,QAC3BK,UAAU,EAAG,GAAG,GACrBJ,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,GAC/BpoB,EAAMD,OAEf,IAAK,eAAgB,CACnB,MAAMqoB,EAAagL,GAAsB7yB,EAAMA,OACzCP,EAAQ,IAAIC,WAAW,EAAImoB,EAAWtoB,YAI5C,OAHa,IAAIK,SAASH,EAAMD,QAC3BK,UAAU,EAAG,GAAG,GACrBJ,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,GAC/BpoB,EAAMD,OAEf,QACE,MAAM,IAAIjB,MAAJ,wBAA2ByB,EAAMgO,QAI7C,MAAMykB,GACJ/wB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIkrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGjFmxB,kBACE,MAAMztB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIsrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI7E,SAASixB,GAAmB5yB,GAC1B,MAAMhB,EAAU,GAEhB,OADAA,EAAQM,KAAK8B,GAAepB,EAAM+yB,gBAC3Bh0B,EAAeC,GAGxB,MAAM0zB,GACJhxB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIkrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC/E,IAAIvB,GAAQwB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACjF,IAAIvB,GAAQwB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGnFqxB,QACE,MAAM3tB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIwlB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG3EkK,YACE,MAAMxG,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIjF,GAAQwB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG7EguB,SACE,MAAMtqB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIa,GAAQwB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI/E,SAASkxB,GAAsB7yB,GAC7B,MAAMhB,EAAU,GAIhB,OAHAA,EAAQM,KAAK8B,GAAepB,EAAMizB,KAClCj0B,EAAQM,KAAKqB,GAAiBX,EAAMY,SACpC5B,EAAQM,KAAKqB,GAAiBX,EAAMiB,MAC7BlC,EAAeC,GAGxB,MAAMk0B,GACJxxB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITwxB,eACE,OAAO,IAAI9yB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAInE,GAAOH,QAAS,CAAEyB,UAAU,IAG9EyxB,iBACE,OAAO,IAAInzB,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInE,GAAOH,OAAQ,EAAIG,GAAOH,OAASD,GAAOC,QAAS,CAC9FyB,UAAU,IAId0xB,gBACE,OAAOzxB,KAAKjC,KAAKmC,SAAS,EAAIzB,GAAOH,OAASD,GAAOC,QAGvDyB,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAY2zB,GAAgBhzB,QACvD0B,KAAKuxB,eAAexxB,SAASmK,GAC7BlK,KAAKwxB,iBAAiBzxB,SAASmK,GAEtB,cACT,OAAO,EAAIzL,GAAOH,OAASD,GAAOC,OAAS,GAI/C,SAASozB,GAAyBtzB,GAChC,MAAMP,EAAQ,IAAIC,WAAW,EAAIW,GAAOH,OAASD,GAAOC,OAAS,GAC3DP,EAAO,IAAIC,SAASH,EAAMD,QAIhC,OAHAC,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAMuzB,aAAc,GAC7D9zB,EAAMK,IAAI,IAAIJ,WAAWY,GAAgBN,EAAMwzB,eAAgB,EAAInzB,GAAOH,QAC1EP,EAAK0C,SAAS,EAAIhC,GAAOH,OAASD,GAAOC,OAAQF,EAAMyzB,aAChDh0B,EAAMD,OAGf,MAAMk0B,GACJhyB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIuzB,GAAgBtxB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACzF,IAAImtB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGlFgyB,YACE,MAAMtuB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI6tB,GAAgBtxB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGrFiyB,yBACE,MAAMvuB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIuvB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI9E,SAASkyB,GAA2B7zB,GAClC,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAKg0B,GAAyBtzB,EAAMugB,SAC5CvhB,EAAQM,KAAKkC,GAAgBxB,EAAM8zB,wBAC5B/0B,EAAeC,GAGxB,MAAM+0B,GACJryB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAI2sB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACpF,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGjFqyB,gBACE,MAAM3uB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIinB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGhFwsB,gBACE,MAAM9oB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIsrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI7E,SAASsyB,GAA0Bj0B,GACjC,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAK2tB,EAAoBjtB,EAAMk0B,cACvCl1B,EAAQM,KAAK8B,GAAepB,EAAM0uB,cAC3B3vB,EAAeC,GAGxB,MAAMm1B,GACJzyB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAK,IAAIN,EAAI,EAAGA,EAAID,EAAQF,OAAS,EAAGG,IACtC,IAAIyvB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQC,GAAID,EAAQC,EAAI,IAAK,CAAEsC,UAAU,IAASA,WAIxFzC,SACE,OAAI0C,KAAKjC,KAAKJ,WAAa,EAClB,EAEAqC,KAAKjC,KAAKqC,UAAU,GAAG,GAAQ,EAAI,EAI9CH,QAAQxC,GACN,MAAMgG,EAAQ,EAAQ,EAAJhG,EACZqqB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GAC1C,IAAIskB,EAAa/nB,KAAKjC,KAAKJ,WAI3B,OAHIF,EAAI,EAAIuC,KAAK1C,WACfyqB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,IAEvC,IAAIypB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI9E,SAASyyB,GAAmBp0B,GAC1B,OAAOjB,EAAeiB,EAAM0M,KAAKxK,GAASV,GAAgBU,MAG5D,MAAMmyB,GACJ3yB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAIT4qB,YACE,OAAO,IAAIpsB,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAIrE,GAAOD,QAAS,CAAEyB,UAAU,IAG9E2yB,UACE,OAAO,IAAIj0B,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAIrE,GAAOD,OAAQ,EAAIC,GAAOD,OAASG,GAAOH,QAAS,CAC9FyB,UAAU,IAIdA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAY80B,GAAen0B,QACtD0B,KAAK2qB,YAAY5qB,SAASmK,GAC1BlK,KAAK0yB,UAAU3yB,SAASmK,GAEf,cACT,OAAO,EAAI3L,GAAOD,OAASG,GAAOH,QAItC,SAASq0B,GAAwBv0B,GAC/B,MAAMP,EAAQ,IAAIC,WAAW,EAAIS,GAAOD,OAASG,GAAOH,QAIxD,OAHA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWc,GAAgBR,EAAMktB,SAAU,GACzDztB,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAM8lB,OAAQ,EAAI3lB,GAAOD,QAC3DT,EAAMD,OAGf,MAAMg1B,GACJ9yB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WAA8B,IAArBmK,EAAoB,wDACvBlK,KAAKjC,KAAKJ,WAAa,GACzBnB,EAAgBwD,KAAKjC,KAAKJ,WAAY,MAExC,MAAMkoB,EAAqB7lB,KAAK1C,SAAWm1B,GAAen0B,OAAS,EACnE1B,EAAiBoD,KAAKjC,KAAKJ,WAAYkoB,GACvC,IAAK,IAAIpoB,EAAI,EAAGA,EAAI,EAAGA,IACRuC,KAAKC,QAAQxC,GACrBsC,SAASmK,GAIlBjK,QAAQxC,GACN,OAAO,IAAIg1B,GACTzyB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInF,EAAIg1B,GAAen0B,OAAQ,GAAKb,EAAI,GAAKg1B,GAAen0B,QACnF,CAAEyB,UAAU,IAIhBzC,SACE,OAAO0C,KAAKjC,KAAKqC,UAAU,GAAG,IAIlC,SAASyyB,GAA2Bz0B,GAClC,MAAMP,EAAQ,IAAIC,WAAW,EAAI20B,GAAen0B,OAASF,EAAMd,QAC/D,IAAIU,SAASH,EAAMD,QAAQK,UAAU,EAAGG,EAAMd,QAAQ,GACtD,IAAK,IAAIG,EAAI,EAAGA,EAAIW,EAAMd,OAAQG,IAAK,CACrC,MAAMwoB,EAAa0M,GAAwBv0B,EAAMX,IACjDI,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,EAAIxoB,EAAIg1B,GAAen0B,QAE/D,OAAOT,EAAMD,OAGf,MAAMk1B,GACJhzB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIM,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAImsB,EAAUlsB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACnF,IAAIgzB,GAAS/yB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAClF,IAAIwyB,GAAUvyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACnF,IAAItB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAI6yB,GAAkB5yB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAG7FizB,kBACE,MAAMvvB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIpF,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EqsB,aACE,MAAM3oB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIyoB,EAAUlsB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG/EkzB,cACE,MAAMxvB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIsvB,GAAS/yB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG9EmzB,aACE,MAAMzvB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI8uB,GAAUvyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG/EozB,oBACE,MAAM1vB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EqzB,iBACE,MAAM3vB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIi1B,GAAkB5yB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIzF,SAASszB,GAAkCj1B,GACzC,MAAMhB,EAAU,GAOhB,OANAA,EAAQM,KAAKgB,GAAgBN,EAAMk1B,gBACnCl2B,EAAQM,KAAKgvB,EAAmBtuB,EAAMuuB,WACtCvvB,EAAQM,KAAK61B,GAAkBn1B,EAAMo1B,YACrCp2B,EAAQM,KAAK80B,GAAmBp0B,EAAMq1B,UACtCr2B,EAAQM,KAAKuB,GAAgBb,EAAMs1B,mBACnCt2B,EAAQM,KAAKm1B,GAA2Bz0B,EAAMu1B,eACvCx2B,EAAeC,GAGxB,MAAMw2B,GACJ9zB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIgoB,EAAU/lB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACnF,IAAI6nB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGrF8zB,aACE,MAAMpwB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIsiB,EAAU/lB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG/E+zB,YACE,MAAMrwB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIiqB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIjF,SAASg0B,GAAwB31B,GAC/B,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAKsoB,EAAmB5nB,EAAM41B,UACtC52B,EAAQM,KAAKqrB,GAAmB3qB,EAAM61B,SAC/B92B,EAAeC,GAGxB,MAAM82B,GACJp0B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIurB,EAActpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACvF,IAAI2qB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACpF,IAAI6zB,GAAe5zB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACxF,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC/E,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC/E,IAAI+yB,GAAyB9yB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGpGo0B,UACE,MAAM1wB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI6lB,EAActpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGnFqyB,gBACE,MAAM3uB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIinB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGhFq0B,aACE,MAAM3wB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAImwB,GAAe5zB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGpFssB,kBACE,MAAM5oB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIwlB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG3Es0B,sBACE,MAAM5wB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIwlB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG3Eu0B,aACE,MAAM7wB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIm1B,GAAyB9yB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIhG,SAASw0B,GAAkCn2B,GACzC,MAAMhB,EAAU,GAOhB,OANAA,EAAQM,KAAK+rB,EAAuBrrB,EAAMkD,OAC1ClE,EAAQM,KAAK2tB,EAAoBjtB,EAAMk0B,cACvCl1B,EAAQM,KAAKq2B,GAAwB31B,EAAMo2B,WAC3Cp3B,EAAQM,KAAK8B,GAAepB,EAAMwuB,iBAClCxvB,EAAQM,KAAK8B,GAAepB,EAAMq2B,qBAClCr3B,EAAQM,KAAK21B,GAAkCj1B,EAAMs2B,UAC9Cv3B,EAAeC,GAGxB,MAAMu3B,GACJ70B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIM,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAImsB,EAAUlsB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACnF,IAAIwyB,GAAUvyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGrFizB,kBACE,MAAMvvB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIpF,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5EqsB,aACE,MAAM3oB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIyoB,EAAUlsB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG/EmzB,aACE,MAAMzvB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAI40B,GAAUvyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIjF,SAAS60B,GAA2Cx2B,GAClD,MAAMhB,EAAU,GAIhB,OAHAA,EAAQM,KAAKgB,GAAgBN,EAAMk1B,gBACnCl2B,EAAQM,KAAKgvB,EAAmBtuB,EAAMuuB,WACtCvvB,EAAQM,KAAK80B,GAAmBp0B,EAAMq1B,UAC/Bt2B,EAAeC,GAGxB,MAAMy3B,GACJ/0B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAI2sB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACpF,IAAIupB,EAActpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACvF,IAAI6zB,GAAe5zB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACxF,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC/E,IAAI40B,GAAkC30B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CACpFuC,UAAU,IACTA,WAGLqyB,gBACE,MAAM3uB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIinB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGhFo0B,UACE,MAAM1wB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI6lB,EAActpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGnFq0B,aACE,MAAM3wB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAImwB,GAAe5zB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGpFssB,kBACE,MAAM5oB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIwlB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG3Eu0B,aACE,MAAM7wB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIg3B,GAAkC30B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIzG,SAAS+0B,GAA2C12B,GAClD,MAAMhB,EAAU,GAMhB,OALAA,EAAQM,KAAK2tB,EAAoBjtB,EAAMk0B,cACvCl1B,EAAQM,KAAK+rB,EAAuBrrB,EAAMkD,OAC1ClE,EAAQM,KAAKq2B,GAAwB31B,EAAMo2B,WAC3Cp3B,EAAQM,KAAK8B,GAAepB,EAAMwuB,iBAClCxvB,EAAQM,KAAKk3B,GAA2Cx2B,EAAMs2B,UACvDv3B,EAAeC,GAGxB,MAAM23B,GACJj1B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAI2sB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACpF,IAAIiuB,EAAkBhuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC3F,IAAI6zB,GAAe5zB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAG1FqyB,gBACE,MAAM3uB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIinB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGhFi1B,uBACE,MAAMvxB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIuqB,EAAkBhuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGvFk1B,qBACE,MAAMxxB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIi2B,GAAe5zB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAItF,SAASm1B,GAAiC92B,GACxC,MAAMhB,EAAU,GAIhB,OAHAA,EAAQM,KAAK2tB,EAAoBjtB,EAAMk0B,cACvCl1B,EAAQM,KAAKS,EAA2BC,EAAM+2B,qBAC9C/3B,EAAQM,KAAKq2B,GAAwB31B,EAAMg3B,mBACpCj4B,EAAeC,GAGxB,MAAMi4B,GACJv1B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIkuB,EAAQjsB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACjF,IAAI6nB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACnF,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGjF8mB,WACE,MAAMpjB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIwoB,EAAQjsB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG7Eu1B,yBACE,MAAM7xB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAImkB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG/Ew1B,wBACE,MAAM9xB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIsrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI7E,SAASy1B,GAA2Bp3B,GAClC,MAAMhB,EAAU,GAIhB,OAHAA,EAAQM,KAAK+uB,EAAiBruB,EAAMgpB,QACpChqB,EAAQM,KAAKqrB,GAAmB3qB,EAAMq3B,wBACtCr4B,EAAQM,KAAK8B,GAAepB,EAAMs3B,uBAC3Bv4B,EAAeC,GAGxB,MAAMu4B,GACJ71B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIo0B,GAAiBnyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAG5F61B,aACE,MAAMnyB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIw0B,GAAiBnyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIxF,SAAS81B,GAA8Bz3B,GACrC,MAAMhB,EAAU,GAEhB,OADAA,EAAQM,KAAK20B,GAA0Bj0B,EAAMsS,UACtCvT,EAAeC,GAGxB,MAAM04B,GACJh2B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE4lB,EAAwB3lB,KAAKjC,KAAM,GAAG,IAI1C,SAASg4B,GAA+B33B,GAEtC,OAAOjB,EADS,IAIlB,MAAM64B,GACJl2B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIguB,EAAc/rB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACvF,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC/E,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC/E,IAAI2qB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGtFk2B,oBACE,MAAMxyB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIsoB,EAAc/rB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGnFwsB,gBACE,MAAM9oB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIwlB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG3Ew1B,wBACE,MAAM9xB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIwlB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG3Em2B,iBACE,MAAMzyB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAI+sB,EAAW1qB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIlF,SAASo2B,GAAsB/3B,GAC7B,MAAMhB,EAAU,GAKhB,OAJAA,EAAQM,KAAKsuB,EAAuB5tB,EAAMg4B,kBAC1Ch5B,EAAQM,KAAK8B,GAAepB,EAAM0uB,cAClC1vB,EAAQM,KAAK8B,GAAepB,EAAMs3B,uBAClCt4B,EAAQM,KAAK2tB,EAAoBjtB,EAAMi4B,gBAChCl5B,EAAeC,GAGxB,MAAMk5B,GACJx2B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACMC,KAAKjC,KAAKJ,WAAa,GACzBf,EAAiBoD,KAAKjC,KAAKJ,WAAY,MAEzC,MAAM8xB,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,OAAQqvB,GACN,KAAK,EACH,IAAI4F,GAAkBr1B,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAASA,WACtE,MACF,KAAK,EACH,IAAI41B,GAAqB31B,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAASA,WACzE,MACF,KAAK,EACH,IAAI+1B,GAAsB91B,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAASA,WAC1E,MACF,KAAK,EACH,IAAIi2B,GAAah2B,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAASA,WACjE,MACF,QACE,MAAM,IAAIpD,MAAJ,wBAA2B8yB,KAIvCI,YACE,MAAMJ,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,OAAQqvB,GACN,KAAK,EACH,MAAO,oBACT,KAAK,EACH,MAAO,uBACT,KAAK,EACH,MAAO,wBACT,KAAK,EACH,MAAO,eACT,QACE,MAAM,IAAI9yB,MAAJ,wBAA2B8yB,KAIvCrxB,QACE,MAAMqxB,EAAIzvB,KAAKjC,KAAKqC,UAAU,GAAG,GACjC,OAAQqvB,GACN,KAAK,EACH,OAAO,IAAI4F,GAAkBr1B,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IACtE,KAAK,EACH,OAAO,IAAI41B,GAAqB31B,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IACzE,KAAK,EACH,OAAO,IAAI+1B,GAAsB91B,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IAC1E,KAAK,EACH,OAAO,IAAIi2B,GAAah2B,KAAKjC,KAAKH,OAAOgF,MAAM,GAAI,CAAE7C,UAAU,IACjE,QACE,MAAM,IAAIpD,MAAJ,wBAA2B8yB,MAKzC,SAAS8G,GAAsBn4B,GAC7B,OAAQA,EAAMgO,MACZ,IAAK,oBAAqB,CACxB,MAAM6Z,EAAauP,GAA2Bp3B,EAAMA,OAC9CP,EAAQ,IAAIC,WAAW,EAAImoB,EAAWtoB,YAI5C,OAHa,IAAIK,SAASH,EAAMD,QAC3BK,UAAU,EAAG,GAAG,GACrBJ,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,GAC/BpoB,EAAMD,OAEf,IAAK,uBAAwB,CAC3B,MAAMqoB,EAAa4P,GAA8Bz3B,EAAMA,OACjDP,EAAQ,IAAIC,WAAW,EAAImoB,EAAWtoB,YAI5C,OAHa,IAAIK,SAASH,EAAMD,QAC3BK,UAAU,EAAG,GAAG,GACrBJ,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,GAC/BpoB,EAAMD,OAEf,IAAK,wBAAyB,CAC5B,MAAMqoB,EAAa8P,GAA+B33B,EAAMA,OAClDP,EAAQ,IAAIC,WAAW,EAAImoB,EAAWtoB,YAI5C,OAHa,IAAIK,SAASH,EAAMD,QAC3BK,UAAU,EAAG,GAAG,GACrBJ,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,GAC/BpoB,EAAMD,OAEf,IAAK,eAAgB,CACnB,MAAMqoB,EAAakQ,GAAsB/3B,EAAMA,OACzCP,EAAQ,IAAIC,WAAW,EAAImoB,EAAWtoB,YAI5C,OAHa,IAAIK,SAASH,EAAMD,QAC3BK,UAAU,EAAG,GAAG,GACrBJ,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,GAC/BpoB,EAAMD,OAEf,QACE,MAAM,IAAIjB,MAAJ,wBAA2ByB,EAAMgO,QAI7C,MAAMoqB,GACJ12B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,GAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGnB64B,oBACE,OAAOz2B,KAAKjC,KAAK24B,UAAU,GAAG,GAGhCC,uBACE,OAAO32B,KAAKjC,KAAK24B,UAAU,GAAG,GAGrB,cACT,OAAO,GAIX,SAASE,GAAgBx4B,GACvB,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,GAC7BC,EAGT,MAAMS,GACJyB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,GAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGnBuC,oBACE,OAAOH,KAAKjC,KAAKqC,UAAU,GAAG,GAGhCC,uBACE,OAAOL,KAAKjC,KAAKqC,UAAU,GAAG,GAGrB,cACT,OAAO,GAIX,SAAS1B,GAAgBN,GACvB,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,GAC7BC,EAGT,MAAMW,GACJuB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,GAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGnBuM,uBACE,OAAOnK,KAAKjC,KAAKqM,aAAa,GAAG,GAGnCC,0BACE,OAAOrK,KAAKjC,KAAKqM,aAAa,GAAG,GAGxB,cACT,OAAO,GAIX,SAASxL,GAAgBR,GACvB,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,GAC7BC,EAGT,MAAMY,GACJsB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,IAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGR,cACT,OAAO,IAIX,SAASmB,GAAiBX,GACxB,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,IAC7BC,EAGT,MAAMa,GACJqB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,IAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGR,cACT,OAAO,IAIX,SAASqB,GAAgBb,GACvB,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,IAC7BC,EAGT,MAAMi5B,GACJ/2B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,IAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGR,cACT,OAAO,IAIX,SAASk5B,GAAiB14B,GACxB,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,IAC7BC,EAGT,MAAMqrB,GACJnpB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACMC,KAAKjC,KAAKJ,WAAa,GACzBnB,EAAgBwD,KAAKjC,KAAKJ,WAAY,MAExC,MAAMkoB,EAAqB7lB,KAAK1C,SAAW,EAC3CV,EAAiBoD,KAAKjC,KAAKJ,WAAYkoB,GAGzCtmB,MACE,OAAOS,KAAKjC,KAAKH,OAAOgF,MAAM,GAGhC3C,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAAS,EAAIzC,GAGhCH,SACE,OAAO0C,KAAKjC,KAAKqC,UAAU,GAAG,IAIlC,SAASZ,GAAepB,GACtB,MAAMkC,EAAOzD,EAAkBuB,GACzBP,EAAQ,IAAIC,WAAW,EAAIwC,EAAK3C,YAGtC,OAFA,IAAIK,SAASH,EAAMD,QAAQK,UAAU,EAAGqC,EAAK3C,YAAY,GACzDE,EAAMK,IAAI,IAAIJ,WAAWwC,GAAO,GACzBzC,EAAMD,OAGf,MAAMm5B,GACJj3B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WAA8B,IAArBmK,EAAoB,wDACvBlK,KAAKg3B,YACPh3B,KAAK5B,QAAQ2B,SAASmK,GAI1B9L,QACE,OAAO,IAAI6qB,GAAMjpB,KAAKjC,KAAKH,OAAQ,CAAEmC,UAAU,IAGjDi3B,WACE,OAAOh3B,KAAKjC,KAAKJ,WAAa,GAIlC,SAAS4N,GAAkBnN,GACzB,OAAIA,EACKoB,GAAepB,GAEf,IAAIlB,YAAY,GAI3B,MAAM61B,GACJjzB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAK,IAAIN,EAAI,EAAGA,EAAID,EAAQF,OAAS,EAAGG,IACtC,IAAIwrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQC,GAAID,EAAQC,EAAI,IAAK,CAAEsC,UAAU,IAASA,WAIvFzC,SACE,OAAI0C,KAAKjC,KAAKJ,WAAa,EAClB,EAEAqC,KAAKjC,KAAKqC,UAAU,GAAG,GAAQ,EAAI,EAI9CH,QAAQxC,GACN,MAAMgG,EAAQ,EAAQ,EAAJhG,EACZqqB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GAC1C,IAAIskB,EAAa/nB,KAAKjC,KAAKJ,WAI3B,OAHIF,EAAI,EAAIuC,KAAK1C,WACfyqB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,IAEvC,IAAIwlB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI7E,SAASwzB,GAAkBn1B,GACzB,OAAOjB,EAAeiB,EAAM0M,KAAKxK,GAASd,GAAec,MAG3D,MAAMsnB,GACJ9nB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WAA8B,IAArBmK,EAAoB,wDACvBlK,KAAKjC,KAAKJ,WAAa,GACzBnB,EAAgBwD,KAAKjC,KAAKJ,WAAY,MAExC,MAAMkoB,EAAqB7lB,KAAK1C,SAAWmB,GAAOH,OAAS,EAC3D1B,EAAiBoD,KAAKjC,KAAKJ,WAAYkoB,GACvC,IAAK,IAAIpoB,EAAI,EAAGA,EAAI,EAAGA,IACRuC,KAAKC,QAAQxC,GACrBsC,SAASmK,GAIlBjK,QAAQxC,GACN,OAAO,IAAIgB,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInF,EAAIgB,GAAOH,OAAQ,GAAKb,EAAI,GAAKgB,GAAOH,QAAS,CAC5FyB,UAAU,IAIdzC,SACE,OAAO0C,KAAKjC,KAAKqC,UAAU,GAAG,IAIlC,SAAS2oB,GAAmB3qB,GAC1B,MAAMP,EAAQ,IAAIC,WAAW,EAAIW,GAAOH,OAASF,EAAMd,QACvD,IAAIU,SAASH,EAAMD,QAAQK,UAAU,EAAGG,EAAMd,QAAQ,GACtD,IAAK,IAAIG,EAAI,EAAGA,EAAIW,EAAMd,OAAQG,IAAK,CACrC,MAAMwoB,EAAahnB,GAAgBb,EAAMX,IACzCI,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,EAAIxoB,EAAIgB,GAAOH,QAEvD,OAAOT,EAAMD,OAGf,MAAMq5B,GACJn3B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WAA8B,IAArBmK,EAAoB,wDACvBlK,KAAKg3B,YACPh3B,KAAK5B,QAAQ2B,SAASmK,GAI1B9L,QACE,OAAO,IAAI8uB,GAAOltB,KAAKjC,KAAKH,OAAQ,CAAEmC,UAAU,IAGlDi3B,WACE,OAAOh3B,KAAKjC,KAAKJ,WAAa,GAIlC,SAASu5B,GAAmB94B,GAC1B,OAAIA,EACKwB,GAAgBxB,GAEhB,IAAIlB,YAAY,GAI3B,MAAMi6B,GACJr3B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACEnD,EAAiBoD,KAAKjC,KAAKJ,WAAY,IAGzCsC,QAAQxC,GACN,OAAOuC,KAAKjC,KAAKmC,SAASzC,GAG5B8B,MACE,OAAOS,KAAKjC,KAAKH,OAGR,cACT,OAAO,IAIX,SAASw5B,GAAyBh5B,GAChC,MAAMR,EAASf,EAAkBuB,GAEjC,OADAxB,EAAiBgB,EAAOD,WAAY,IAC7BC,EAGT,MAAMy5B,GACJv3B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAK,IAAIN,EAAI,EAAGA,EAAID,EAAQF,OAAS,EAAGG,IACtC,IAAI65B,GAAWt3B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQC,GAAID,EAAQC,EAAI,IAAK,CAAEsC,UAAU,IAASA,WAI5FzC,SACE,OAAI0C,KAAKjC,KAAKJ,WAAa,EAClB,EAEAqC,KAAKjC,KAAKqC,UAAU,GAAG,GAAQ,EAAI,EAI9CH,QAAQxC,GACN,MAAMgG,EAAQ,EAAQ,EAAJhG,EACZqqB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GAC1C,IAAIskB,EAAa/nB,KAAKjC,KAAKJ,WAI3B,OAHIF,EAAI,EAAIuC,KAAK1C,WACfyqB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,IAEvC,IAAI6zB,GAAWt3B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIlF,SAASw3B,GAAuBn5B,GAC9B,OAAOjB,EAAeiB,EAAM0M,KAAKxK,GAASk3B,GAAoBl3B,MAGhE,MAAMm3B,GACJ33B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAK,IAAIN,EAAI,EAAGA,EAAID,EAAQF,OAAS,EAAGG,IACtC,IAAIi6B,GAAY13B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQC,GAAID,EAAQC,EAAI,IAAK,CAAEsC,UAAU,IAASA,WAI7FzC,SACE,OAAI0C,KAAKjC,KAAKJ,WAAa,EAClB,EAEAqC,KAAKjC,KAAKqC,UAAU,GAAG,GAAQ,EAAI,EAI9CH,QAAQxC,GACN,MAAMgG,EAAQ,EAAQ,EAAJhG,EACZqqB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GAC1C,IAAIskB,EAAa/nB,KAAKjC,KAAKJ,WAI3B,OAHIF,EAAI,EAAIuC,KAAK1C,WACfyqB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,IAEvC,IAAIi0B,GAAY13B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAInF,SAAS43B,GAAwBv5B,GAC/B,OAAOjB,EAAeiB,EAAM0M,KAAKxK,GAASs3B,GAAqBt3B,MAGjE,MAAMu3B,GACJ/3B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WAA8B,IAArBmK,EAAoB,wDACvBlK,KAAKjC,KAAKJ,WAAa,GACzBnB,EAAgBwD,KAAKjC,KAAKJ,WAAY,MAExC,MAAMkoB,EAAqB7lB,KAAK1C,SAAW65B,GAAgB74B,OAAS,EACpE1B,EAAiBoD,KAAKjC,KAAKJ,WAAYkoB,GACvC,IAAK,IAAIpoB,EAAI,EAAGA,EAAI,EAAGA,IACRuC,KAAKC,QAAQxC,GACrBsC,SAASmK,GAIlBjK,QAAQxC,GACN,OAAO,IAAI05B,GACTn3B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInF,EAAI05B,GAAgB74B,OAAQ,GAAKb,EAAI,GAAK05B,GAAgB74B,QACrF,CAAEyB,UAAU,IAIhBzC,SACE,OAAO0C,KAAKjC,KAAKqC,UAAU,GAAG,IAIlC,SAAS03B,GAA4B15B,GACnC,MAAMP,EAAQ,IAAIC,WAAW,EAAIq5B,GAAgB74B,OAASF,EAAMd,QAChE,IAAIU,SAASH,EAAMD,QAAQK,UAAU,EAAGG,EAAMd,QAAQ,GACtD,IAAK,IAAIG,EAAI,EAAGA,EAAIW,EAAMd,OAAQG,IAAK,CACrC,MAAMwoB,EAAamR,GAAyBh5B,EAAMX,IAClDI,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,EAAIxoB,EAAI05B,GAAgB74B,QAEhE,OAAOT,EAAMD,OAGf,MAAMm6B,GACJj4B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WAA8B,IAArBmK,EAAoB,wDACvBlK,KAAKjC,KAAKJ,WAAa,GACzBnB,EAAgBwD,KAAKjC,KAAKJ,WAAY,MAExC,MAAMkoB,EAAqB7lB,KAAK1C,SAAW06B,GAAQ15B,OAAS,EAC5D1B,EAAiBoD,KAAKjC,KAAKJ,WAAYkoB,GACvC,IAAK,IAAIpoB,EAAI,EAAGA,EAAI,EAAGA,IACRuC,KAAKC,QAAQxC,GACrBsC,SAASmK,GAIlBjK,QAAQxC,GACN,OAAO,IAAIu6B,GAAQh4B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInF,EAAIu6B,GAAQ15B,OAAQ,GAAKb,EAAI,GAAKu6B,GAAQ15B,QAAS,CAC/FyB,UAAU,IAIdzC,SACE,OAAO0C,KAAKjC,KAAKqC,UAAU,GAAG,IAIlC,SAAS63B,GAAoB75B,GAC3B,MAAMP,EAAQ,IAAIC,WAAW,EAAIk6B,GAAQ15B,OAASF,EAAMd,QACxD,IAAIU,SAASH,EAAMD,QAAQK,UAAU,EAAGG,EAAMd,QAAQ,GACtD,IAAK,IAAIG,EAAI,EAAGA,EAAIW,EAAMd,OAAQG,IAAK,CACrC,MAAMwoB,EAAaiS,GAAiB95B,EAAMX,IAC1CI,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,EAAIxoB,EAAIu6B,GAAQ15B,QAExD,OAAOT,EAAMD,OAGf,MAAMu6B,GACJr4B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WAA8B,IAArBmK,EAAoB,wDACvBlK,KAAKjC,KAAKJ,WAAa,GACzBnB,EAAgBwD,KAAKjC,KAAKJ,WAAY,MAExC,MAAMkoB,EAAqB7lB,KAAK1C,SAAW86B,GAAU95B,OAAS,EAC9D1B,EAAiBoD,KAAKjC,KAAKJ,WAAYkoB,GACvC,IAAK,IAAIpoB,EAAI,EAAGA,EAAI,EAAGA,IACRuC,KAAKC,QAAQxC,GACrBsC,SAASmK,GAIlBjK,QAAQxC,GACN,OAAO,IAAI26B,GAAUp4B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInF,EAAI26B,GAAU95B,OAAQ,GAAKb,EAAI,GAAK26B,GAAU95B,QAAS,CACrGyB,UAAU,IAIdzC,SACE,OAAO0C,KAAKjC,KAAKqC,UAAU,GAAG,IAIlC,SAASi4B,GAAsBj6B,GAC7B,MAAMP,EAAQ,IAAIC,WAAW,EAAIs6B,GAAU95B,OAASF,EAAMd,QAC1D,IAAIU,SAASH,EAAMD,QAAQK,UAAU,EAAGG,EAAMd,QAAQ,GACtD,IAAK,IAAIG,EAAI,EAAGA,EAAIW,EAAMd,OAAQG,IAAK,CACrC,MAAMwoB,EAAaqS,GAAmBl6B,EAAMX,IAC5CI,EAAMK,IAAI,IAAIJ,WAAWmoB,GAAa,EAAIxoB,EAAI26B,GAAU95B,QAE1D,OAAOT,EAAMD,OAGf,MAAM26B,GACJz4B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAK,IAAIN,EAAI,EAAGA,EAAID,EAAQF,OAAS,EAAGG,IACtC,IAAI+6B,GAAWx4B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQC,GAAID,EAAQC,EAAI,IAAK,CAAEsC,UAAU,IAASA,WAI5FzC,SACE,OAAI0C,KAAKjC,KAAKJ,WAAa,EAClB,EAEAqC,KAAKjC,KAAKqC,UAAU,GAAG,GAAQ,EAAI,EAI9CH,QAAQxC,GACN,MAAMgG,EAAQ,EAAQ,EAAJhG,EACZqqB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GAC1C,IAAIskB,EAAa/nB,KAAKjC,KAAKJ,WAI3B,OAHIF,EAAI,EAAIuC,KAAK1C,WACfyqB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,IAEvC,IAAI+0B,GAAWx4B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIlF,SAAS04B,GAAuBr6B,GAC9B,OAAOjB,EAAeiB,EAAM0M,KAAKxK,GAASo4B,GAAoBp4B,MAGhE,MAAM4sB,GACJptB,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GAEtD,GADA,IAAIU,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC5EvC,EAAQ,GAAKA,EAAQ,KAAO,EAC9B,MAAM,IAAIb,MAAJ,wCAA2Ca,EAAQ,GAAnD,cAA2DA,EAAQ,KAE3E,IAAIyrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGjF44B,cACE,MAAMl1B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIhF,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E64B,cACE,MAAMn1B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIzF,SAASgC,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,IAAa7nB,SAAS,GAG3EkpB,UACE,MAAM3lB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIsrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI7E,SAASH,GAAgBxB,GACvB,MAAMhB,EAAU,GAChBA,EAAQM,KAAKuB,GAAgBb,EAAMmC,YACnC,MAAMC,EAAe,IAAIxC,SAAS,IAAId,YAAY,IAIlD,OAHAsD,EAAaC,SAAS,EAAGrC,EAAMsC,WAC/BtD,EAAQM,KAAK8C,EAAa5C,QAC1BR,EAAQM,KAAK8B,GAAepB,EAAMuC,OAC3BxD,EAAeC,GAGxB,MAAMy7B,GACJ/4B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAIT+4B,YACE,OAAO,IAAIr6B,GAAOuB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAInE,GAAOH,QAAS,CAAEyB,UAAU,IAG9Eg5B,WACE,OAAO,IAAI16B,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAInE,GAAOH,OAAQ,EAAIG,GAAOH,OAASD,GAAOC,QAAS,CAC9FyB,UAAU,IAIdA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAYk7B,GAASv6B,QAChD0B,KAAK84B,YAAY/4B,SAASmK,GAC1BlK,KAAK+4B,WAAWh5B,SAASmK,GAEhB,cACT,OAAO,EAAIzL,GAAOH,OAASD,GAAOC,QAItC,SAAS06B,GAAkB56B,GACzB,MAAMP,EAAQ,IAAIC,WAAW,EAAIW,GAAOH,OAASD,GAAOC,QAIxD,OAHA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWmB,GAAgBb,EAAMyH,UAAW,GAC1DhI,EAAMK,IAAI,IAAIJ,WAAWY,GAAgBN,EAAM0H,QAAS,EAAIrH,GAAOH,QAC5DT,EAAMD,OAGf,MAAMw6B,GACJt4B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITk5B,WACE,OAAO,IAAI16B,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAIrE,GAAOD,QAAS,CAAEyB,UAAU,IAG9Em5B,oBACE,OAAO,IAAIL,GAAS74B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAIrE,GAAOD,OAAQ,EAAIC,GAAOD,OAASu6B,GAASv6B,QAAS,CAClGyB,UAAU,IAIdA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAYy6B,GAAU95B,QACjD0B,KAAKi5B,WAAWl5B,SAASmK,GACzBlK,KAAKk5B,oBAAoBn5B,SAASmK,GAEzB,cACT,OAAO,EAAI3L,GAAOD,OAASu6B,GAASv6B,QAIxC,SAASg6B,GAAmBl6B,GAC1B,MAAMP,EAAQ,IAAIC,WAAW,EAAIS,GAAOD,OAASu6B,GAASv6B,QAI1D,OAHA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWc,GAAgBR,EAAM+6B,QAAS,GACxDt7B,EAAMK,IAAI,IAAIJ,WAAWk7B,GAAkB56B,EAAMg7B,kBAAmB,EAAI76B,GAAOD,QACxET,EAAMD,OAGf,MAAM46B,GACJ14B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIQ,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAImtB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIk3B,GAAUj3B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGrFotB,cACE,MAAM1pB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIlF,GAAOyB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5Es5B,UACE,MAAM51B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIypB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5Eu5B,UACE,MAAM71B,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIs5B,GAAUj3B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIjF,SAAS24B,GAAoBt6B,GAC3B,MAAMhB,EAAU,GAIhB,OAHAA,EAAQM,KAAKkB,GAAgBR,EAAMU,WACnC1B,EAAQM,KAAKkC,GAAgBxB,EAAMuR,OACnCvS,EAAQM,KAAKw5B,GAAmB94B,EAAMm7B,QAC/Bp8B,EAAeC,GAGxB,MAAM46B,GACJl4B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITy5B,cACE,OAAO,IAAIX,GAAS74B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAIi2B,GAASv6B,QAAS,CAAEyB,UAAU,IAGlF05B,aACE,OAAOz5B,KAAKjC,KAAKmC,SAAS,EAAI24B,GAASv6B,QAGzCyB,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAYq6B,GAAQ15B,QAC/C0B,KAAKw5B,cAAcz5B,SAASmK,GAEnB,cACT,OAAO,EAAI2uB,GAASv6B,OAAS,GAIjC,SAAS45B,GAAiB95B,GACxB,MAAMP,EAAQ,IAAIC,WAAW,EAAI+6B,GAASv6B,OAAS,GAC7CP,EAAO,IAAIC,SAASH,EAAMD,QAGhC,OAFAC,EAAMK,IAAI,IAAIJ,WAAWk7B,GAAkB56B,EAAMwH,YAAa,GAC9D7H,EAAK0C,SAAS,EAAIo4B,GAASv6B,OAAQF,EAAM2H,UAClClI,EAAMD,OAGf,MAAM87B,GACJ55B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIM,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIg4B,GAAW/3B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACpF,IAAI6nB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACnF,IAAIo4B,GAAan4B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACtF,IAAIw4B,GAAcv4B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACvF,IAAIgzB,GAAS/yB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGpFqY,aACE,MAAM3U,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIpF,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E45B,cACE,MAAMl2B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIs0B,GAAW/3B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGhF65B,gBACE,MAAMn2B,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAImkB,GAAU5nB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG/E85B,YACE,MAAMp2B,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI00B,GAAan4B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGlF+5B,aACE,MAAMr2B,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI80B,GAAcv4B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGnFg6B,iBACE,MAAMt2B,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIo1B,GAAS/yB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIhF,SAASqQ,GAAwBhS,GAC/B,MAAMhB,EAAU,GAOhB,OANAA,EAAQM,KAAKgB,GAAgBN,EAAM8P,UACnC9Q,EAAQM,KAAKu6B,GAAoB75B,EAAM2V,YACvC3W,EAAQM,KAAKqrB,GAAmB3qB,EAAM47B,cACtC58B,EAAQM,KAAK26B,GAAsBj6B,EAAM8N,SACzC9O,EAAQM,KAAK+6B,GAAuBr6B,EAAMoO,UAC1CpP,EAAQM,KAAK61B,GAAkBn1B,EAAM67B,eAC9B98B,EAAeC,GAGxB,MAAMs6B,GACJ53B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAI27B,GAAe15B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACxF,IAAIgzB,GAAS/yB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGpFwpB,SACE,MAAM9lB,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIi2B,GAAe15B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGpFm6B,eACE,MAAMz2B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIo1B,GAAS/yB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIhF,SAAS63B,GAAqBx5B,GAC5B,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAK0S,GAAwBhS,EAAMmB,MAC3CnC,EAAQM,KAAK61B,GAAkBn1B,EAAMyR,YAC9B1S,EAAeC,GAGxB,MAAM+8B,GACJr6B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITqY,aACE,OAAO,IAAI/Z,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAIvE,GAAOC,QAAS,CAAEyB,UAAU,IAG9Eq6B,mBACE,OAAO,IAAI/7B,GAAO2B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAIvE,GAAOC,OAAQ,EAAID,GAAOC,OAASD,GAAOC,QAAS,CAC9FyB,UAAU,IAIdgrB,eACE,OAAO,IAAIxsB,GACTyB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAIvE,GAAOC,OAASD,GAAOC,OAAQ,EAAID,GAAOC,OAASD,GAAOC,OAASC,GAAOD,QACrG,CAAEyB,UAAU,IAIhB4qB,YACE,OAAO,IAAIpsB,GACTyB,KAAKjC,KAAKH,OAAOgF,MACf,EAAIvE,GAAOC,OAASD,GAAOC,OAASC,GAAOD,OAC3C,EAAID,GAAOC,OAASD,GAAOC,OAASC,GAAOD,OAASC,GAAOD,QAE7D,CAAEyB,UAAU,IAIhBs6B,WACE,OAAO,IAAI97B,GACTyB,KAAKjC,KAAKH,OAAOgF,MACf,EAAIvE,GAAOC,OAASD,GAAOC,OAASC,GAAOD,OAASC,GAAOD,OAC3D,EAAID,GAAOC,OAASD,GAAOC,OAASC,GAAOD,OAASC,GAAOD,OAASC,GAAOD,QAE7E,CAAEyB,UAAU,IAIhBu6B,gBACE,OAAO,IAAI77B,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EAAIvE,GAAOC,OAASD,GAAOC,OAASC,GAAOD,OAASC,GAAOD,OAASC,GAAOD,OAC3E,EAAID,GAAOC,OAASD,GAAOC,OAASC,GAAOD,OAASC,GAAOD,OAASC,GAAOD,OAASG,GAAOH,QAE7F,CAAEyB,UAAU,IAIhBw6B,sBACE,OAAO,IAAI97B,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EAAIvE,GAAOC,OAASD,GAAOC,OAASC,GAAOD,OAASC,GAAOD,OAASC,GAAOD,OAASG,GAAOH,OAC3F,EACED,GAAOC,OACPD,GAAOC,OACPC,GAAOD,OACPC,GAAOD,OACPC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,QAEX,CAAEyB,UAAU,IAIhBy6B,mBACE,OAAO,IAAI/7B,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EACEvE,GAAOC,OACPD,GAAOC,OACPC,GAAOD,OACPC,GAAOD,OACPC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACT,EACED,GAAOC,OACPD,GAAOC,OACPC,GAAOD,OACPC,GAAOD,OACPC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,QAEX,CAAEyB,UAAU,IAIhB06B,eACE,OAAO,IAAIh8B,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EACEvE,GAAOC,OACPD,GAAOC,OACPC,GAAOD,OACPC,GAAOD,OACPC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,OACT,EACED,GAAOC,OACPD,GAAOC,OACPC,GAAOD,OACPC,GAAOD,OACPC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,QAEX,CAAEyB,UAAU,IAIhB26B,SACE,OAAO,IAAIj8B,GACTuB,KAAKjC,KAAKH,OAAOgF,MACf,EACEvE,GAAOC,OACPD,GAAOC,OACPC,GAAOD,OACPC,GAAOD,OACPC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,OACT,EACED,GAAOC,OACPD,GAAOC,OACPC,GAAOD,OACPC,GAAOD,OACPC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,QAEX,CAAEyB,UAAU,IAIhBA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAYw8B,GAAU77B,QACjD0B,KAAKoY,aAAarY,SAASmK,GAC3BlK,KAAKo6B,mBAAmBr6B,SAASmK,GACjClK,KAAK+qB,eAAehrB,SAASmK,GAC7BlK,KAAK2qB,YAAY5qB,SAASmK,GAC1BlK,KAAKq6B,WAAWt6B,SAASmK,GACzBlK,KAAKs6B,gBAAgBv6B,SAASmK,GAC9BlK,KAAKu6B,sBAAsBx6B,SAASmK,GACpClK,KAAKw6B,mBAAmBz6B,SAASmK,GACjClK,KAAKy6B,eAAe16B,SAASmK,GAC7BlK,KAAK06B,SAAS36B,SAASmK,GAEd,cACT,OACE,EACA7L,GAAOC,OACPD,GAAOC,OACPC,GAAOD,OACPC,GAAOD,OACPC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,QAKb,SAASq8B,GAAmBv8B,GAC1B,MAAMP,EAAQ,IAAIC,WAChB,EACEO,GAAOC,OACPD,GAAOC,OACPC,GAAOD,OACPC,GAAOD,OACPC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,QAgDX,OA9CA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAWY,GAAgBN,EAAM8P,UAAW,GAC1DrQ,EAAMK,IAAI,IAAIJ,WAAWY,GAAgBN,EAAMw8B,iBAAkB,EAAIv8B,GAAOC,QAC5ET,EAAMK,IAAI,IAAIJ,WAAWc,GAAgBR,EAAMgJ,YAAa,EAAI/I,GAAOC,OAASD,GAAOC,QACvFT,EAAMK,IAAI,IAAIJ,WAAWc,GAAgBR,EAAMktB,SAAU,EAAIjtB,GAAOC,OAASD,GAAOC,OAASC,GAAOD,QACpGT,EAAMK,IACJ,IAAIJ,WAAWc,GAAgBR,EAAMy8B,QACrC,EAAIx8B,GAAOC,OAASD,GAAOC,OAASC,GAAOD,OAASC,GAAOD,QAE7DT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAM08B,cACrC,EAAIz8B,GAAOC,OAASD,GAAOC,OAASC,GAAOD,OAASC,GAAOD,OAASC,GAAOD,QAE7ET,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAM28B,oBACrC,EAAI18B,GAAOC,OAASD,GAAOC,OAASC,GAAOD,OAASC,GAAOD,OAASC,GAAOD,OAASG,GAAOH,QAE7FT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAM48B,iBACrC,EAAI38B,GAAOC,OAASD,GAAOC,OAASC,GAAOD,OAASC,GAAOD,OAASC,GAAOD,OAASG,GAAOH,OAASG,GAAOH,QAE7GT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAM68B,aACrC,EACE58B,GAAOC,OACPD,GAAOC,OACPC,GAAOD,OACPC,GAAOD,OACPC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,QAEXT,EAAMK,IACJ,IAAIJ,WAAWmB,GAAgBb,EAAM88B,MACrC,EACE78B,GAAOC,OACPD,GAAOC,OACPC,GAAOD,OACPC,GAAOD,OACPC,GAAOD,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,OACPG,GAAOH,QAEJT,EAAMD,OAGf,MAAMu9B,GACJr7B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITwpB,SACE,OAAO,IAAI4Q,GAAUn6B,KAAKjC,KAAKH,OAAOgF,MAAM,EAAG,EAAIu3B,GAAU77B,QAAS,CAAEyB,UAAU,IAGpF6a,WACE,OAAO,IAAIpc,GAAQwB,KAAKjC,KAAKH,OAAOgF,MAAM,EAAIu3B,GAAU77B,OAAQ,EAAI67B,GAAU77B,OAASE,GAAQF,QAAS,CACtGyB,UAAU,IAIdA,WAA8B,IAArBmK,EAAoB,wDAC3BtN,EAAiBoD,KAAKjC,KAAKJ,WAAYw9B,GAAO78B,QAC9C0B,KAAKupB,SAASxpB,SAASmK,GACvBlK,KAAK4a,WAAW7a,SAASmK,GAEhB,cACT,OAAO,EAAIiwB,GAAU77B,OAASE,GAAQF,QAI1C,SAAS88B,GAAgBh9B,GACvB,MAAMP,EAAQ,IAAIC,WAAW,EAAIq8B,GAAU77B,OAASE,GAAQF,QAI5D,OAHA,IAAIN,SAASH,EAAMD,QACnBC,EAAMK,IAAI,IAAIJ,WAAW68B,GAAmBv8B,EAAMmB,MAAO,GACzD1B,EAAMK,IAAI,IAAIJ,WAAWiB,GAAiBX,EAAMO,QAAS,EAAIw7B,GAAU77B,QAChET,EAAMD,OAGf,MAAM05B,GACJx3B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIo9B,GAAOn7B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAI83B,GAAmB73B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAG9Fs7B,YACE,MAAM53B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI03B,GAAOn7B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5Eu7B,eACE,MAAM73B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIk6B,GAAmB73B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI1F,SAASy3B,GAAoBp5B,GAC3B,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAK09B,GAAgBh9B,EAAMm9B,SACnCn+B,EAAQM,KAAKo6B,GAA4B15B,EAAMo9B,YACxCr+B,EAAeC,GAGxB,MAAMq+B,GACJ37B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIo9B,GAAOn7B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIs3B,GAAcr3B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACvF,IAAI03B,GAAez3B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACxF,IAAI83B,GAAmB73B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAG9Fs7B,YACE,MAAM53B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI03B,GAAOn7B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E27B,YACE,MAAMj4B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI4zB,GAAcr3B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGnFusB,kBACE,MAAM7oB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIg0B,GAAez3B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGpFu7B,eACE,MAAM73B,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIk6B,GAAmB73B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI1F,SAAS47B,GAAev9B,GACtB,MAAMhB,EAAU,GAKhB,OAJAA,EAAQM,KAAK09B,GAAgBh9B,EAAMm9B,SACnCn+B,EAAQM,KAAK65B,GAAuBn5B,EAAMw9B,SAC1Cx+B,EAAQM,KAAKi6B,GAAwBv5B,EAAMyuB,eAC3CzvB,EAAQM,KAAKo6B,GAA4B15B,EAAMo9B,YACxCr+B,EAAeC,GAGxB,MAAMy+B,GACJ/7B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIo9B,GAAOn7B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIs3B,GAAcr3B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACvF,IAAI03B,GAAez3B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WACxF,IAAI83B,GAAmB73B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAC5F,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGjFs7B,YACE,MAAM53B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI03B,GAAOn7B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5E27B,YACE,MAAMj4B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAI4zB,GAAcr3B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGnFusB,kBACE,MAAM7oB,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIg0B,GAAez3B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGpFu7B,eACE,MAAM73B,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIo0B,GAAmB73B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAGxF+7B,eACE,MAAMr4B,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIsrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI7E,SAASg8B,GAAiB39B,GACxB,MAAMhB,EAAU,GAMhB,OALAA,EAAQM,KAAK09B,GAAgBh9B,EAAMm9B,SACnCn+B,EAAQM,KAAK65B,GAAuBn5B,EAAMw9B,SAC1Cx+B,EAAQM,KAAKi6B,GAAwBv5B,EAAMyuB,eAC3CzvB,EAAQM,KAAKo6B,GAA4B15B,EAAMo9B,YAC/Cp+B,EAAQM,KAAK8B,GAAepB,EAAM49B,YAC3B7+B,EAAeC,GAGxB,MAAM6+B,GACJn8B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAImvB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAChF,IAAIkpB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGjFs5B,UACE,MAAM51B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIypB,GAAOltB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG5Em8B,aACE,MAAMz4B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIsrB,GAAMjpB,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAI7E,SAASo8B,GAAyB/9B,GAChC,MAAMhB,EAAU,GAGhB,OAFAA,EAAQM,KAAKkC,GAAgBxB,EAAMuR,OACnCvS,EAAQM,KAAK8B,GAAepB,EAAM4Q,UAC3B7R,EAAeC,GAGxB,MAAMg/B,GACJt8B,YAAYhD,GAAmC,IAA3B,SAAEiD,GAAW,GAAa,uDAAJ,GACxCC,KAAKjC,KAAO,IAAIC,SAASnB,EAAkBC,IACvCiD,GACFC,KAAKD,WAITA,WACE,MAAMvC,EAAUmoB,EAAwB3lB,KAAKjC,KAAM,GAAG,GACtD,IAAIg5B,GAAS/2B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAClF,IAAIg3B,GAAS/2B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAClF,IAAIg3B,GAAS/2B,KAAKjC,KAAKH,OAAOgF,MAAMpF,EAAQ,GAAIA,EAAQ,IAAK,CAAEuC,UAAU,IAASA,WAGpFs5B,UACE,MAAM51B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIszB,GAAS/2B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG9Es8B,eACE,MAAM54B,EAAQ,EACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKqC,UAAUqD,EAAQ,GAAG,GAClD,OAAO,IAAIszB,GAAS/2B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,IAG9Eu8B,gBACE,MAAM74B,EAAQ,GACRqkB,EAAS9nB,KAAKjC,KAAKqC,UAAUqD,GAAO,GACpCskB,EAAa/nB,KAAKjC,KAAKJ,WAC7B,OAAO,IAAIo5B,GAAS/2B,KAAKjC,KAAKH,OAAOgF,MAAMklB,EAAQC,GAAa,CAAEhoB,UAAU,KAIhF,SAAS2P,GAAqBtR,GAC5B,MAAMhB,EAAU,GAIhB,OAHAA,EAAQM,KAAK6N,GAAkBnN,EAAMuR,OACrCvS,EAAQM,KAAK6N,GAAkBnN,EAAMm+B,aACrCn/B,EAAQM,KAAK6N,GAAkBnN,EAAMo+B,cAC9Br/B,EAAeC,GAGxBsoB,EAAQc,mBAAqBA,EAC7Bd,EAAQ+V,MAAQA,GAChB/V,EAAQ+M,eAAiBA,GACzB/M,EAAQkN,kBAAoBA,GAC5BlN,EAAQ4I,UAAYA,EACpB5I,EAAQQ,iBAAmBA,EAC3BR,EAAQmW,QAAUA,GAClBnW,EAAQjnB,OAASA,GACjBinB,EAAQkC,UAAYA,GACpBlC,EAAQuD,MAAQA,GAChBvD,EAAQqR,SAAWA,GACnBrR,EAAQqN,SAAWA,GACnBrN,EAAQkO,eAAiBA,GACzBlO,EAAQsS,QAAUA,GAClBtS,EAAQqS,WAAaA,GACrBrS,EAAQ0S,UAAYA,GACpB1S,EAAQyS,aAAeA,GACvBzS,EAAQ8S,WAAaA,GACrB9S,EAAQ6S,cAAgBA,GACxB7S,EAAQuW,gBAAkBA,GAC1BvW,EAAQoM,kBAAoBA,GAC5BpM,EAAQ4L,gBAAkBA,GAC1B5L,EAAQyM,iBAAmBA,GAC3BzM,EAAQ+K,cAAgBA,GACxB/K,EAAQiJ,kBAAoBA,EAC5BjJ,EAAQ8I,gBAAkBA,EAC1B9I,EAAQuH,eAAiBA,EACzBvH,EAAQ6H,kBAAoBA,EAC5B7H,EAAQhc,IAAMA,GACdgc,EAAQlT,YAAcA,EACtBkT,EAAQgB,cAAgBA,EACxBhB,EAAQyV,OAASA,GACjBzV,EAAQuI,OAASA,EACjBvI,EAAQwG,UAAYA,EACpBxG,EAAQuG,QAAUA,EAClBvG,EAAQ4D,cAAgBA,EACxB5D,EAAQgE,iBAAmBA,EAC3BhE,EAAQ8K,iBAAmBA,GAC3B9K,EAAQmT,SAAWA,GACnBnT,EAAQyR,gBAAkBA,GAC1BzR,EAAQmS,mBAAqBA,GAC7BnS,EAAQyU,UAAYA,GACpBzU,EAAQgF,WAAaA,EACrBhF,EAAQqG,cAAgBA,EACxBrG,EAAQsD,iBAAmBA,EAC3BtD,EAAQgU,eAAiBA,GACzBhU,EAAQ+H,qBAAuBA,EAC/B/H,EAAQ4Q,aAAeA,GACvB5Q,EAAQoQ,sBAAwBA,GAChCpQ,EAAQiC,aAAeA,EACvBjC,EAAQiQ,qBAAuBA,GAC/BjQ,EAAQsQ,aAAeA,GACvBtQ,EAAQ2P,kBAAoBA,GAC5B3P,EAAQkL,SAAWA,GACnBlL,EAAQmL,UAAYA,GACpBnL,EAAQoL,aAAeA,GACvBpL,EAAQwH,OAASA,GACjBxH,EAAQuR,UAAYA,GACpBvR,EAAQ6M,UAAYA,GACpB7M,EAAQe,4BAA8BA,EACtCf,EAAQiW,eAAiBA,GACzBjW,EAAQiN,wBAA0BA,GAClCjN,EAAQmN,2BAA6BA,GACrCnN,EAAQ6I,mBAAqBA,EAC7B7I,EAAQW,0BAA4BA,EACpCX,EAAQqW,iBAAmBA,GAC3BrW,EAAQzmB,gBAAkBA,GAC1BymB,EAAQqD,mBAAqBA,GAC7BrD,EAAQlmB,eAAiBA,GACzBkmB,EAAQna,kBAAoBA,GAC5Bma,EAAQ6N,kBAAoBA,GAC5B7N,EAAQqO,wBAA0BA,GAClCrO,EAAQwS,iBAAmBA,GAC3BxS,EAAQuS,oBAAsBA,GAC9BvS,EAAQ4S,mBAAqBA,GAC7B5S,EAAQ2S,sBAAwBA,GAChC3S,EAAQgT,oBAAsBA,GAC9BhT,EAAQ+S,uBAAyBA,GACjC/S,EAAQyW,yBAA2BA,GACnCzW,EAAQuM,2BAA6BA,GACrCvM,EAAQgM,yBAA2BA,GACnChM,EAAQ2M,0BAA4BA,GACpC3M,EAAQiL,uBAAyBA,GACjCjL,EAAQqJ,2BAA6BA,EACrCrJ,EAAQ9b,yBAA2BA,EACnC8b,EAAQ4H,wBAA0BA,EAClC5H,EAAQ8H,2BAA6BA,EACrC9H,EAAQ/b,aAAeA,GACvB+b,EAAQ+B,qBAAuBA,EAC/B/B,EAAQuB,uBAAyBA,EACjCvB,EAAQ0V,gBAAkBA,GAC1B1V,EAAQ0I,gBAAkBA,EAC1B1I,EAAQgH,mBAAqBA,EAC7BhH,EAAQ+G,iBAAmBA,EAC3B/G,EAAQ+D,uBAAyBA,EACjC/D,EAAQiE,0BAA4BA,EACpCjE,EAAQgL,0BAA4BA,GACpChL,EAAQsT,kBAAoBA,GAC5BtT,EAAQ0R,yBAA2BA,GACnC1R,EAAQoS,4BAA8BA,GACtCpS,EAAQiV,mBAAqBA,GAC7BjV,EAAQ2F,oBAAsBA,EAC9B3F,EAAQsG,uBAAyBA,EACjCtG,EAAQ2D,0BAA4BA,EACpC3D,EAAQtV,wBAA0BA,GAClCsV,EAAQjc,8BAAgCA,EACxCic,EAAQ6Q,sBAAwBA,GAChC7Q,EAAQqQ,+BAAiCA,GACzCrQ,EAAQmD,sBAAwBA,EAChCnD,EAAQmQ,8BAAgCA,GACxCnQ,EAAQyQ,sBAAwBA,GAChCzQ,EAAQ8P,2BAA6BA,GACrC9P,EAAQqL,kBAAoBA,GAC5BrL,EAAQsL,mBAAqBA,GAC7BtL,EAAQuL,sBAAwBA,GAChCvL,EAAQ9lB,gBAAkBA,GAC1B8lB,EAAQwR,mBAAqBA,GAC7BxR,EAAQ8M,mBAAqBA,GAC7B9M,EAAQ4K,uBAAyBA,GACjC5K,EAAQsE,4BAA8BA,EACtCtE,EAAQ6E,2BAA6BA,EACrC7E,EAAQkS,qBAAuBA,GAC/BlS,EAAQiS,wBAA0BA,GAClCjS,EAAQ3mB,iBAAmBA,GAC3B2mB,EAAQkR,gBAAkBA,GAC1BlR,EAAQoR,iBAAmBA,GAC3BpR,EAAQhnB,gBAAkBA,GAC1BgnB,EAAQM,mBAAqBA,EAC7BN,EAAQ9mB,gBAAkBA,GAC1B8mB,EAAQ8R,oBAAsBA,GAC9B9R,EAAQ6R,uBAAyBA,GACjC7R,EAAQ2J,yCAA2CA,GACnD3J,EAAQ3b,qCAAuCA,GAC/C2b,EAAQqK,mCAAqCA,GAC7CrK,EAAQsK,kCAAoCA,GAC5CtK,EAAQoK,iCAAmCA,GAC3CpK,EAAQ2N,kCAAoCA,GAC5C3N,EAAQkP,2CAA6CA,GACrDlP,EAAQoP,2CAA6CA,GACrDpP,EAAQ6O,kCAAoCA,GAC5C7O,EAAQwP,iCAAmCA,GAC3CxP,EAAQjP,4BAA8BA,GACtCiP,EAAQvnB,2BAA6BA,EACrCunB,EAAQqH,8BAAgCA,EACxCrH,EAAQhW,qBAAuBA,GAC/BgW,EAAQ0K,cAAgBA,GACxB1K,EAAQkE,mBAAqBA,EAC7BlE,EAAQ0E,kBAAoBA,EAC5B1E,EAAQgS,YAAcA,GACtBhS,EAAQ+R,eAAiBA,GACzB/R,EAAQlnB,QAAUA,GAClBknB,EAAQ8Q,OAASA,GACjB9Q,EAAQmR,QAAUA,GAClBnR,EAAQrnB,OAASA,GACjBqnB,EAAQK,UAAYA,EACpBL,EAAQnnB,OAASA,GACjBmnB,EAAQ4R,WAAaA,GACrB5R,EAAQ2R,cAAgBA,GACxB3R,EAAQyJ,gCAAkCA,GAC1CzJ,EAAQgK,4BAA8BA,GACtChK,EAAQiK,0BAA4BA,GACpCjK,EAAQkK,yBAA2BA,GACnClK,EAAQ8J,wBAA0BA,GAClC9J,EAAQoN,yBAA2BA,GACnCpN,EAAQiP,kCAAoCA,GAC5CjP,EAAQmP,kCAAoCA,GAC5CnP,EAAQwO,yBAA2BA,GACnCxO,EAAQqP,wBAA0BA,GAClCrP,EAAQ5M,mBAAqBA,GAC7B4M,EAAQsI,kBAAoBA,EAC5BtI,EAAQyG,qBAAuBA,EAC/BzG,EAAQ0W,YAAcA,GAEtBr/B,OAAO0/B,eAAe/W,EAAS,aAAc,CAAEtnB,OAAO,IAj0JlDs+B,CAAQhX,K","file":"static/js/main.b42c102f.chunk.js","sourcesContent":["function dataLengthError(actual, required) {\n  throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n}\n\nfunction assertDataLength(actual, required) {\n  if (actual !== required) {\n    dataLengthError(actual, required);\n  }\n}\n\nfunction assertArrayBuffer(reader) {\n  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n    reader = reader.toArrayBuffer();\n  }\n  if (!(reader instanceof ArrayBuffer)) {\n    throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n  }\n  return reader;\n}\n\nfunction verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n  if (view.byteLength < 4) {\n    dataLengthError(view.byteLength, \">4\");\n  }\n  const requiredByteLength = view.getUint32(0, true);\n  assertDataLength(view.byteLength, requiredByteLength);\n  if (requiredByteLength === 4) {\n    return [requiredByteLength];\n  }\n  if (requiredByteLength < 8) {\n    dataLengthError(view.byteLength, \">8\");\n  }\n  const firstOffset = view.getUint32(4, true);\n  if (firstOffset % 4 !== 0 || firstOffset < 8) {\n    throw new Error(`Invalid first offset: ${firstOffset}`);\n  }\n  const itemCount = firstOffset / 4 - 1;\n  if (itemCount < expectedFieldCount) {\n    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  } else if (!compatible && itemCount > expectedFieldCount) {\n    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  }\n  if (requiredByteLength < firstOffset) {\n    throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n  }\n  const offsets = [];\n  for (let i = 0; i < itemCount; i++) {\n    const start = 4 + i * 4;\n    offsets.push(view.getUint32(start, true));\n  }\n  offsets.push(requiredByteLength);\n  for (let i = 0; i < offsets.length - 1; i++) {\n    if (offsets[i] > offsets[i + 1]) {\n      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n    }\n  }\n  return offsets;\n}\n\nfunction serializeTable(buffers) {\n  const itemCount = buffers.length;\n  let totalSize = 4 * (itemCount + 1);\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    offsets.push(totalSize);\n    totalSize += buffers[i].byteLength;\n  }\n\n  const buffer = new ArrayBuffer(totalSize);\n  const array = new Uint8Array(buffer);\n  const view = new DataView(buffer);\n\n  view.setUint32(0, totalSize, true);\n  for (let i = 0; i < itemCount; i++) {\n    view.setUint32(4 + i * 4, offsets[i], true);\n    array.set(new Uint8Array(buffers[i]), offsets[i]);\n  }\n  return buffer;\n}\n\nexport class Uint32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Uint32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Uint32(this.view.buffer.slice(4 + i * Uint32.size(), 4 + (i + 1) * Uint32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeUint32Vec(value) {\n  const array = new Uint8Array(4 + Uint32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeUint32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Uint32.size());\n  }\n  return array.buffer;\n}\n\nexport class BlockMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class AccountMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, AccountMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeAccountMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class GlobalStateV0 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(\n      this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n      { validate: false },\n    );\n  }\n\n  getBlock() {\n    return new BlockMerkleState(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getStatus() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size(),\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalStateV0.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      1\n    );\n  }\n}\n\nexport function SerializeGlobalStateV0(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      1,\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.reverted_block_root)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.tip_block_hash)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n    value.status,\n  );\n  return array.buffer;\n}\n\nexport class GlobalState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(\n      this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n      { validate: false },\n    );\n  }\n\n  getBlock() {\n    return new BlockMerkleState(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getStatus() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size(),\n    );\n  }\n\n  getVersion() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        1,\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalState.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getTipBlockTimestamp().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1 +\n      1\n    );\n  }\n}\n\nexport function SerializeGlobalState(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1 +\n      1,\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.reverted_block_root)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.tip_block_hash)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.tip_block_timestamp)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size(),\n    value.status,\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1,\n    value.version,\n  );\n  return array.buffer;\n}\n\nexport class AllowedTypeHash {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getType() {\n    return this.view.getUint8(0);\n  }\n\n  getHash() {\n    return new Byte32(this.view.buffer.slice(0 + 1, 0 + 1 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, AllowedTypeHash.size());\n    this.getHash().validate(compatible);\n  }\n  static size() {\n    return 0 + 1 + Byte32.size();\n  }\n}\n\nexport function SerializeAllowedTypeHash(value) {\n  const array = new Uint8Array(0 + 1 + Byte32.size());\n  const view = new DataView(array.buffer);\n  view.setUint8(0, value.type_);\n  array.set(new Uint8Array(SerializeByte32(value.hash)), 0 + 1);\n  return array.buffer;\n}\n\nexport class AllowedTypeHashVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * AllowedTypeHash.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new AllowedTypeHash(\n      this.view.buffer.slice(4 + i * AllowedTypeHash.size(), 4 + (i + 1) * AllowedTypeHash.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeAllowedTypeHashVec(value) {\n  const array = new Uint8Array(4 + AllowedTypeHash.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeAllowedTypeHash(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * AllowedTypeHash.size());\n  }\n  return array.buffer;\n}\n\nexport class RollupConfig {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[10], offsets[11]), { validate: false }).validate();\n    if (offsets[12] - offsets[11] !== 1) {\n      throw new Error(`Invalid offset for reward_burn_rate: ${offsets[11]} - ${offsets[12]}`);\n    }\n    new Uint32(this.view.buffer.slice(offsets[12], offsets[13]), { validate: false }).validate();\n    new AllowedTypeHashVec(this.view.buffer.slice(offsets[13], offsets[14]), { validate: false }).validate();\n    new AllowedTypeHashVec(this.view.buffer.slice(offsets[14], offsets[15]), { validate: false }).validate();\n  }\n\n  getL1SudtScriptTypeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCustodianScriptTypeHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositScriptTypeHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalScriptTypeHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeScriptTypeHash() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeScriptTypeHash() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2SudtValidatorScriptTypeHash() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBurnLockHash() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRequiredStakingCapacity() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeMaturityBlocks() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFinalityBlocks() {\n    const start = 44;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardBurnRate() {\n    const start = 48;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getCompatibleChainId() {\n    const start = 52;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAllowedEoaTypeHashes() {\n    const start = 56;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AllowedTypeHashVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAllowedContractTypeHashes() {\n    const start = 60;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new AllowedTypeHashVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupConfig(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.l1_sudt_script_type_hash));\n  buffers.push(SerializeByte32(value.custodian_script_type_hash));\n  buffers.push(SerializeByte32(value.deposit_script_type_hash));\n  buffers.push(SerializeByte32(value.withdrawal_script_type_hash));\n  buffers.push(SerializeByte32(value.challenge_script_type_hash));\n  buffers.push(SerializeByte32(value.stake_script_type_hash));\n  buffers.push(SerializeByte32(value.l2_sudt_validator_script_type_hash));\n  buffers.push(SerializeByte32(value.burn_lock_hash));\n  buffers.push(SerializeUint64(value.required_staking_capacity));\n  buffers.push(SerializeUint64(value.challenge_maturity_blocks));\n  buffers.push(SerializeUint64(value.finality_blocks));\n  const rewardBurnRateView = new DataView(new ArrayBuffer(1));\n  rewardBurnRateView.setUint8(0, value.reward_burn_rate);\n  buffers.push(rewardBurnRateView.buffer);\n  buffers.push(SerializeUint32(value.compatible_chain_id));\n  buffers.push(SerializeAllowedTypeHashVec(value.allowed_eoa_type_hashes));\n  buffers.push(SerializeAllowedTypeHashVec(value.allowed_contract_type_hashes));\n  return serializeTable(buffers);\n}\n\nexport class RawL2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getFromId() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getToId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNonce() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getArgs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.from_id));\n  buffers.push(SerializeUint32(value.to_id));\n  buffers.push(SerializeUint32(value.nonce));\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class L2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Transaction(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class L2TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new L2Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2TransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeL2Transaction(item)));\n}\n\nexport class SubmitTransactions {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxWitnessRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getTxCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getPrevStateCheckpoint() {\n    return new Byte32(\n      this.view.buffer.slice(0 + Byte32.size() + Uint32.size(), 0 + Byte32.size() + Uint32.size() + Byte32.size()),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SubmitTransactions.size());\n    this.getTxWitnessRoot().validate(compatible);\n    this.getTxCount().validate(compatible);\n    this.getPrevStateCheckpoint().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size() + Byte32.size();\n  }\n}\n\nexport function SerializeSubmitTransactions(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_witness_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.tx_count)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.prev_state_checkpoint)), 0 + Byte32.size() + Uint32.size());\n  return array.buffer;\n}\n\nexport class SubmitWithdrawals {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getWithdrawalWitnessRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SubmitWithdrawals.size());\n    this.getWithdrawalWitnessRoot().validate(compatible);\n    this.getWithdrawalCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeSubmitWithdrawals(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_witness_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.withdrawal_count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class RawL2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new SubmitWithdrawals(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new SubmitTransactions(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n  }\n\n  getNumber() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProducerId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getParentBlockHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeCellOwnerLockHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTimestamp() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPrevAccount() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPostAccount() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStateCheckpointList() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitWithdrawals() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new SubmitWithdrawals(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitTransactions() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SubmitTransactions(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.number));\n  buffers.push(SerializeUint32(value.block_producer_id));\n  buffers.push(SerializeByte32(value.parent_block_hash));\n  buffers.push(SerializeByte32(value.stake_cell_owner_lock_hash));\n  buffers.push(SerializeUint64(value.timestamp));\n  buffers.push(SerializeAccountMerkleState(value.prev_account));\n  buffers.push(SerializeAccountMerkleState(value.post_account));\n  buffers.push(SerializeByte32Vec(value.state_checkpoint_list));\n  buffers.push(SerializeSubmitWithdrawals(value.submit_withdrawals));\n  buffers.push(SerializeSubmitTransactions(value.submit_transactions));\n  return serializeTable(buffers);\n}\n\nexport class RawL2BlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new RawL2Block(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2BlockVec(value) {\n  return serializeTable(value.map((item) => SerializeRawL2Block(item)));\n}\n\nexport class L2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new L2TransactionVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new WithdrawalRequestVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawals() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new WithdrawalRequestVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeL2TransactionVec(value.transactions));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeWithdrawalRequestVec(value.withdrawals));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSudtScriptHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScript() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeByte32(value.sudt_script_hash));\n  buffers.push(SerializeScript(value.script));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new DepositRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new DepositRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequestVec(value) {\n  return serializeTable(value.map((item) => SerializeDepositRequest(item)));\n}\n\nexport class RawWithdrawalRequestV1 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNonce() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getChainId() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getCapacity() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  getAmount() {\n    return new Uint128(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSudtScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size(),\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getFee() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawWithdrawalRequestV1.size());\n    this.getNonce().validate(compatible);\n    this.getChainId().validate(compatible);\n    this.getCapacity().validate(compatible);\n    this.getAmount().validate(compatible);\n    this.getSudtScriptHash().validate(compatible);\n    this.getAccountScriptHash().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n    this.getFee().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size()\n    );\n  }\n}\n\nexport function SerializeRawWithdrawalRequestV1(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.nonce)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.chain_id)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.capacity)), 0 + Uint32.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size() + Uint64.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.sudt_script_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.account_script_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.fee)),\n    0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class WithdrawalRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new WithdrawalRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequestVec(value) {\n  return serializeTable(value.map((item) => SerializeWithdrawalRequest(item)));\n}\n\nexport class WithdrawalRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawWithdrawalRequestV1(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawWithdrawalRequestV1(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeRawWithdrawalRequestV1(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class WithdrawalRequestExtra {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new WithdrawalRequest(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRequest() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOwnerLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequestExtra(value) {\n  const buffers = [];\n  buffers.push(SerializeWithdrawalRequest(value.request));\n  buffers.push(SerializeScript(value.owner_lock));\n  return serializeTable(buffers);\n}\n\nexport class KVPair {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getK() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getV() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, KVPair.size());\n    this.getK().validate(compatible);\n    this.getV().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Byte32.size();\n  }\n}\n\nexport function SerializeKVPair(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.k)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.v)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class KVPairVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * KVPair.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new KVPair(this.view.buffer.slice(4 + i * KVPair.size(), 4 + (i + 1) * KVPair.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeKVPairVec(value) {\n  const array = new Uint8Array(4 + KVPair.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeKVPair(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * KVPair.size());\n  }\n  return array.buffer;\n}\n\nexport class BlockInfo {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockProducerId() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockInfo.size());\n    this.getBlockProducerId().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getTimestamp().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint64.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockInfo(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint64.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.block_producer_id)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint64.size());\n  return array.buffer;\n}\n\nexport class DepositLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getOwnerLockHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLayer2Lock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCancelTimeout() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.owner_lock_hash));\n  buffers.push(SerializeScript(value.layer2_lock));\n  buffers.push(SerializeUint64(value.cancel_timeout));\n  return serializeTable(buffers);\n}\n\nexport class CustodianLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new DepositLockArgs(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getDepositLockArgs() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DepositLockArgs(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockNumber() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCustodianLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeDepositLockArgs(value.deposit_lock_args));\n  buffers.push(SerializeByte32(value.deposit_block_hash));\n  buffers.push(SerializeUint64(value.deposit_block_number));\n  return serializeTable(buffers);\n}\n\nexport class UnlockCustodianViaRevertWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getDepositLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockCustodianViaRevertWitness.size());\n    this.getDepositLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockCustodianViaRevertWitness(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.deposit_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class WithdrawalLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getWithdrawalBlockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalBlockNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(0 + Byte32.size() + Uint64.size(), 0 + Byte32.size() + Uint64.size() + Byte32.size()),\n      { validate: false },\n    );\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Uint64.size() + Byte32.size(),\n        0 + Byte32.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, WithdrawalLockArgs.size());\n    this.getWithdrawalBlockHash().validate(compatible);\n    this.getWithdrawalBlockNumber().validate(compatible);\n    this.getAccountScriptHash().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size() + Byte32.size() + Byte32.size();\n  }\n}\n\nexport function SerializeWithdrawalLockArgs(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size() + Byte32.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_block_hash)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.withdrawal_block_number)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.account_script_hash)), 0 + Byte32.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0 + Byte32.size() + Uint64.size() + Byte32.size());\n  return array.buffer;\n}\n\nexport class UnlockWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"UnlockWithdrawalViaFinalize\";\n      case 1:\n        return \"UnlockWithdrawalViaRevert\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeUnlockWithdrawalWitness(value) {\n  switch (value.type) {\n    case \"UnlockWithdrawalViaFinalize\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaFinalize(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"UnlockWithdrawalViaRevert\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class UnlockWithdrawalViaFinalize {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaFinalize(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class UnlockWithdrawalViaRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getCustodianLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockWithdrawalViaRevert.size());\n    this.getCustodianLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaRevert(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.custodian_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class StakeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getStakeBlockNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, StakeLockArgs.size());\n    this.getOwnerLockHash().validate(compatible);\n    this.getStakeBlockNumber().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeStakeLockArgs(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.stake_block_number)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class MetaContractArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new CreateAccount(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"CreateAccount\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new CreateAccount(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeMetaContractArgs(value) {\n  switch (value.type) {\n    case \"CreateAccount\": {\n      const itemBuffer = SerializeCreateAccount(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class CreateAccount {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getScript() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCreateAccount(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.script));\n  buffers.push(SerializeUint64(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class SUDTArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new SUDTQuery(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new SUDTTransfer(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"SUDTQuery\";\n      case 1:\n        return \"SUDTTransfer\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new SUDTQuery(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new SUDTTransfer(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeSUDTArgs(value) {\n  switch (value.type) {\n    case \"SUDTQuery\": {\n      const itemBuffer = SerializeSUDTQuery(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"SUDTTransfer\": {\n      const itemBuffer = SerializeSUDTTransfer(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class SUDTQuery {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getShortScriptHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTQuery(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.short_script_hash));\n  return serializeTable(buffers);\n}\n\nexport class SUDTTransfer {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getTo() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTTransfer(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.to));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeUint64(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeTarget {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getTargetIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTargetType() {\n    return this.view.getUint8(0 + Byte32.size() + Uint32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, ChallengeTarget.size());\n    this.getBlockHash().validate(compatible);\n    this.getTargetIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size() + 1;\n  }\n}\n\nexport function SerializeChallengeTarget(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.block_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.target_index)), 0 + Byte32.size());\n  view.setUint8(0 + Byte32.size() + Uint32.size(), value.target_type);\n  return array.buffer;\n}\n\nexport class ChallengeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeTarget(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getTarget() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ChallengeTarget(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardsReceiverLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeTarget(value.target));\n  buffers.push(SerializeScript(value.rewards_receiver_lock));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeBytes(value.block_proof));\n  return serializeTable(buffers);\n}\n\nexport class ScriptVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScriptVec(value) {\n  return serializeTable(value.map((item) => SerializeScript(item)));\n}\n\nexport class BlockHashEntry {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockHashEntry.size());\n    this.getNumber().validate(compatible);\n    this.getHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + Byte32.size();\n  }\n}\n\nexport function SerializeBlockHashEntry(value) {\n  const array = new Uint8Array(0 + Uint64.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.hash)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class BlockHashEntryVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * BlockHashEntry.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new BlockHashEntry(\n      this.view.buffer.slice(4 + i * BlockHashEntry.size(), 4 + (i + 1) * BlockHashEntry.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBlockHashEntryVec(value) {\n  const array = new Uint8Array(4 + BlockHashEntry.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeBlockHashEntry(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * BlockHashEntry.size());\n  }\n  return array.buffer;\n}\n\nexport class CKBMerkleProof {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32Vec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getIndices() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLemmas() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCKBMerkleProof(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32Vec(value.indices));\n  buffers.push(SerializeByte32Vec(value.lemmas));\n  return serializeTable(buffers);\n}\n\nexport class CCTransactionWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new ScriptVec(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n    new BlockHashEntryVec(this.view.buffer.slice(offsets[10], offsets[11]), { validate: false }).validate();\n  }\n\n  getL2Tx() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRawL2Block() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashesProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAccountCount() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLoadData() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScripts() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getReturnDataHash() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashes() {\n    const start = 44;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BlockHashEntryVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCCTransactionWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeBytes(value.block_hashes_proof));\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytesVec(value.load_data));\n  buffers.push(SerializeScriptVec(value.scripts));\n  buffers.push(SerializeByte32(value.return_data_hash));\n  buffers.push(SerializeBlockHashEntryVec(value.block_hashes));\n  return serializeTable(buffers);\n}\n\nexport class CCTransactionSignatureWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new L2Transaction(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2Tx() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAccountCount() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSender() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getReceiver() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCCTransactionSignatureWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeScript(value.sender));\n  buffers.push(SerializeScript(value.receiver));\n  return serializeTable(buffers);\n}\n\nexport class CCWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new WithdrawalRequest(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawal() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSender() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOwnerLock() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCCWithdrawalWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeWithdrawalRequest(value.withdrawal));\n  buffers.push(SerializeScript(value.sender));\n  buffers.push(SerializeScript(value.owner_lock));\n  buffers.push(SerializeCKBMerkleProof(value.withdrawal_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupSubmitBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getBlock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockHashes() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupSubmitBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Block(value.block));\n  buffers.push(SerializeByte32Vec(value.reverted_block_hashes));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupEnterChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeWitness(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getWitness() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ChallengeWitness(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupEnterChallenge(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeWitness(value.witness));\n  return serializeTable(buffers);\n}\n\nexport class RollupCancelChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n}\n\nexport function SerializeRollupCancelChallenge(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class RollupRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2BlockVec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getRevertedBlocks() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2BlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNewTipBlock() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupRevert(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2BlockVec(value.reverted_blocks));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  buffers.push(SerializeRawL2Block(value.new_tip_block));\n  return serializeTable(buffers);\n}\n\nexport class RollupAction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 2:\n        new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 3:\n        new RollupRevert(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"RollupSubmitBlock\";\n      case 1:\n        return \"RollupEnterChallenge\";\n      case 2:\n        return \"RollupCancelChallenge\";\n      case 3:\n        return \"RollupRevert\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false });\n      case 2:\n        return new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false });\n      case 3:\n        return new RollupRevert(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeRollupAction(value) {\n  switch (value.type) {\n    case \"RollupSubmitBlock\": {\n      const itemBuffer = SerializeRollupSubmitBlock(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupEnterChallenge\": {\n      const itemBuffer = SerializeRollupEnterChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupCancelChallenge\": {\n      const itemBuffer = SerializeRollupCancelChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupRevert\": {\n      const itemBuffer = SerializeRollupRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 3, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class Byte20 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 20);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 20;\n  }\n}\n\nexport function SerializeByte20(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 20);\n  return buffer;\n}\n\nexport class ETHAddrRegArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new EthToGw(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new GwToEth(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 2:\n        new SetMapping(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 3:\n        new BatchSetMapping(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"EthToGw\";\n      case 1:\n        return \"GwToEth\";\n      case 2:\n        return \"SetMapping\";\n      case 3:\n        return \"BatchSetMapping\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new EthToGw(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new GwToEth(this.view.buffer.slice(4), { validate: false });\n      case 2:\n        return new SetMapping(this.view.buffer.slice(4), { validate: false });\n      case 3:\n        return new BatchSetMapping(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeETHAddrRegArgs(value) {\n  switch (value.type) {\n    case \"EthToGw\": {\n      const itemBuffer = SerializeEthToGw(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"GwToEth\": {\n      const itemBuffer = SerializeGwToEth(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"SetMapping\": {\n      const itemBuffer = SerializeSetMapping(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"BatchSetMapping\": {\n      const itemBuffer = SerializeBatchSetMapping(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 3, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class EthToGw {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getEthAddress() {\n    return new Byte20(this.view.buffer.slice(0, 0 + Byte20.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, EthToGw.size());\n    this.getEthAddress().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte20.size();\n  }\n}\n\nexport function SerializeEthToGw(value) {\n  const array = new Uint8Array(0 + Byte20.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte20(value.eth_address)), 0);\n  return array.buffer;\n}\n\nexport class GwToEth {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getGwScriptHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GwToEth.size());\n    this.getGwScriptHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeGwToEth(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.gw_script_hash)), 0);\n  return array.buffer;\n}\n\nexport class SetMapping {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getGwScriptHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getFee() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SetMapping.size());\n    this.getGwScriptHash().validate(compatible);\n    this.getFee().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeSetMapping(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.gw_script_hash)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.fee)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class BatchSetMapping {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32Vec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getGwScriptHashes() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBatchSetMapping(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32Vec(value.gw_script_hashes));\n  buffers.push(SerializeUint64(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class Uint16 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 2);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint16() {\n    return this.view.getUint16(0, false);\n  }\n\n  toLittleEndianUint16() {\n    return this.view.getUint16(0, true);\n  }\n\n  static size() {\n    return 2;\n  }\n}\n\nexport function SerializeUint16(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 2);\n  return buffer;\n}\n\nexport class Uint32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint32() {\n    return this.view.getUint32(0, false);\n  }\n\n  toLittleEndianUint32() {\n    return this.view.getUint32(0, true);\n  }\n\n  static size() {\n    return 4;\n  }\n}\n\nexport function SerializeUint32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 4);\n  return buffer;\n}\n\nexport class Uint64 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 8);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 8;\n  }\n}\n\nexport function SerializeUint64(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 8);\n  return buffer;\n}\n\nexport class Uint128 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 16);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 16;\n  }\n}\n\nexport function SerializeUint128(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 16);\n  return buffer;\n}\n\nexport class Byte32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeByte32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Uint256 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeUint256(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Bytes {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBytes(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nexport class BytesOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Bytes(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeBytesOpt(value) {\n  if (value) {\n    return SerializeBytes(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class BytesVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBytesVec(value) {\n  return serializeTable(value.map((item) => SerializeBytes(item)));\n}\n\nexport class Byte32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeByte32Vec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n  return array.buffer;\n}\n\nexport class ScriptOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Script(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeScriptOpt(value) {\n  if (value) {\n    return SerializeScript(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class ProposalShortId {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 10);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 10;\n  }\n}\n\nexport function SerializeProposalShortId(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 10);\n  return buffer;\n}\n\nexport class UncleBlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new UncleBlock(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlockVec(value) {\n  return serializeTable(value.map((item) => SerializeUncleBlock(item)));\n}\n\nexport class TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeTransaction(item)));\n}\n\nexport class ProposalShortIdVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new ProposalShortId(\n      this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeProposalShortIdVec(value) {\n  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeProposalShortId(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n  }\n  return array.buffer;\n}\n\nexport class CellDepVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellDep.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellDepVec(value) {\n  const array = new Uint8Array(4 + CellDep.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellDep(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n  }\n  return array.buffer;\n}\n\nexport class CellInputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellInput.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellInputVec(value) {\n  const array = new Uint8Array(4 + CellInput.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellInput(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n  }\n  return array.buffer;\n}\n\nexport class CellOutputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new CellOutput(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutputVec(value) {\n  return serializeTable(value.map((item) => SerializeCellOutput(item)));\n}\n\nexport class Script {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    if (offsets[2] - offsets[1] !== 1) {\n      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);\n    }\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCodeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHashType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getArgs() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScript(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.code_hash));\n  const hashTypeView = new DataView(new ArrayBuffer(1));\n  hashTypeView.setUint8(0, value.hash_type);\n  buffers.push(hashTypeView.buffer);\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class OutPoint {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, OutPoint.size());\n    this.getTxHash().validate(compatible);\n    this.getIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeOutPoint(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class CellInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSince() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getPreviousOutput() {\n    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellInput.size());\n    this.getSince().validate(compatible);\n    this.getPreviousOutput().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + OutPoint.size();\n  }\n}\n\nexport function SerializeCellInput(value) {\n  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class CellOutput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutput(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeScriptOpt(value.type_));\n  return serializeTable(buffers);\n}\n\nexport class CellDep {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOutPoint() {\n    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), { validate: false });\n  }\n\n  getDepType() {\n    return this.view.getUint8(0 + OutPoint.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellDep.size());\n    this.getOutPoint().validate(compatible);\n  }\n  static size() {\n    return 0 + OutPoint.size() + 1;\n  }\n}\n\nexport function SerializeCellDep(value) {\n  const array = new Uint8Array(0 + OutPoint.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n  view.setUint8(0 + OutPoint.size(), value.dep_type);\n  return array.buffer;\n}\n\nexport class RawTransaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getVersion() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCellDeps() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellDepVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHeaderDeps() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellInputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputs() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputsData() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.version));\n  buffers.push(SerializeCellDepVec(value.cell_deps));\n  buffers.push(SerializeByte32Vec(value.header_deps));\n  buffers.push(SerializeCellInputVec(value.inputs));\n  buffers.push(SerializeCellOutputVec(value.outputs));\n  buffers.push(SerializeBytesVec(value.outputs_data));\n  return serializeTable(buffers);\n}\n\nexport class Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawTransaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWitnesses() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawTransaction(value.raw));\n  buffers.push(SerializeBytesVec(value.witnesses));\n  return serializeTable(buffers);\n}\n\nexport class RawHeader {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getVersion() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getCompactTarget() {\n    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  getNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getEpoch() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getParentHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTransactionsRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getProposalsHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getExtraHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getDao() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawHeader.size());\n    this.getVersion().validate(compatible);\n    this.getCompactTarget().validate(compatible);\n    this.getTimestamp().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getEpoch().validate(compatible);\n    this.getParentHash().validate(compatible);\n    this.getTransactionsRoot().validate(compatible);\n    this.getProposalsHash().validate(compatible);\n    this.getExtraHash().validate(compatible);\n    this.getDao().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size()\n    );\n  }\n}\n\nexport function SerializeRawHeader(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeUint64(value.epoch)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.parent_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.transactions_root)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.proposals_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.extra_hash)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.dao)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class Header {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRaw() {\n    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), { validate: false });\n  }\n\n  getNonce() {\n    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Header.size());\n    this.getRaw().validate(compatible);\n    this.getNonce().validate(compatible);\n  }\n  static size() {\n    return 0 + RawHeader.size() + Uint128.size();\n  }\n}\n\nexport function SerializeHeader(value) {\n  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n  return array.buffer;\n}\n\nexport class UncleBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class BlockV1 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getExtension() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlockV1(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  buffers.push(SerializeBytes(value.extension));\n  return serializeTable(buffers);\n}\n\nexport class CellbaseWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getMessage() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellbaseWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeBytes(value.message));\n  return serializeTable(buffers);\n}\n\nexport class WitnessArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWitnessArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.lock));\n  buffers.push(SerializeBytesOpt(value.input_type));\n  buffers.push(SerializeBytesOpt(value.output_type));\n  return serializeTable(buffers);\n}\n","import { Hash, HexString, HexNumber, Script } from \"@ckb-lumos/base\";\n\nexport type Uint32 = number;\nexport type Uint64 = bigint;\nexport type Uint128 = bigint;\nexport type Uint256 = bigint;\n\nexport interface RunResult {\n  read_values: Map<Hash, Hash>;\n  write_values: Map<Hash, Hash>;\n  return_data: HexString;\n  account_count?: HexNumber;\n  new_scripts: Map<Hash, HexString>;\n  write_data: Map<Hash, HexString>;\n  read_data: Map<Hash, HexNumber>;\n}\nexport interface RawL2Transaction {\n  from_id: HexNumber;\n  to_id: HexNumber;\n  nonce: HexNumber;\n  args: HexString;\n}\nexport interface L2Transaction {\n  raw: RawL2Transaction;\n  signature: HexString;\n}\n\nexport interface CreateAccount {\n  script: Script;\n}\n\nexport interface Fee {\n  sudt_id: Uint32;\n  amount: Uint128;\n}\n\nexport interface RawWithdrawalRequest {\n  nonce: HexNumber;\n  // CKB amount\n  capacity: HexNumber;\n  // SUDT amount\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n  // layer2 account_script_hash\n  account_script_hash: Hash;\n  // buyer can pay sell_amount and sell_capacity to unlock\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n  fee: Fee;\n}\nexport interface WithdrawalRequest {\n  raw: RawWithdrawalRequest;\n  signature: HexString;\n}\n\nexport interface RawWithdrawalRequestV1 {\n  nonce: HexNumber;\n  chain_id: HexNumber;\n  // CKB amount\n  capacity: HexNumber;\n  // SUDT amount\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n  // layer2 account_script_hash\n  account_script_hash: Hash;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  fee: HexNumber;\n}\n\nexport interface WithdrawalRequestV1 {\n  raw: RawWithdrawalRequestV1;\n  signature: HexString;\n}\n\nexport interface WithdrawalRequestExtra {\n  request: WithdrawalRequestV1;\n  owner_lock: Script;\n}\n\nexport interface WithdrawalLockArgs {\n  // layer2 account script hash\n  account_script_hash: Hash;\n  // the original custodian lock hash\n  withdrawal_block_hash: Hash;\n  withdrawal_block_number: HexNumber;\n  // buyer can pay sell_amount token to unlock\n  sudt_script_hash: Hash;\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n}\n\nexport interface UnlockWithdrawalViaFinalize {\n  block_proof: HexString;\n}\n\n// export interface HeaderInfo {\n//     number: Uint64;\n//     block_hash: Hash;\n// }\n// FIXME: todo\n// export interface L2Block {}\nexport enum Status {\n  Running = \"running\",\n  Halting = \"halting\",\n}\n\nexport interface LastL2BlockCommittedInfo {\n  transaction_hash: Hash;\n}\n","import * as normalizer from \"./normalizer\";\nimport * as core from \"../schemas\";\nimport {\n  NormalizeL2Transaction,\n  NormalizeRawL2Transaction,\n  NormalizeCreateAccount,\n  NormalizeWithdrawalRequest,\n  NormalizeRawWithdrawalRequest,\n} from \"./normalizer\";\nimport {\n  L2Transaction,\n  RawL2Transaction,\n  RawWithdrawalRequest,\n  WithdrawalRequest,\n  WithdrawalRequestExtra,\n  RunResult,\n  Uint128,\n  Uint32,\n  Uint64,\n  Fee,\n  LastL2BlockCommittedInfo,\n} from \"./types\";\nimport { SerializeRawWithdrawalRequestV1, SerializeWithdrawalRequestExtra } from \"./schema_v1\";\nimport { RPC, Reader } from \"ckb-js-toolkit\";\nimport { Hash, HexString, Script, utils } from \"@ckb-lumos/base\";\nimport keccak256 from \"keccak256\";\nexport * from \"./types\";\n\nexport { core, normalizer, SerializeRawWithdrawalRequestV1 };\nexport type { WithdrawalRequestExtra };\n\nexport function numberToUInt32LE(value: number): HexString {\n  const buf = Buffer.alloc(4);\n  buf.writeUInt32LE(value);\n  return `0x${buf.toString(\"hex\")}`;\n}\n\nexport function UInt32LEToNumber(hex: HexString): number {\n  const buf = Buffer.from(hex.slice(2, 10), \"hex\");\n  return buf.readUInt32LE(0);\n}\n\nexport function u32ToHex(value: number): HexString {\n  return `0x${value.toString(16)}`;\n}\n\nexport function hexToU32(hex: HexString): number {\n  // return parseInt(hex.slice(2), \"hex\");\n  return +hex;\n}\n\nexport function toBuffer(ab: ArrayBuffer): Buffer {\n  const buf = Buffer.alloc(ab.byteLength);\n  const view = new Uint8Array(ab);\n  for (let i = 0; i < buf.length; ++i) {\n    buf[i] = view[i];\n  }\n  return buf;\n}\n\nexport function toArrayBuffer(buf: Buffer) {\n  const ab = new ArrayBuffer(buf.length);\n  const view = new Uint8Array(ab);\n  for (let i = 0; i < buf.length; ++i) {\n    view[i] = buf[i];\n  }\n  return ab;\n}\n\nexport class Godwoken {\n  private rpc: RPC;\n\n  constructor(url: string) {\n    this.rpc = new RPC(url);\n  }\n\n  /**\n   * chain_id: u64 = (compatible_chain_id << 32) | creator_id\n   *\n   * e.g. 0x315DA00000005 = 868,450,977,185,797\n   */\n  async getChainId(): Promise<string> {\n    const result = await this.rpc[\"eth_chainId\"]();\n    console.debug(\"chain_id:\", result);\n    return result;\n  }\n\n  private async rpcCall(method_name: string, ...args: any[]): Promise<any> {\n    const name = \"gw_\" + method_name;\n    const result = await this.rpc[name](...args);\n    return result;\n  }\n\n  async _send(l2tx: L2Transaction, method_name: string) {\n    const data = new Reader(core.SerializeL2Transaction(NormalizeL2Transaction(l2tx))).serializeJson();\n    return await this.rpcCall(method_name, data);\n  }\n\n  async executeL2Transaction(l2tx: L2Transaction): Promise<RunResult> {\n    return this._send(l2tx, \"execute_l2transaction\");\n  }\n\n  async submitL2Transaction(l2tx: L2Transaction): Promise<Hash> {\n    return this._send(l2tx, \"submit_l2transaction\");\n  }\n\n  async executeRawL2Transaction(rawL2Tx: RawL2Transaction): Promise<RunResult> {\n    const hex = new Reader(core.SerializeRawL2Transaction(NormalizeRawL2Transaction(rawL2Tx))).serializeJson();\n    return await this.rpcCall(\"execute_raw_l2transaction\", hex);\n  }\n\n  async submitWithdrawalRequest(request: WithdrawalRequest): Promise<void> {\n    const data = new Reader(core.SerializeWithdrawalRequest(NormalizeWithdrawalRequest(request))).serializeJson();\n    return await this.rpcCall(\"submit_withdrawal_request\", data);\n  }\n\n  async submitWithdrawalReqV1(reqExtra: WithdrawalRequestExtra): Promise<Hash> {\n    const data = new Reader(\n      SerializeWithdrawalRequestExtra(normalizer.NormalizeWithdrawalReqExtra(reqExtra)),\n    ).serializeJson();\n    return await this.rpcCall(\"submit_withdrawal_request\", data);\n  }\n\n  // TODO\n  // async function getWithdrawal(withdrawalHash: Hash) {\n  //   withdrawal_hash\n  // }\n\n  async getScriptHashByShortAddress(address: HexString): Promise<Hash> {\n    return await this.rpcCall(\"get_script_hash_by_short_address\", address);\n  }\n\n  // TODO: maybe swap params later?\n  async getBalance(sudt_id: Uint32, address: HexString): Promise<Uint128> {\n    const sudt_id_hex = `0x${(+sudt_id).toString(16)}`;\n    const balance = await this.rpcCall(\"get_balance\", address, sudt_id_hex);\n    return BigInt(balance);\n  }\n\n  async getBalanceById(sudt_id: Uint32, account_id: Uint32): Promise<Uint128> {\n    const scriptHash = await this.getScriptHash(account_id);\n    const address = scriptHash.slice(0, 42);\n    const balance = await this.getBalance(sudt_id, address);\n    return balance;\n  }\n\n  async getStorageAt(account_id: Uint32, key: Hash): Promise<Hash> {\n    const account_id_hex = `0x${account_id.toString(16)}`;\n    return await this.rpcCall(\"get_storage_at\", account_id_hex, key);\n  }\n\n  async getAccountIdByScriptHash(script_hash: Hash): Promise<Uint32 | undefined> {\n    const id = await this.rpcCall(\"get_account_id_by_script_hash\", script_hash);\n    return id ? +id : undefined;\n  }\n\n  async getNonce(account_id: Uint32): Promise<Uint32> {\n    const account_id_hex = `0x${account_id.toString(16)}`;\n    const nonce = await this.rpcCall(\"get_nonce\", account_id_hex);\n    return parseInt(nonce);\n  }\n\n  async getScript(script_hash: Hash): Promise<Script> {\n    return await this.rpcCall(\"get_script\", script_hash);\n  }\n\n  async getScriptHash(account_id: Uint32): Promise<Hash> {\n    const account_id_hex = `0x${account_id.toString(16)}`;\n    return await this.rpcCall(\"get_script_hash\", account_id_hex);\n  }\n\n  async getData(data_hash: Hash): Promise<HexString> {\n    return await this.rpcCall(\"get_data\", data_hash);\n  }\n\n  async hasDataHash(data_hash: Hash): Promise<boolean> {\n    return await this.rpcCall(\"get_data_hash\", data_hash);\n  }\n\n  async getTransactionReceipt(l2_tx_hash: Hash) {\n    return await this.rpcCall(\"get_transaction_receipt\", l2_tx_hash);\n  }\n\n  async getLastSubmittedInfo(): Promise<LastL2BlockCommittedInfo> {\n    return await this.rpcCall(\"get_last_submitted_info\");\n  }\n}\n\nexport class GodwokenUtils {\n  private rollup_type_hash: Hash;\n\n  constructor(rollup_type_hash: Hash) {\n    this.rollup_type_hash = rollup_type_hash;\n  }\n\n  generateTransactionMessageWithoutPrefixToSign(\n    raw_l2tx: RawL2Transaction,\n    sender_script_hash: Hash,\n    receiver_script_hash: Hash,\n  ): Hash {\n    const raw_tx_data = core.SerializeRawL2Transaction(NormalizeRawL2Transaction(raw_l2tx));\n    const rollup_type_hash = Buffer.from(this.rollup_type_hash.slice(2), \"hex\");\n    const senderScriptHash = Buffer.from(sender_script_hash.slice(2), \"hex\");\n    const receiverScriptHash = Buffer.from(receiver_script_hash.slice(2), \"hex\");\n    const data = toArrayBuffer(\n      Buffer.concat([rollup_type_hash, senderScriptHash, receiverScriptHash, toBuffer(raw_tx_data)]),\n    );\n    const message = utils.ckbHash(data).serializeJson();\n    return message;\n  }\n\n  generateTransactionMessageToSign(\n    raw_l2tx: RawL2Transaction,\n    sender_script_hash: Hash,\n    receiver_script_hash: Hash,\n  ): Hash {\n    const message = this.generateTransactionMessageWithoutPrefixToSign(\n      raw_l2tx,\n      sender_script_hash,\n      receiver_script_hash,\n    );\n    const prefix_buf = Buffer.from(`\\x19Ethereum Signed Message:\\n32`);\n    const buf = Buffer.concat([prefix_buf, Buffer.from(message.slice(2), \"hex\")]);\n    return `0x${keccak256(buf).toString(\"hex\")}`;\n  }\n\n  generateWithdrawalMessageWithoutPrefixToSign(raw_request: RawWithdrawalRequest): Hash {\n    const raw_request_data = core.SerializeRawWithdrawalRequest(NormalizeRawWithdrawalRequest(raw_request));\n    const rollup_type_hash = Buffer.from(this.rollup_type_hash.slice(2), \"hex\");\n    const data = toArrayBuffer(Buffer.concat([rollup_type_hash, toBuffer(raw_request_data)]));\n    const message = utils.ckbHash(data).serializeJson();\n    return message;\n  }\n\n  generateWithdrawalMessageToSign(raw_request: RawWithdrawalRequest): Hash {\n    const message = this.generateWithdrawalMessageWithoutPrefixToSign(raw_request);\n    const prefix_buf = Buffer.from(`\\x19Ethereum Signed Message:\\n32`);\n    const buf = Buffer.concat([prefix_buf, Buffer.from(message.slice(2), \"hex\")]);\n    return `0x${keccak256(buf).toString(\"hex\")}`;\n  }\n\n  static createAccountRawL2Transaction(\n    from_id: Uint32,\n    nonce: Uint32,\n    script: Script,\n    sudt_id: Uint32 = 1,\n    fee_amount: Uint128 = BigInt(0),\n  ): RawL2Transaction {\n    const create_account = {\n      script,\n      fee: {\n        sudt_id: \"0x\" + (+sudt_id).toString(16),\n        amount: \"0x\" + BigInt(fee_amount).toString(16),\n      },\n    };\n    const enum_tag = \"0x00000000\";\n    const create_account_part = new Reader(\n      core.SerializeCreateAccount(NormalizeCreateAccount(create_account)),\n    ).serializeJson();\n    const args = enum_tag + create_account_part.slice(2);\n    return {\n      from_id: u32ToHex(from_id),\n      to_id: u32ToHex(0),\n      nonce: u32ToHex(nonce),\n      args,\n    };\n  }\n\n  static createRawWithdrawalRequest(\n    nonce: Uint32,\n    capacity: Uint64,\n    amount: Uint128,\n    sudt_script_hash: Hash,\n    account_script_hash: Hash,\n    sell_amount: Uint128,\n    sell_capacity: Uint64,\n    owner_lock_hash: Hash,\n    payment_lock_hash: Hash,\n    fee: Fee,\n  ): RawWithdrawalRequest {\n    return {\n      nonce: \"0x\" + BigInt(nonce).toString(16),\n      capacity: \"0x\" + BigInt(capacity).toString(16),\n      amount: \"0x\" + BigInt(amount).toString(16),\n      sudt_script_hash: sudt_script_hash,\n      account_script_hash: account_script_hash,\n      sell_amount: \"0x\" + BigInt(sell_amount).toString(16),\n      sell_capacity: \"0x\" + BigInt(sell_capacity).toString(16),\n      owner_lock_hash: owner_lock_hash,\n      payment_lock_hash: payment_lock_hash,\n      fee,\n    };\n  }\n}\n","import { Hash, HexNumber, HexString, PackedSince, Script } from \"@ckb-lumos/base\";\nimport { normalizers, Reader } from \"ckb-js-toolkit\";\nimport { L2Transaction, WithdrawalRequest, WithdrawalRequestExtra, WithdrawalRequestV1 } from \"./types\";\n\n// Taken for now from https://github.com/xxuejie/ckb-js-toolkit/blob/68f5ff709f78eb188ee116b2887a362123b016cc/src/normalizers.js#L17-L69,\n// later we can think about exposing those functions directly.\nfunction normalizeHexNumber(length: number) {\n  return function (debugPath: string, value: any) {\n    if (!(value instanceof ArrayBuffer)) {\n      let intValue = BigInt(value).toString(16);\n      if (intValue.length % 2 !== 0) {\n        intValue = \"0\" + intValue;\n      }\n      if (intValue.length / 2 > length) {\n        throw new Error(`${debugPath} is ${intValue.length / 2} bytes long, expected length is ${length}!`);\n      }\n      const view = new DataView(new ArrayBuffer(length));\n      for (let i = 0; i < intValue.length / 2; i++) {\n        const start = intValue.length - (i + 1) * 2;\n        view.setUint8(i, parseInt(intValue.substr(start, 2), 16));\n      }\n      value = view.buffer;\n    }\n    if (value.byteLength < length) {\n      const array = new Uint8Array(length);\n      array.set(new Uint8Array(value), 0);\n      value = array.buffer;\n    }\n    return value;\n  };\n}\n\nfunction normalizeRawData(length: number) {\n  return function (debugPath: string, value: any) {\n    value = new Reader(value).toArrayBuffer();\n    if (length > 0 && value.byteLength !== length) {\n      throw new Error(`${debugPath} has invalid length ${value.byteLength}, required: ${length}`);\n    }\n    return value;\n  };\n}\n\nfunction normalizeObject(debugPath: string, obj: any, keys: object) {\n  const result: any = {};\n\n  for (const [key, f] of Object.entries(keys)) {\n    const value = obj[key];\n    if (value === undefined || value === null) {\n      throw new Error(`${debugPath} is missing ${key}!`);\n    }\n    result[key] = f(`${debugPath}.${key}`, value);\n  }\n  return result;\n}\n\nfunction toNormalize(normalize: Function) {\n  return function (debugPath: string, value: any) {\n    return normalize(value, {\n      debugPath,\n    });\n  };\n}\n\nexport interface DepositRequest {\n  capacity: HexNumber;\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n  script: Script;\n}\n\nexport function NormalizeDepositRequest(request: object, { debugPath = \"deposit_request\" } = {}) {\n  return normalizeObject(debugPath, request, {\n    capacity: normalizeHexNumber(8),\n    amount: normalizeHexNumber(16),\n    sudt_script_hash: normalizeRawData(32),\n    script: toNormalize(normalizers.NormalizeScript),\n  });\n}\n\nexport interface DepositLockArgs {\n  owner_lock_hash: Hash;\n  layer2_lock: Script;\n  cancel_timeout: PackedSince;\n}\n\nexport function NormalizeDepositLockArgs(args: object, { debugPath = \"deposit_lock_args\" } = {}) {\n  return normalizeObject(debugPath, args, {\n    owner_lock_hash: normalizeRawData(32),\n    layer2_lock: toNormalize(normalizers.NormalizeScript),\n    cancel_timeout: normalizeHexNumber(8),\n  });\n}\n\nexport interface HeaderInfo {\n  number: HexNumber;\n  block_hash: Hash;\n}\n\nexport function NormalizeHeaderInfo(headerInfo: object, { debugPath = \"header_info\" } = {}) {\n  return normalizeObject(debugPath, headerInfo, {\n    number: normalizeHexNumber(8),\n    block_hash: normalizeRawData(32),\n  });\n}\n\nexport interface CustodianLockArgs {\n  deposit_block_hash: Hash;\n  deposit_block_number: HexNumber;\n  deposit_lock_args: DepositLockArgs;\n}\n\nexport function NormalizeCustodianLockArgs(args: object, { debugPath = \"custondian_lock_args\" } = {}) {\n  return normalizeObject(debugPath, args, {\n    deposit_block_hash: normalizeRawData(32),\n    deposit_block_number: normalizeHexNumber(8),\n    deposit_lock_args: toNormalize(NormalizeDepositLockArgs),\n  });\n}\n\nexport function NormalizeRawL2Transaction(rawL2Transaction: object, { debugPath = \"raw_l2_transaction\" } = {}) {\n  return normalizeObject(debugPath, rawL2Transaction, {\n    from_id: normalizeHexNumber(4),\n    to_id: normalizeHexNumber(4),\n    nonce: normalizeHexNumber(4),\n    args: normalizeRawData(-1),\n  });\n}\n\nexport function NormalizeL2Transaction(l2Transaction: L2Transaction, { debugPath = \"l2_transaction\" } = {}) {\n  return normalizeObject(debugPath, l2Transaction, {\n    raw: toNormalize(NormalizeRawL2Transaction),\n    signature: normalizeRawData(-1),\n  });\n}\n\nexport function NormalizeRawWithdrawalRequest(raw_request: object, { debugPath = \"raw_withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, raw_request, {\n    nonce: normalizeHexNumber(4),\n    capacity: normalizeHexNumber(8),\n    amount: normalizeHexNumber(16),\n    sudt_script_hash: normalizeRawData(32),\n    account_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    owner_lock_hash: normalizeRawData(32),\n    payment_lock_hash: normalizeRawData(32),\n    fee: toNormalize(NormalizeFee),\n  });\n}\n\nexport function NormalizeRawWithdrawalRequestV1(raw_request_v1: object, { debugPath = \"raw_withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, raw_request_v1, {\n    nonce: normalizeHexNumber(4),\n    chain_id: normalizeHexNumber(8),\n    // CKB amount\n    capacity: normalizeHexNumber(8),\n    // SUDT amount\n    amount: normalizeHexNumber(16),\n    sudt_script_hash: normalizeRawData(32),\n    // layer2 account_script_hash\n    account_script_hash: normalizeRawData(32),\n    // layer1 lock to withdraw after challenge period\n    owner_lock_hash: normalizeRawData(32),\n    // withdrawal fee, paid to block producer\n    fee: normalizeHexNumber(8),\n  });\n}\n\nexport function NormalizeWithdrawalRequestV1(\n  request_v1: WithdrawalRequestV1,\n  { debugPath = \"withdrawal_request\" } = {},\n) {\n  return normalizeObject(debugPath, request_v1, {\n    raw: toNormalize(NormalizeRawWithdrawalRequestV1),\n    signature: normalizeRawData(65),\n  });\n}\n\nexport function NormalizeWithdrawalReqExtra(\n  withdrawalReqExtra: WithdrawalRequestExtra,\n  { debugPath = \"withdrawal_request\" } = {},\n) {\n  return normalizeObject(debugPath, withdrawalReqExtra, {\n    request: toNormalize(NormalizeWithdrawalRequestV1),\n    owner_lock: toNormalize(normalizers.NormalizeScript),\n  });\n}\n\nexport function NormalizeWithdrawalRequest(request: WithdrawalRequest, { debugPath = \"withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, request, {\n    raw: toNormalize(NormalizeRawWithdrawalRequest),\n    signature: normalizeRawData(65),\n  });\n}\n\nexport interface UnoinType {\n  type: string;\n  value: any;\n}\n\nexport function NormalizeFee(fee: object, { debugPath = \"fee\" } = {}) {\n  return normalizeObject(debugPath, fee, {\n    sudt_id: normalizeHexNumber(4),\n    amount: normalizeHexNumber(16),\n  });\n}\n\nexport function NormalizeCreateAccount(createAccount: object, { debugPath = \"create_account\" } = {}) {\n  return normalizeObject(debugPath, createAccount, {\n    script: toNormalize(normalizers.NormalizeScript),\n    fee: toNormalize(NormalizeFee),\n  });\n}\n\nexport interface SUDTQuery {\n  short_address: HexString;\n}\n\nexport function NormalizeSUDTQuery(sudt_query: object, { debugPath = \"sudt_query\" } = {}) {\n  return normalizeObject(debugPath, sudt_query, {\n    short_address: normalizeRawData(20),\n  });\n}\n\nexport interface SUDTTransfer {\n  to: HexString;\n  amount: HexNumber;\n  fee: HexNumber;\n}\n\nexport function NormalizeSUDTTransfer(sudt_transfer: object, { debugPath = \"sudt_transfer\" } = {}) {\n  return normalizeObject(debugPath, sudt_transfer, {\n    to: normalizeRawData(20),\n    amount: normalizeHexNumber(16),\n    fee: normalizeHexNumber(16),\n  });\n}\n\nexport function NormalizeWithdrawalLockArgs(withdrawal_lock_args: object, { debugPath = \"withdrawal_lock_args\" } = {}) {\n  return normalizeObject(debugPath, withdrawal_lock_args, {\n    // the original deposit info\n    // used for helping programs generate reverted custodian cell\n    // deposit_block_hash: normalizeRawData(32),\n    // deposit_block_number: normalizeHexNumber(8),\n    account_script_hash: normalizeRawData(32),\n    // the original custodian lock hash\n    withdrawal_block_hash: normalizeRawData(32),\n    withdrawal_block_number: normalizeHexNumber(8),\n    // buyer can pay sell_amount token to unlock\n    sudt_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    // layer1 lock to withdraw after challenge period\n    owner_lock_hash: normalizeRawData(32),\n    // layer1 lock to receive the payment, must exists on the chain\n    payment_lock_hash: normalizeRawData(32),\n  });\n}\n\nexport function NormalizeUnlockWithdrawalViaFinalize(\n  unlock_withdrawal_finalize: object,\n  { debugPath = \"unlock_withdrawal_finalize\" } = {},\n) {\n  return normalizeObject(debugPath, unlock_withdrawal_finalize, {});\n}\n","export const SCRIPTS = {\n  eth_account_lock: {\n    script_type_hash: \"0xed470b3ce58c73a9673cbb28cf34a44d0b85ed1b5bef0eea4b3c475344379b39\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xf19a616f3f556d9a8d2455b8744cc29bcfccbf90f4bc877a91d4b40fba13ac67\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  deposit_lock: {\n    script_type_hash: \"0x33ac8fb80e43697a8b886883cc650136fa6e8e9c261eb335b6fc1f8d54b74870\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x529f6c9413e5e386454131294c6122736b6a681f0d9cfce8683dfc4701885a68\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  polyjuice_generator: {\n    script_type_hash: \"0x4ce86361c74ca046a775b860cd1faa62aca4d4d6c2178137ab8ad899a11fffee\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xaea5ecadbd91dbd5133f78b54bd749eec34f79bfaaba8690d3cdeb5377392d11\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  l2_sudt_validator: {\n    script_type_hash: \"0x76479d9e2773fe0bae011345d085b59b6e7c4d80f392799a7d7041305ec61c73\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x29b7809236c53e0245cc45d93349687810e0d1c57ebe82334f84aaaf64d6fb44\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  meta_contract_validator: {\n    script_type_hash: \"0xafaa3646deaa86d1a4734b9a9a778468ad5c4fb5fc22873310bd8a41ae7b5421\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xbcd23414f5e8efd419b1cedd107a6f985c78e110f9a9237f65176675fad7aba9\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  custodian_lock: {\n    script_type_hash: \"0x5f86d23b30daec1fcbcde129eceda31f6f813b2b517804cf4aed08b442e7d606\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x3c774b747039c5d15fcbe4f455ddf14c298e92b81a5d71ec93c7c6b14ae558e6\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  l2_sudt_generator: {\n    script_type_hash: \"0xcbd0184a794a47ac5abc53434bdf11dfc615bb68f38a9169204cc4bb234350ad\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x02fdaa1137f624b9782abe7020f9b147a65034da0fddeab6e1ffb913ec165bb0\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  state_validator_lock: {\n    script_type_hash: \"0x84bdbca813620c03f7cf5af8f23559f09ab22619cb4de0aa1e0c72fc3074ecf9\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x582827f0c6bee23ab4679aee1e3bfea56effc02d9e501e70b51e685cb7ad0cfc\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  challenge_lock: {\n    script_type_hash: \"0x839585217150517810da3f55930fc9ead100e007d1bb393ed9bb872b54ed4080\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x991ca391cc092873ebf45b72378e959d78ef8f07bbe4f2096d0939072086d277\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  meta_contract_generator: {\n    script_type_hash: \"0x74af9b7b1b2e797db3b308599926360b83211a75991f1991ffff3817d12c699f\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x056b466a51e791f7b4bf8bac64826dd2844500f06a9f25a4ce1372b52aea8e71\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  always_success: {\n    script_type_hash: \"0x38bea2c593d5426b839b721d2b7a5e6953d9dbc8d738220f3d332cd26393597f\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xf3ff1c8c590ad95fbdf65c1fd70f5be2edde510766dd20cd9c2c043a4d38b121\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  state_validator: {\n    script_type_hash: \"0x5826d84d9345d6688602762773662aec64d765b4cbc01284b4de1aa361dfc300\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xbee9869a0839fb9cd17fadba6a3b3313779d8d340eb04fa4fbd0cfe7b8c5cc12\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  polyjuice_validator: {\n    script_type_hash: \"0x10a3fb3e485491c71c097b971078600ef5f7ef492c2c5bf9411dfe7538211f74\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x06ce06917e134939e8f1e5ac34cdeccd6b8b3048a5e895d89ec0c7e5fd63b174\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  poa_state: {\n    script_type_hash: \"0xcdc3c7b3178eebd8dcd035d1dae452dbed1d9d22a480977bbc59c786f9baa130\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xe8f46f0c968d25f883785bc5a218f61d9df728de79b1f6a120533b2a3c1ebe09\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  stake_lock: {\n    script_type_hash: \"0xef984822bac9ddaa865c1bca61beda671ec3b86dc83fe8f909954da730e82901\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x4442e58cd2c4f43b6cf537590c96ce5b97204227690e6e7d5816cd283026cd8e\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  withdrawal_lock: {\n    script_type_hash: \"0xa410542a29f3bbd3ee0a176f0283b5db3fb6c86d3aef406f4d4917ff9609d832\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xa4e05a31cbc153c4a667183e5dee23fa542e4fc19d63a8c70f6327fad3d1de28\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  tron_account_lock: {\n    script_type_hash: \"0x22268916b3aab4db9abd206eac646ad14fb2b5611dc5af4ba8fa883a109c7dcd\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x686ad028595d906cbeac1cbe93ca86d8c73c54902b9ce201aef579ffa3f9c435\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n};\n\nexport const ROLLUP_CONFIG = {\n  rollup_type_hash: \"0xac6737b05b357756fd7c17bb583672967a186515d9815af0f3b221943c13d167\",\n  rollup_type_script: {\n    code_hash: \"0x5826d84d9345d6688602762773662aec64d765b4cbc01284b4de1aa361dfc300\",\n    hash_type: \"type\",\n    args: \"0x53d7905bfe0aeb1aba147cb12d3b45c6974ade43e1f21fa350c5498624fac362\",\n  },\n  genesis: {\n    timestamp: 1647264360462,\n    meta_contract_validator_type_hash: \"0xafaa3646deaa86d1a4734b9a9a778468ad5c4fb5fc22873310bd8a41ae7b5421\",\n    rollup_type_hash: \"0xac6737b05b357756fd7c17bb583672967a186515d9815af0f3b221943c13d167\",\n    rollup_config: {\n      l1_sudt_script_type_hash: \"0x080f242d92ab7c7c5cda8f17a6eeb8592206429e451fbb66bae16231a4845e67\",\n      custodian_script_type_hash: \"0x5f86d23b30daec1fcbcde129eceda31f6f813b2b517804cf4aed08b442e7d606\",\n      deposit_script_type_hash: \"0x33ac8fb80e43697a8b886883cc650136fa6e8e9c261eb335b6fc1f8d54b74870\",\n      withdrawal_script_type_hash: \"0xa410542a29f3bbd3ee0a176f0283b5db3fb6c86d3aef406f4d4917ff9609d832\",\n      challenge_script_type_hash: \"0x839585217150517810da3f55930fc9ead100e007d1bb393ed9bb872b54ed4080\",\n      stake_script_type_hash: \"0xef984822bac9ddaa865c1bca61beda671ec3b86dc83fe8f909954da730e82901\",\n      l2_sudt_validator_script_type_hash: \"0x76479d9e2773fe0bae011345d085b59b6e7c4d80f392799a7d7041305ec61c73\",\n      burn_lock_hash: \"0x77c93b0632b5b6c3ef922c5b7cea208fb0a7c427a13d50e13d3fefad17e0c590\",\n      required_staking_capacity: \"0x2540be400\",\n      challenge_maturity_blocks: \"0x64\",\n      finality_blocks: \"0x64\",\n      reward_burn_rate: \"0x32\",\n      allowed_eoa_type_hashes: [\n        \"0xed470b3ce58c73a9673cbb28cf34a44d0b85ed1b5bef0eea4b3c475344379b39\",\n        \"0x22268916b3aab4db9abd206eac646ad14fb2b5611dc5af4ba8fa883a109c7dcd\",\n      ],\n      allowed_contract_type_hashes: [\n        \"0xafaa3646deaa86d1a4734b9a9a778468ad5c4fb5fc22873310bd8a41ae7b5421\",\n        \"0x76479d9e2773fe0bae011345d085b59b6e7c4d80f392799a7d7041305ec61c73\",\n        \"0x10a3fb3e485491c71c097b971078600ef5f7ef492c2c5bf9411dfe7538211f74\",\n      ],\n    },\n    secp_data_dep: {\n      dep_type: \"code\",\n      out_point: {\n        tx_hash: \"0x6dd0b20f37a03939f40f26a6a41a9ad3baa9abdc37086e74879c52dd35c8664c\",\n        index: \"0x3\",\n      },\n    },\n  },\n  rpc_client: {\n    indexer_url: \"http://indexer:8116\",\n    ckb_url: \"http://ckb:8114\",\n  },\n};\n","import * as LocalLayer2Config from \"./localLayer2Config\";\nconst SCRIPTS_V0 = {\n  deposit_lock: {\n    script_type_hash: \"0x5a2506bb68d81a11dcadad4cb7eae62a17c43c619fe47ac8037bc8ce2dd90360\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x97614145cdec9ba924001c11cd49f1c424927437b40ed3ca3b82fff358f2e3de\",\n        index: \"0x0\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  withdrawal_lock: {\n    script_type_hash: \"0x170ef156e9f6132dbca6069dfd3e436f7d91c29d3ac7332c4b33e633b6a299b5\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xb4b07dcd1571ac18683b515ada40e13b99bd0622197b6817047adc9f407f4828\",\n        index: \"0x0\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  eth_account_lock: {\n    script_type_hash: \"0xdeec13a7b8e100579541384ccaf4b5223733e4a5483c3aec95ddc4c1d5ea5b22\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x2f9f8ec8a1556238aeeefed29e990d53ea75060ef04249371fd8b5246fffb8ea\",\n        index: \"0x0\",\n      },\n      dep_type: \"code\",\n    },\n  },\n};\nconst ROLLUP_CONFIG_V0 = {\n  rollup_type_hash: \"0x4cc2e6526204ae6a2e8fcf12f7ad472f41a1606d5b9624beebd215d780809f6a\",\n  rollup_type_script: {\n    code_hash: \"0x5c365147bb6c40e817a2a53e0dec3661f7390cc77f0c02db138303177b12e9fb\",\n    hash_type: \"type\",\n    args: \"0x213743d13048e9f36728c547ab736023a7426e15a3d7d1c82f43ec3b5f266df2\",\n  },\n};\nconst SCRIPTS_V1 = {\n  deposit_lock: {\n    script_type_hash: \"0xcc2b4e14d7dfeb1e72f7708ac2d7f636ae222b003bac6bccfcf8f4dfebd9c714\",\n  },\n  withdrawal_lock: {\n    script_type_hash: \"0x318e8882bec0339fa20584f4791152e71d5b71c5dbd8bf988fd511373e142222\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xb4b07dcd1571ac18683b515ada40e13b99bd0622197b6817047adc9f407f4828\",\n        index: \"0x0\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  eth_account_lock: {\n    script_type_hash: \"0x10571f91073fdc3cdef4ddad96b4204dd30d6355f3dda9a6d7fc0fa0326408da\",\n  },\n  omni_lock: {\n    code_hash: \"0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e\",\n    hash_type: \"type\",\n    tx_hash: \"0x9154df4f7336402114d04495175b37390ce86a4906d2d4001cf02c3e6d97f39c\",\n    index: \"0x0\",\n    dep_type: \"code\",\n  },\n  secp256k1_blake160: {\n    code_hash: \"0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8\",\n    hash_type: \"type\",\n    tx_hash: \"0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37\",\n    index: \"0x0\",\n    dep_type: \"dep_group\",\n    short_id: 0,\n  },\n  sudt: {\n    code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n    hash_type: \"type\",\n    tx_hash: \"0xe12877ebd2c3c364dc46c5c992bcfaf4fee33fa13eebdf82c591fc9825aab769\",\n    index: \"0x0\",\n    dep_type: \"code\",\n  },\n};\nconst ROLLUP_CONFIG_V1 = {\n  rollup_type_hash: \"0x4940246f168f4106429dc641add3381a44b5eef61e7754142f594e986671a575\",\n  rollup_type_script: {\n    code_hash: \"0x0d3bfeaa292a59fcb58ed026e8f14e2167bd27f1765aa4b2af7d842b6123c6a9\",\n    hash_type: \"type\",\n    args: \"0x8137c84a9089f92fee684ac840532ee1133b012a9d42b6b76b74fbdde6999230\",\n  },\n};\n\nexport type Layer2Config = {\n  SCRIPTS: {\n    deposit_lock: {\n      script_type_hash: string;\n    };\n    withdrawal_lock: {\n      script_type_hash: string;\n      cell_dep: {\n        out_point: {\n          tx_hash: string;\n          index: string;\n        };\n        dep_type: string;\n      };\n    };\n    eth_account_lock: {\n      script_type_hash: string;\n    };\n  };\n  ROLLUP_CONFIG: {\n    rollup_type_hash: string;\n    rollup_type_script: {\n      code_hash: string;\n      hash_type: string;\n      args: string;\n    };\n  };\n};\n\nexport type Layer2Env = \"local\" | \"testnet_v1\" | \"testnet_v0\" | \"mainnet\";\n\nexport const getLayer2Config = (env: Layer2Env = \"testnet_v1\"): Layer2Config => {\n  console.log(`getLayer2Config env: ${env}`);\n\n  if (env === \"testnet_v0\") {\n    return {\n      SCRIPTS: SCRIPTS_V0,\n      ROLLUP_CONFIG: ROLLUP_CONFIG_V0,\n    };\n  } else if (env === \"testnet_v1\") {\n    return {\n      SCRIPTS: SCRIPTS_V1,\n      ROLLUP_CONFIG: ROLLUP_CONFIG_V1,\n    };\n  } else if (env === \"local\") {\n    return {\n      SCRIPTS: LocalLayer2Config.SCRIPTS,\n      ROLLUP_CONFIG: LocalLayer2Config.ROLLUP_CONFIG,\n    };\n  } else if (env === \"mainnet\") {\n    return {\n      SCRIPTS: SCRIPTS_V1,\n      ROLLUP_CONFIG: ROLLUP_CONFIG_V1,\n    };\n  }\n  throw new Error(\"invalid env\");\n};\n","export const PROVIDER_CONFIG = {\n  LINA: {\n    //TODO: fake urls\n    CKB_INDEXER_URL: \"https://testnet.ckb.dev/indexer\",\n    CKB_RPC_URL: \"https://testnet.ckb.dev\",\n    GW_POLYJUICE_RPC_URL: \"https://godwoken-testnet-web3-rpc.ckbapp.dev\",\n  },\n  AGGRON: {\n    CKB_INDEXER_URL: \"https://testnet.ckb.dev/indexer\",\n    CKB_RPC_URL: \"https://testnet.ckb.dev\",\n    GW_POLYJUICE_RPC_URL: \"https://godwoken-testnet-web3-rpc.ckbapp.dev\",\n  },\n  GODWOKEN_V1: {\n    CKB_INDEXER_URL: \"https://testnet.ckb.dev/indexer\",\n    CKB_RPC_URL: \"https://testnet.ckb.dev\",\n    GW_POLYJUICE_RPC_URL: \"https://godwoken-testnet-web3-v1-rpc.ckbapp.dev\",\n  },\n};\n","import { Hash, HexNumber, HexString, PackedSince, Script } from \"@ckb-lumos/lumos\";\nimport { normalizers, Reader } from \"ckb-js-toolkit\";\n\n// Taken for now from https://github.com/xxuejie/ckb-js-toolkit/blob/68f5ff709f78eb188ee116b2887a362123b016cc/src/normalizers.js#L17-L69,\n// later we can think about exposing those functions directly.\nfunction normalizeHexNumber(length: number) {\n  return function (debugPath: string, value: any) {\n    if (!(value instanceof ArrayBuffer)) {\n      let intValue = BigInt(value).toString(16);\n      if (intValue.length % 2 !== 0) {\n        intValue = \"0\" + intValue;\n      }\n      if (intValue.length / 2 > length) {\n        throw new Error(`${debugPath} is ${intValue.length / 2} bytes long, expected length is ${length}!`);\n      }\n      const view = new DataView(new ArrayBuffer(length));\n      for (let i = 0; i < intValue.length / 2; i++) {\n        const start = intValue.length - (i + 1) * 2;\n        view.setUint8(i, parseInt(intValue.substr(start, 2), 16));\n      }\n      value = view.buffer;\n    }\n    if (value.byteLength < length) {\n      const array = new Uint8Array(length);\n      array.set(new Uint8Array(value), 0);\n      value = array.buffer;\n    }\n    return value;\n  };\n}\n\nfunction normalizeRawData(length: number) {\n  return function (debugPath: string, value: any) {\n    value = new Reader(value).toArrayBuffer();\n    if (length > 0 && value.byteLength !== length) {\n      throw new Error(`${debugPath} has invalid length ${value.byteLength}, required: ${length}`);\n    }\n    return value;\n  };\n}\n\nfunction normalizeObject(debugPath: string, obj: any, keys: object) {\n  const result: any = {};\n\n  for (const [key, f] of Object.entries(keys)) {\n    const value = obj[key];\n    if (value === undefined || value === null) {\n      throw new Error(`${debugPath} is missing ${key}!`);\n    }\n    result[key] = f(`${debugPath}.${key}`, value);\n  }\n  return result;\n}\n\nfunction toNormalize(normalize: Function) {\n  return function (debugPath: string, value: any) {\n    return normalize(value, {\n      debugPath,\n    });\n  };\n}\n\nexport interface DepositLockArgs {\n  owner_lock_hash: Hash;\n  layer2_lock: Script;\n  cancel_timeout: PackedSince;\n}\n\nexport function NormalizeDepositLockArgs(args: object, { debugPath = \"deposit_lock_args\" } = {}) {\n  return normalizeObject(debugPath, args, {\n    owner_lock_hash: normalizeRawData(32),\n    layer2_lock: toNormalize(normalizers.NormalizeScript),\n    cancel_timeout: normalizeHexNumber(8),\n  });\n}\n\n/**\n * sudt_id: uint32\n * amount: uint128\n */\nexport interface Fee {\n  sudt_id: HexNumber;\n  amount: HexNumber;\n}\n\nexport function NormalizeFee(fee: object, { debugPath = \"fee\" } = {}) {\n  return normalizeObject(debugPath, fee, {\n    sudt_id: normalizeHexNumber(4),\n    amount: normalizeHexNumber(16),\n  });\n}\n\nexport interface RawWithdrawalRequest {\n  nonce: HexNumber;\n  // CKB amount\n  capacity: HexNumber;\n  // SUDT amount\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n  // layer2 account_script_hash\n  account_script_hash: Hash;\n  // buyer can pay sell_amount and sell_capacity to unlock\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n  fee: Fee;\n}\nexport interface WithdrawalRequest {\n  raw: RawWithdrawalRequest;\n  signature: HexString;\n}\n\nexport function NormalizeRawWithdrawalRequest(raw_request: object, { debugPath = \"raw_withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, raw_request, {\n    nonce: normalizeHexNumber(4),\n    capacity: normalizeHexNumber(8),\n    amount: normalizeHexNumber(16),\n    sudt_script_hash: normalizeRawData(32),\n    account_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    owner_lock_hash: normalizeRawData(32),\n    payment_lock_hash: normalizeRawData(32),\n    fee: toNormalize(NormalizeFee),\n  });\n}\n\nexport function NormalizeWithdrawalRequest(request: WithdrawalRequest, { debugPath = \"withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, request, {\n    raw: toNormalize(NormalizeRawWithdrawalRequest),\n    signature: normalizeRawData(65),\n  });\n}\n\nexport interface WithdrawalLockArgs {\n  // layer2 account script hash\n  account_script_hash: Hash;\n  withdrawal_block_hash: Hash;\n  withdrawal_block_number: HexNumber;\n  // buyer can pay sell_amount token to unlock\n  sudt_script_hash: Hash;\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n}\n\nexport function NormalizeWithdrawalLockArgs(\n  withdrawal_lock_args: WithdrawalLockArgs,\n  { debugPath = \"withdrawal_lock_args\" } = {},\n) {\n  return normalizeObject(debugPath, withdrawal_lock_args, {\n    account_script_hash: normalizeRawData(32),\n    withdrawal_block_hash: normalizeRawData(32),\n    withdrawal_block_number: normalizeHexNumber(8),\n    sudt_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    owner_lock_hash: normalizeRawData(32),\n    payment_lock_hash: normalizeRawData(32),\n  });\n}\n\nexport function NormalizeUnlockWithdrawalViaFinalize(\n  unlock_withdrawal_finalize: object,\n  { debugPath = \"unlock_withdrawal_finalize\" } = {},\n) {\n  return normalizeObject(debugPath, unlock_withdrawal_finalize, {});\n}\n\nexport interface RawL2Transaction {\n  from_id: HexNumber;\n  to_id: HexNumber;\n  nonce: HexNumber;\n  args: HexString;\n}\n\nexport function NormalizeRawL2Transaction(\n  rawL2Transaction: RawL2Transaction,\n  { debugPath = \"raw_l2_transaction\" } = {},\n) {\n  return normalizeObject(debugPath, rawL2Transaction, {\n    from_id: normalizeHexNumber(4),\n    to_id: normalizeHexNumber(4),\n    nonce: normalizeHexNumber(4),\n    args: normalizeRawData(-1),\n  });\n}\n\nexport interface L2Transaction {\n  raw: RawL2Transaction;\n  signature: HexString;\n}\n\nexport function NormalizeL2Transaction(l2Transaction: L2Transaction, { debugPath = \"l2_transaction\" } = {}) {\n  return normalizeObject(debugPath, l2Transaction, {\n    raw: toNormalize(NormalizeRawL2Transaction),\n    signature: normalizeRawData(-1),\n  });\n}\n","/* eslint-disable */\nfunction dataLengthError(actual, required) {\n  throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n}\n\nfunction assertDataLength(actual, required) {\n  if (actual !== required) {\n    dataLengthError(actual, required);\n  }\n}\n\nfunction assertArrayBuffer(reader) {\n  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n    reader = reader.toArrayBuffer();\n  }\n  if (!(reader instanceof ArrayBuffer)) {\n    throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n  }\n  return reader;\n}\n\nfunction verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n  if (view.byteLength < 4) {\n    dataLengthError(view.byteLength, \">4\");\n  }\n  const requiredByteLength = view.getUint32(0, true);\n  assertDataLength(view.byteLength, requiredByteLength);\n  if (requiredByteLength === 4) {\n    return [requiredByteLength];\n  }\n  if (requiredByteLength < 8) {\n    dataLengthError(view.byteLength, \">8\");\n  }\n  const firstOffset = view.getUint32(4, true);\n  if (firstOffset % 4 !== 0 || firstOffset < 8) {\n    throw new Error(`Invalid first offset: ${firstOffset}`);\n  }\n  const itemCount = firstOffset / 4 - 1;\n  if (itemCount < expectedFieldCount) {\n    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  } else if (!compatible && itemCount > expectedFieldCount) {\n    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  }\n  if (requiredByteLength < firstOffset) {\n    throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n  }\n  const offsets = [];\n  for (let i = 0; i < itemCount; i++) {\n    const start = 4 + i * 4;\n    offsets.push(view.getUint32(start, true));\n  }\n  offsets.push(requiredByteLength);\n  for (let i = 0; i < offsets.length - 1; i++) {\n    if (offsets[i] > offsets[i + 1]) {\n      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n    }\n  }\n  return offsets;\n}\n\nfunction serializeTable(buffers) {\n  const itemCount = buffers.length;\n  let totalSize = 4 * (itemCount + 1);\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    offsets.push(totalSize);\n    totalSize += buffers[i].byteLength;\n  }\n\n  const buffer = new ArrayBuffer(totalSize);\n  const array = new Uint8Array(buffer);\n  const view = new DataView(buffer);\n\n  view.setUint32(0, totalSize, true);\n  for (let i = 0; i < itemCount; i++) {\n    view.setUint32(4 + i * 4, offsets[i], true);\n    array.set(new Uint8Array(buffers[i]), offsets[i]);\n  }\n  return buffer;\n}\n\nexport class Uint32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Uint32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Uint32(this.view.buffer.slice(4 + i * Uint32.size(), 4 + (i + 1) * Uint32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeUint32Vec(value) {\n  const array = new Uint8Array(4 + Uint32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeUint32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Uint32.size());\n  }\n  return array.buffer;\n}\n\nexport class BlockMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class AccountMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, AccountMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeAccountMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class GlobalStateV0 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(\n      this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n      { validate: false },\n    );\n  }\n\n  getBlock() {\n    return new BlockMerkleState(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getStatus() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size(),\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalStateV0.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      1\n    );\n  }\n}\n\nexport function SerializeGlobalStateV0(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      1,\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.reverted_block_root)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.tip_block_hash)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n    value.status,\n  );\n  return array.buffer;\n}\n\nexport class GlobalState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(\n      this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n      { validate: false },\n    );\n  }\n\n  getBlock() {\n    return new BlockMerkleState(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getStatus() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size(),\n    );\n  }\n\n  getVersion() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        1,\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalState.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getTipBlockTimestamp().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1 +\n      1\n    );\n  }\n}\n\nexport function SerializeGlobalState(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1 +\n      1,\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.reverted_block_root)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.tip_block_hash)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.tip_block_timestamp)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size(),\n    value.status,\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1,\n    value.version,\n  );\n  return array.buffer;\n}\n\nexport class RollupConfig {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[10], offsets[11]), { validate: false }).validate();\n    if (offsets[12] - offsets[11] !== 1) {\n      throw new Error(`Invalid offset for reward_burn_rate: ${offsets[11]} - ${offsets[12]}`);\n    }\n    new Byte32Vec(this.view.buffer.slice(offsets[12], offsets[13]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[13], offsets[14]), { validate: false }).validate();\n  }\n\n  getL1SudtScriptTypeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCustodianScriptTypeHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositScriptTypeHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalScriptTypeHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeScriptTypeHash() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeScriptTypeHash() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2SudtValidatorScriptTypeHash() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBurnLockHash() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRequiredStakingCapacity() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeMaturityBlocks() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFinalityBlocks() {\n    const start = 44;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardBurnRate() {\n    const start = 48;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getAllowedEoaTypeHashes() {\n    const start = 52;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAllowedContractTypeHashes() {\n    const start = 56;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupConfig(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.l1_sudt_script_type_hash));\n  buffers.push(SerializeByte32(value.custodian_script_type_hash));\n  buffers.push(SerializeByte32(value.deposit_script_type_hash));\n  buffers.push(SerializeByte32(value.withdrawal_script_type_hash));\n  buffers.push(SerializeByte32(value.challenge_script_type_hash));\n  buffers.push(SerializeByte32(value.stake_script_type_hash));\n  buffers.push(SerializeByte32(value.l2_sudt_validator_script_type_hash));\n  buffers.push(SerializeByte32(value.burn_lock_hash));\n  buffers.push(SerializeUint64(value.required_staking_capacity));\n  buffers.push(SerializeUint64(value.challenge_maturity_blocks));\n  buffers.push(SerializeUint64(value.finality_blocks));\n  const rewardBurnRateView = new DataView(new ArrayBuffer(1));\n  rewardBurnRateView.setUint8(0, value.reward_burn_rate);\n  buffers.push(rewardBurnRateView.buffer);\n  buffers.push(SerializeByte32Vec(value.allowed_eoa_type_hashes));\n  buffers.push(SerializeByte32Vec(value.allowed_contract_type_hashes));\n  return serializeTable(buffers);\n}\n\nexport class RawL2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getFromId() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getToId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNonce() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getArgs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.from_id));\n  buffers.push(SerializeUint32(value.to_id));\n  buffers.push(SerializeUint32(value.nonce));\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class L2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Transaction(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class L2TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new L2Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2TransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeL2Transaction(item)));\n}\n\nexport class SubmitTransactions {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getTxWitnessRoot() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxCount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPrevStateCheckpoint() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSubmitTransactions(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.tx_witness_root));\n  buffers.push(SerializeUint32(value.tx_count));\n  buffers.push(SerializeByte32(value.prev_state_checkpoint));\n  return serializeTable(buffers);\n}\n\nexport class SubmitWithdrawals {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getWithdrawalWitnessRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SubmitWithdrawals.size());\n    this.getWithdrawalWitnessRoot().validate(compatible);\n    this.getWithdrawalCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeSubmitWithdrawals(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_witness_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.withdrawal_count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class RawL2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new SubmitWithdrawals(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new SubmitTransactions(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n  }\n\n  getNumber() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProducerId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getParentBlockHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeCellOwnerLockHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTimestamp() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPrevAccount() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPostAccount() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStateCheckpointList() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitWithdrawals() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new SubmitWithdrawals(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitTransactions() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SubmitTransactions(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.number));\n  buffers.push(SerializeUint32(value.block_producer_id));\n  buffers.push(SerializeByte32(value.parent_block_hash));\n  buffers.push(SerializeByte32(value.stake_cell_owner_lock_hash));\n  buffers.push(SerializeUint64(value.timestamp));\n  buffers.push(SerializeAccountMerkleState(value.prev_account));\n  buffers.push(SerializeAccountMerkleState(value.post_account));\n  buffers.push(SerializeByte32Vec(value.state_checkpoint_list));\n  buffers.push(SerializeSubmitWithdrawals(value.submit_withdrawals));\n  buffers.push(SerializeSubmitTransactions(value.submit_transactions));\n  return serializeTable(buffers);\n}\n\nexport class RawL2BlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new RawL2Block(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2BlockVec(value) {\n  return serializeTable(value.map((item) => SerializeRawL2Block(item)));\n}\n\nexport class L2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new L2TransactionVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new WithdrawalRequestVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawals() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new WithdrawalRequestVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeL2TransactionVec(value.transactions));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeWithdrawalRequestVec(value.withdrawals));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSudtScriptHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScript() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeByte32(value.sudt_script_hash));\n  buffers.push(SerializeScript(value.script));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new DepositRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new DepositRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequestVec(value) {\n  return serializeTable(value.map((item) => SerializeDepositRequest(item)));\n}\n\nexport class RawWithdrawalRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNonce() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getCapacity() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getAmount() {\n    return new Uint128(\n      this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size()),\n      { validate: false },\n    );\n  }\n\n  getSudtScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size(),\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellAmount() {\n    return new Uint128(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellCapacity() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getPaymentLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getFee() {\n    return new Fee(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Fee.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawWithdrawalRequest.size());\n    this.getNonce().validate(compatible);\n    this.getCapacity().validate(compatible);\n    this.getAmount().validate(compatible);\n    this.getSudtScriptHash().validate(compatible);\n    this.getAccountScriptHash().validate(compatible);\n    this.getSellAmount().validate(compatible);\n    this.getSellCapacity().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n    this.getPaymentLockHash().validate(compatible);\n    this.getFee().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Fee.size()\n    );\n  }\n}\n\nexport function SerializeRawWithdrawalRequest(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Fee.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.nonce)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.capacity)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.sudt_script_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.account_script_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint128(value.sell_amount)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.sell_capacity)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.payment_lock_hash)),\n    0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeFee(value.fee)),\n    0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class WithdrawalRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new WithdrawalRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequestVec(value) {\n  return serializeTable(value.map((item) => SerializeWithdrawalRequest(item)));\n}\n\nexport class WithdrawalRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawWithdrawalRequest(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawWithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeRawWithdrawalRequest(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class KVPair {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getK() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getV() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeKVPair(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.k));\n  buffers.push(SerializeByte32(value.v));\n  return serializeTable(buffers);\n}\n\nexport class KVPairVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new KVPair(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new KVPair(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeKVPairVec(value) {\n  return serializeTable(value.map((item) => SerializeKVPair(item)));\n}\n\nexport class BlockInfo {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockProducerId() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockInfo.size());\n    this.getBlockProducerId().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getTimestamp().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint64.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockInfo(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint64.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.block_producer_id)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint64.size());\n  return array.buffer;\n}\n\nexport class DepositLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getOwnerLockHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLayer2Lock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCancelTimeout() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.owner_lock_hash));\n  buffers.push(SerializeScript(value.layer2_lock));\n  buffers.push(SerializeUint64(value.cancel_timeout));\n  return serializeTable(buffers);\n}\n\nexport class CustodianLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new DepositLockArgs(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getDepositLockArgs() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DepositLockArgs(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockNumber() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCustodianLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeDepositLockArgs(value.deposit_lock_args));\n  buffers.push(SerializeByte32(value.deposit_block_hash));\n  buffers.push(SerializeUint64(value.deposit_block_number));\n  return serializeTable(buffers);\n}\n\nexport class UnlockCustodianViaRevertWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getDepositLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockCustodianViaRevertWitness.size());\n    this.getDepositLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockCustodianViaRevertWitness(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.deposit_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class WithdrawalLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalBlockHash() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getWithdrawalBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Byte32.size() + Byte32.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  getSudtScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size(),\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellAmount() {\n    return new Uint128(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellCapacity() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n        0 +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getPaymentLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n        0 +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, WithdrawalLockArgs.size());\n    this.getAccountScriptHash().validate(compatible);\n    this.getWithdrawalBlockHash().validate(compatible);\n    this.getWithdrawalBlockNumber().validate(compatible);\n    this.getSudtScriptHash().validate(compatible);\n    this.getSellAmount().validate(compatible);\n    this.getSellCapacity().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n    this.getPaymentLockHash().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size()\n    );\n  }\n}\n\nexport function SerializeWithdrawalLockArgs(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.account_script_hash)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_block_hash)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeUint64(value.withdrawal_block_number)), 0 + Byte32.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.sudt_script_hash)), 0 + Byte32.size() + Byte32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeUint128(value.sell_amount)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.sell_capacity)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.payment_lock_hash)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class UnlockWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 2:\n        new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"UnlockWithdrawalViaFinalize\";\n      case 1:\n        return \"UnlockWithdrawalViaRevert\";\n      case 2:\n        return \"UnlockWithdrawalViaTrade\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false });\n      case 2:\n        return new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeUnlockWithdrawalWitness(value) {\n  switch (value.type) {\n    case \"UnlockWithdrawalViaFinalize\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaFinalize(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"UnlockWithdrawalViaRevert\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"UnlockWithdrawalViaTrade\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaTrade(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class UnlockWithdrawalViaFinalize {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaFinalize(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class UnlockWithdrawalViaRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getCustodianLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockWithdrawalViaRevert.size());\n    this.getCustodianLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaRevert(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.custodian_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class UnlockWithdrawalViaTrade {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getOwnerLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaTrade(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.owner_lock));\n  return serializeTable(buffers);\n}\n\nexport class StakeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getStakeBlockNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, StakeLockArgs.size());\n    this.getOwnerLockHash().validate(compatible);\n    this.getStakeBlockNumber().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeStakeLockArgs(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.stake_block_number)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class MetaContractArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new CreateAccount(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"CreateAccount\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new CreateAccount(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeMetaContractArgs(value) {\n  switch (value.type) {\n    case \"CreateAccount\": {\n      const itemBuffer = SerializeCreateAccount(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class Fee {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSudtId() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getAmount() {\n    return new Uint128(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint128.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Fee.size());\n    this.getSudtId().validate(compatible);\n    this.getAmount().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint128.size();\n  }\n}\n\nexport function SerializeFee(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.sudt_id)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size());\n  return array.buffer;\n}\n\nexport class CreateAccount {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Fee(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getScript() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Fee(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCreateAccount(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.script));\n  buffers.push(SerializeFee(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class SUDTArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new SUDTQuery(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new SUDTTransfer(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"SUDTQuery\";\n      case 1:\n        return \"SUDTTransfer\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new SUDTQuery(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new SUDTTransfer(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeSUDTArgs(value) {\n  switch (value.type) {\n    case \"SUDTQuery\": {\n      const itemBuffer = SerializeSUDTQuery(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"SUDTTransfer\": {\n      const itemBuffer = SerializeSUDTTransfer(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class SUDTQuery {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getShortAddress() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTQuery(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.short_address));\n  return serializeTable(buffers);\n}\n\nexport class SUDTTransfer {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getTo() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTTransfer(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.to));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeUint128(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeTarget {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getTargetIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTargetType() {\n    return this.view.getUint8(0 + Byte32.size() + Uint32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, ChallengeTarget.size());\n    this.getBlockHash().validate(compatible);\n    this.getTargetIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size() + 1;\n  }\n}\n\nexport function SerializeChallengeTarget(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.block_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.target_index)), 0 + Byte32.size());\n  view.setUint8(0 + Byte32.size() + Uint32.size(), value.target_type);\n  return array.buffer;\n}\n\nexport class ChallengeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeTarget(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getTarget() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ChallengeTarget(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardsReceiverLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeTarget(value.target));\n  buffers.push(SerializeScript(value.rewards_receiver_lock));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeBytes(value.block_proof));\n  return serializeTable(buffers);\n}\n\nexport class ScriptVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScriptVec(value) {\n  return serializeTable(value.map((item) => SerializeScript(item)));\n}\n\nexport class BlockHashEntry {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockHashEntry.size());\n    this.getNumber().validate(compatible);\n    this.getHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + Byte32.size();\n  }\n}\n\nexport function SerializeBlockHashEntry(value) {\n  const array = new Uint8Array(0 + Uint64.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.hash)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class BlockHashEntryVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * BlockHashEntry.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new BlockHashEntry(\n      this.view.buffer.slice(4 + i * BlockHashEntry.size(), 4 + (i + 1) * BlockHashEntry.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBlockHashEntryVec(value) {\n  const array = new Uint8Array(4 + BlockHashEntry.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeBlockHashEntry(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * BlockHashEntry.size());\n  }\n  return array.buffer;\n}\n\nexport class VerifyTransactionContext {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ScriptVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new BlockHashEntryVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getAccountCount() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLoadData() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScripts() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getReturnDataHash() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashes() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BlockHashEntryVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionContext(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytesVec(value.load_data));\n  buffers.push(SerializeScriptVec(value.scripts));\n  buffers.push(SerializeByte32(value.return_data_hash));\n  buffers.push(SerializeBlockHashEntryVec(value.block_hashes));\n  return serializeTable(buffers);\n}\n\nexport class CKBMerkleProof {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32Vec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getIndices() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLemmas() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCKBMerkleProof(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32Vec(value.indices));\n  buffers.push(SerializeByte32Vec(value.lemmas));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new VerifyTransactionContext(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getL2Tx() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRawL2Block() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashesProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getContext() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new VerifyTransactionContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeBytes(value.block_hashes_proof));\n  buffers.push(SerializeVerifyTransactionContext(value.context));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionSignatureContext {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new ScriptVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getAccountCount() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScripts() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionSignatureContext(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeScriptVec(value.scripts));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionSignatureWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new L2Transaction(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new VerifyTransactionSignatureContext(this.view.buffer.slice(offsets[4], offsets[5]), {\n      validate: false,\n    }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2Tx() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getContext() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new VerifyTransactionSignatureContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionSignatureWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeVerifyTransactionSignatureContext(value.context));\n  return serializeTable(buffers);\n}\n\nexport class VerifyWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new WithdrawalRequest(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalRequest() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyWithdrawalWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeWithdrawalRequest(value.withdrawal_request));\n  buffers.push(SerializeCKBMerkleProof(value.withdrawal_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupSubmitBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getBlock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockHashes() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupSubmitBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Block(value.block));\n  buffers.push(SerializeByte32Vec(value.reverted_block_hashes));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupEnterChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeWitness(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getWitness() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ChallengeWitness(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupEnterChallenge(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeWitness(value.witness));\n  return serializeTable(buffers);\n}\n\nexport class RollupCancelChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n}\n\nexport function SerializeRollupCancelChallenge(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class RollupRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2BlockVec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getRevertedBlocks() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2BlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNewTipBlock() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupRevert(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2BlockVec(value.reverted_blocks));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  buffers.push(SerializeRawL2Block(value.new_tip_block));\n  return serializeTable(buffers);\n}\n\nexport class RollupAction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 2:\n        new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 3:\n        new RollupRevert(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"RollupSubmitBlock\";\n      case 1:\n        return \"RollupEnterChallenge\";\n      case 2:\n        return \"RollupCancelChallenge\";\n      case 3:\n        return \"RollupRevert\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false });\n      case 2:\n        return new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false });\n      case 3:\n        return new RollupRevert(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeRollupAction(value) {\n  switch (value.type) {\n    case \"RollupSubmitBlock\": {\n      const itemBuffer = SerializeRollupSubmitBlock(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupEnterChallenge\": {\n      const itemBuffer = SerializeRollupEnterChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupCancelChallenge\": {\n      const itemBuffer = SerializeRollupCancelChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupRevert\": {\n      const itemBuffer = SerializeRollupRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 3, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class Uint16 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 2);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint16() {\n    return this.view.getUint16(0, false);\n  }\n\n  toLittleEndianUint16() {\n    return this.view.getUint16(0, true);\n  }\n\n  static size() {\n    return 2;\n  }\n}\n\nexport function SerializeUint16(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 2);\n  return buffer;\n}\n\nexport class Uint32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint32() {\n    return this.view.getUint32(0, false);\n  }\n\n  toLittleEndianUint32() {\n    return this.view.getUint32(0, true);\n  }\n\n  static size() {\n    return 4;\n  }\n}\n\nexport function SerializeUint32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 4);\n  return buffer;\n}\n\nexport class Uint64 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 8);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianBigUint64() {\n    return this.view.getBigUint64(0, false);\n  }\n\n  toLittleEndianBigUint64() {\n    return this.view.getBigUint64(0, true);\n  }\n\n  static size() {\n    return 8;\n  }\n}\n\nexport function SerializeUint64(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 8);\n  return buffer;\n}\n\nexport class Uint128 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 16);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 16;\n  }\n}\n\nexport function SerializeUint128(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 16);\n  return buffer;\n}\n\nexport class Byte32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeByte32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Uint256 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeUint256(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Bytes {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBytes(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nexport class BytesOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Bytes(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeBytesOpt(value) {\n  if (value) {\n    return SerializeBytes(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class BytesVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBytesVec(value) {\n  return serializeTable(value.map((item) => SerializeBytes(item)));\n}\n\nexport class Byte32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeByte32Vec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n  return array.buffer;\n}\n\nexport class ScriptOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Script(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeScriptOpt(value) {\n  if (value) {\n    return SerializeScript(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class ProposalShortId {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 10);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 10;\n  }\n}\n\nexport function SerializeProposalShortId(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 10);\n  return buffer;\n}\n\nexport class UncleBlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new UncleBlock(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlockVec(value) {\n  return serializeTable(value.map((item) => SerializeUncleBlock(item)));\n}\n\nexport class TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeTransaction(item)));\n}\n\nexport class ProposalShortIdVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new ProposalShortId(\n      this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeProposalShortIdVec(value) {\n  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeProposalShortId(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n  }\n  return array.buffer;\n}\n\nexport class CellDepVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellDep.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellDepVec(value) {\n  const array = new Uint8Array(4 + CellDep.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellDep(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n  }\n  return array.buffer;\n}\n\nexport class CellInputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellInput.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellInputVec(value) {\n  const array = new Uint8Array(4 + CellInput.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellInput(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n  }\n  return array.buffer;\n}\n\nexport class CellOutputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new CellOutput(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutputVec(value) {\n  return serializeTable(value.map((item) => SerializeCellOutput(item)));\n}\n\nexport class Script {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    if (offsets[2] - offsets[1] !== 1) {\n      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);\n    }\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCodeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHashType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getArgs() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScript(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.code_hash));\n  const hashTypeView = new DataView(new ArrayBuffer(1));\n  hashTypeView.setUint8(0, value.hash_type);\n  buffers.push(hashTypeView.buffer);\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class OutPoint {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, OutPoint.size());\n    this.getTxHash().validate(compatible);\n    this.getIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeOutPoint(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class CellInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSince() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getPreviousOutput() {\n    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellInput.size());\n    this.getSince().validate(compatible);\n    this.getPreviousOutput().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + OutPoint.size();\n  }\n}\n\nexport function SerializeCellInput(value) {\n  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class CellOutput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutput(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeScriptOpt(value.type_));\n  return serializeTable(buffers);\n}\n\nexport class CellDep {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOutPoint() {\n    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), { validate: false });\n  }\n\n  getDepType() {\n    return this.view.getUint8(0 + OutPoint.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellDep.size());\n    this.getOutPoint().validate(compatible);\n  }\n  static size() {\n    return 0 + OutPoint.size() + 1;\n  }\n}\n\nexport function SerializeCellDep(value) {\n  const array = new Uint8Array(0 + OutPoint.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n  view.setUint8(0 + OutPoint.size(), value.dep_type);\n  return array.buffer;\n}\n\nexport class RawTransaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getVersion() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCellDeps() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellDepVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHeaderDeps() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellInputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputs() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputsData() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.version));\n  buffers.push(SerializeCellDepVec(value.cell_deps));\n  buffers.push(SerializeByte32Vec(value.header_deps));\n  buffers.push(SerializeCellInputVec(value.inputs));\n  buffers.push(SerializeCellOutputVec(value.outputs));\n  buffers.push(SerializeBytesVec(value.outputs_data));\n  return serializeTable(buffers);\n}\n\nexport class Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawTransaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWitnesses() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawTransaction(value.raw));\n  buffers.push(SerializeBytesVec(value.witnesses));\n  return serializeTable(buffers);\n}\n\nexport class RawHeader {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getVersion() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getCompactTarget() {\n    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  getNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getEpoch() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getParentHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTransactionsRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getProposalsHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getExtraHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getDao() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawHeader.size());\n    this.getVersion().validate(compatible);\n    this.getCompactTarget().validate(compatible);\n    this.getTimestamp().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getEpoch().validate(compatible);\n    this.getParentHash().validate(compatible);\n    this.getTransactionsRoot().validate(compatible);\n    this.getProposalsHash().validate(compatible);\n    this.getExtraHash().validate(compatible);\n    this.getDao().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size()\n    );\n  }\n}\n\nexport function SerializeRawHeader(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeUint64(value.epoch)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.parent_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.transactions_root)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.proposals_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.extra_hash)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.dao)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class Header {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRaw() {\n    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), { validate: false });\n  }\n\n  getNonce() {\n    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Header.size());\n    this.getRaw().validate(compatible);\n    this.getNonce().validate(compatible);\n  }\n  static size() {\n    return 0 + RawHeader.size() + Uint128.size();\n  }\n}\n\nexport function SerializeHeader(value) {\n  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n  return array.buffer;\n}\n\nexport class UncleBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class BlockV1 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getExtension() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlockV1(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  buffers.push(SerializeBytes(value.extension));\n  return serializeTable(buffers);\n}\n\nexport class CellbaseWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getMessage() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellbaseWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeBytes(value.message));\n  return serializeTable(buffers);\n}\n\nexport class WitnessArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWitnessArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.lock));\n  buffers.push(SerializeBytesOpt(value.input_type));\n  buffers.push(SerializeBytesOpt(value.output_type));\n  return serializeTable(buffers);\n}\n","import { RPC, Reader } from \"ckb-js-toolkit\";\nimport { Hash, HexNumber, HexString } from \"@ckb-lumos/lumos\";\nimport { NormalizeWithdrawalRequest, WithdrawalRequest } from \"./normalizer\";\nimport { SerializeWithdrawalRequest } from \"../schemas/index.esm\";\n\ninterface LastL2BlockCommittedInfo {\n  transaction_hash: Hash;\n}\n/**\n * Godwoken RPC client\n */\nexport class GodwokenClient {\n  private rpc: RPC;\n\n  constructor(url: string) {\n    this.rpc = new RPC(url);\n  }\n\n  private async rpcCall(method_name: string, ...args: any[]): Promise<any> {\n    const name = \"gw_\" + method_name;\n    const result = await this.rpc[name](...args);\n    return result;\n  }\n\n  /**\n   * Serialize withdrawal request and submit to godwoken\n   *\n   * @param request\n   * @returns\n   */\n  async submitWithdrawalRequest(request: WithdrawalRequest): Promise<void> {\n    const data = new Reader(SerializeWithdrawalRequest(NormalizeWithdrawalRequest(request))).serializeJson();\n    return await this.rpcCall(\"submit_withdrawal_request\", data);\n  }\n\n  /**\n   *\n   * @param scriptHash layer2 lock script hash\n   * @returns uint32\n   */\n  async getAccountIdByScriptHash(scriptHash: Hash): Promise<HexNumber | undefined> {\n    const id = await this.rpcCall(\"get_account_id_by_script_hash\", scriptHash);\n    return id;\n  }\n\n  /**\n   *\n   * @param shortAddress scriptHash160 (scriptHash first 20 bytes)\n   * @returns uint32\n   */\n  async getScriptHashByShortAddress(shortAddress: HexString): Promise<Hash | undefined> {\n    const scriptHash = await this.rpcCall(\"get_script_hash_by_short_address\", shortAddress);\n    return scriptHash;\n  }\n  /**\n   *\n   * @param txHash Hash\n   * @returns uint32\n   */\n  async getWithdrawal(txHash: Hash): Promise<Hash | undefined> {\n    const withdrawal = await this.rpcCall(\"get_withdrawal\", txHash);\n    return withdrawal;\n  }\n  /**\n   *\n   * @param accountId uint32 in hex number\n   * @returns uint32 in hex number\n   */\n  async getNonce(accountId: HexNumber): Promise<HexNumber> {\n    const nonce = await this.rpcCall(\"get_nonce\", accountId);\n    return nonce;\n  }\n\n  async getLastSubmittedInfo(): Promise<LastL2BlockCommittedInfo> {\n    return await this.rpcCall(\"get_last_submitted_info\");\n  }\n  /**\n   *\n   * @param accountId uint32 in hex number\n   * @returns\n   */\n  async getScriptHash(accountId: HexNumber): Promise<Hash> {\n    return await this.rpcCall(\"get_script_hash\", accountId);\n  }\n}\n","/* eslint-disable */\n// Object.defineProperty(\n//   value: true\n// });\n\nfunction dataLengthError(actual, required) {\n  throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n}\n\nfunction assertDataLength(actual, required) {\n  if (actual !== required) {\n    dataLengthError(actual, required);\n  }\n}\n\nfunction assertArrayBuffer(reader) {\n  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n    reader = reader.toArrayBuffer();\n  }\n\n  if (!(reader instanceof ArrayBuffer)) {\n    throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n  }\n\n  return reader;\n}\n\nfunction verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n  if (view.byteLength < 4) {\n    dataLengthError(view.byteLength, \">4\");\n  }\n\n  const requiredByteLength = view.getUint32(0, true);\n  assertDataLength(view.byteLength, requiredByteLength);\n\n  if (requiredByteLength === 4) {\n    return [requiredByteLength];\n  }\n\n  if (requiredByteLength < 8) {\n    dataLengthError(view.byteLength, \">8\");\n  }\n\n  const firstOffset = view.getUint32(4, true);\n\n  if (firstOffset % 4 !== 0 || firstOffset < 8) {\n    throw new Error(`Invalid first offset: ${firstOffset}`);\n  }\n\n  const itemCount = firstOffset / 4 - 1;\n\n  if (itemCount < expectedFieldCount) {\n    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  } else if (!compatible && itemCount > expectedFieldCount) {\n    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  }\n\n  if (requiredByteLength < firstOffset) {\n    throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n  }\n\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    const start = 4 + i * 4;\n    offsets.push(view.getUint32(start, true));\n  }\n\n  offsets.push(requiredByteLength);\n\n  for (let i = 0; i < offsets.length - 1; i++) {\n    if (offsets[i] > offsets[i + 1]) {\n      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n    }\n  }\n\n  return offsets;\n}\n\nfunction serializeTable(buffers) {\n  const itemCount = buffers.length;\n  let totalSize = 4 * (itemCount + 1);\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    offsets.push(totalSize);\n    totalSize += buffers[i].byteLength;\n  }\n\n  const buffer = new ArrayBuffer(totalSize);\n  const array = new Uint8Array(buffer);\n  const view = new DataView(buffer);\n  view.setUint32(0, totalSize, true);\n\n  for (let i = 0; i < itemCount; i++) {\n    view.setUint32(4 + i * 4, offsets[i], true);\n    array.set(new Uint8Array(buffers[i]), offsets[i]);\n  }\n\n  return buffer;\n}\n\nclass Identity {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 21);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 21;\n  }\n}\n\nfunction SerializeIdentity(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 21);\n  return buffer;\n}\n\nclass RcIdentity {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Identity(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new SmtProofEntryVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getIdentity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Identity(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProofs() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProofEntryVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeRcIdentity(value) {\n  const buffers = [];\n  buffers.push(SerializeIdentity(value.identity));\n  buffers.push(SerializeSmtProofEntryVec(value.proofs));\n  return serializeTable(buffers);\n}\n\nclass RcIdentityOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new RcIdentity(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeRcIdentityOpt(value) {\n  if (value) {\n    return SerializeRcIdentity(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass RcLockWitnessLock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new RcIdentityOpt(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getSignature() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getRcIdentity() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RcIdentityOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getPreimage() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nexport function SerializeRcLockWitnessLock(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.signature));\n  buffers.push(SerializeRcIdentityOpt(value.rc_identity));\n  buffers.push(SerializeBytesOpt(value.preimage));\n  return serializeTable(buffers);\n}\n\nclass ScriptVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeScriptVec(value) {\n  return serializeTable(value.map((item) => SerializeScript(item)));\n}\n\nclass ScriptVecOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new ScriptVec(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeScriptVecOpt(value) {\n  if (value) {\n    return SerializeScriptVec(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass XudtWitnessInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ScriptVecOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getRawExtensionData() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ScriptVecOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getExtensionData() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeXudtWitnessInput(value) {\n  const buffers = [];\n  buffers.push(SerializeScriptVecOpt(value.raw_extension_data));\n  buffers.push(SerializeBytesVec(value.extension_data));\n  return serializeTable(buffers);\n}\n\nclass RCRule {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSmtRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getFlags() {\n    return this.view.getUint8(0 + Byte32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RCRule.size());\n    this.getSmtRoot().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + 1;\n  }\n}\n\nfunction SerializeRCRule(value) {\n  const array = new Uint8Array(0 + Byte32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.smt_root)), 0);\n  view.setUint8(0 + Byte32.size(), value.flags);\n  return array.buffer;\n}\n\nclass RCCellVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeRCCellVec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n\n  return array.buffer;\n}\n\nclass RCData {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        new RCRule(this.view.buffer.slice(4), {\n          validate: false,\n        }).validate();\n        break;\n\n      case 1:\n        new RCCellVec(this.view.buffer.slice(4), {\n          validate: false,\n        }).validate();\n        break;\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        return \"RCRule\";\n\n      case 1:\n        return \"RCCellVec\";\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        return new RCRule(this.view.buffer.slice(4), {\n          validate: false,\n        });\n\n      case 1:\n        return new RCCellVec(this.view.buffer.slice(4), {\n          validate: false,\n        });\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nfunction SerializeRCData(value) {\n  switch (value.type) {\n    case \"RCRule\": {\n      const itemBuffer = SerializeRCRule(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n\n    case \"RCCellVec\": {\n      const itemBuffer = SerializeRCCellVec(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nclass SmtProof {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeSmtProof(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nclass SmtProofEntry {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    if (offsets[1] - offsets[0] !== 1) {\n      throw new Error(`Invalid offset for mask: ${offsets[0]} - ${offsets[1]}`);\n    }\n\n    new SmtProof(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getMask() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProof(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeSmtProofEntry(value) {\n  const buffers = [];\n  const maskView = new DataView(new ArrayBuffer(1));\n  maskView.setUint8(0, value.mask);\n  buffers.push(maskView.buffer);\n  buffers.push(SerializeSmtProof(value.proof));\n  return serializeTable(buffers);\n}\n\nclass SmtProofEntryVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new SmtProofEntry(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new SmtProofEntry(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeSmtProofEntryVec(value) {\n  return serializeTable(value.map((item) => SerializeSmtProofEntry(item)));\n}\n\nclass SmtUpdateItem {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getKey() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getPackedValues() {\n    return this.view.getUint8(0 + Byte32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SmtUpdateItem.size());\n    this.getKey().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + 1;\n  }\n}\n\nfunction SerializeSmtUpdateItem(value) {\n  const array = new Uint8Array(0 + Byte32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.key)), 0);\n  view.setUint8(0 + Byte32.size(), value.packed_values);\n  return array.buffer;\n}\n\nclass SmtUpdateItemVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * SmtUpdateItem.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new SmtUpdateItem(this.view.buffer.slice(4 + i * SmtUpdateItem.size(), 4 + (i + 1) * SmtUpdateItem.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeSmtUpdateItemVec(value) {\n  const array = new Uint8Array(4 + SmtUpdateItem.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeSmtUpdateItem(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * SmtUpdateItem.size());\n  }\n\n  return array.buffer;\n}\n\nclass SmtUpdateAction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new SmtUpdateItemVec(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new SmtProof(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getUpdates() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new SmtUpdateItemVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProof(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeSmtUpdateAction(value) {\n  const buffers = [];\n  buffers.push(SerializeSmtUpdateItemVec(value.updates));\n  buffers.push(SerializeSmtProof(value.proof));\n  return serializeTable(buffers);\n}\n\nclass XudtData {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getData() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeXudtData(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.lock));\n  buffers.push(SerializeBytesVec(value.data));\n  return serializeTable(buffers);\n}\n\nclass Uint32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint32() {\n    return this.view.getUint32(0, false);\n  }\n\n  toLittleEndianUint32() {\n    return this.view.getUint32(0, true);\n  }\n\n  static size() {\n    return 4;\n  }\n}\n\nfunction SerializeUint32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 4);\n  return buffer;\n}\n\nclass Uint64 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 8);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 8;\n  }\n}\n\nfunction SerializeUint64(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 8);\n  return buffer;\n}\n\nclass Uint128 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 16);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 16;\n  }\n}\n\nfunction SerializeUint128(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 16);\n  return buffer;\n}\n\nclass Byte32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nfunction SerializeByte32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nclass Uint256 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nfunction SerializeUint256(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nclass Bytes {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeBytes(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nclass BytesOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Bytes(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeBytesOpt(value) {\n  if (value) {\n    return SerializeBytes(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass BytesVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeBytesVec(value) {\n  return serializeTable(value.map((item) => SerializeBytes(item)));\n}\n\nclass Byte32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeByte32Vec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n\n  return array.buffer;\n}\n\nclass ScriptOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Script(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeScriptOpt(value) {\n  if (value) {\n    return SerializeScript(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass ProposalShortId {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 10);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 10;\n  }\n}\n\nfunction SerializeProposalShortId(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 10);\n  return buffer;\n}\n\nclass UncleBlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new UncleBlock(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeUncleBlockVec(value) {\n  return serializeTable(value.map((item) => SerializeUncleBlock(item)));\n}\n\nclass TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Transaction(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeTransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeTransaction(item)));\n}\n\nclass ProposalShortIdVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new ProposalShortId(\n      this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeProposalShortIdVec(value) {\n  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeProposalShortId(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellDepVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * CellDep.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeCellDepVec(value) {\n  const array = new Uint8Array(4 + CellDep.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellDep(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellInputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * CellInput.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeCellInputVec(value) {\n  const array = new Uint8Array(4 + CellInput.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellInput(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellOutputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new CellOutput(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeCellOutputVec(value) {\n  return serializeTable(value.map((item) => SerializeCellOutput(item)));\n}\n\nclass Script {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n\n    if (offsets[2] - offsets[1] !== 1) {\n      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);\n    }\n\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getCodeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getHashType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getArgs() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeScript(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.code_hash));\n  const hashTypeView = new DataView(new ArrayBuffer(1));\n  hashTypeView.setUint8(0, value.hash_type);\n  buffers.push(hashTypeView.buffer);\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nclass OutPoint {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, OutPoint.size());\n    this.getTxHash().validate(compatible);\n    this.getIndex().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nfunction SerializeOutPoint(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nclass CellInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSince() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getPreviousOutput() {\n    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellInput.size());\n    this.getSince().validate(compatible);\n    this.getPreviousOutput().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Uint64.size() + OutPoint.size();\n  }\n}\n\nfunction SerializeCellInput(value) {\n  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nclass CellOutput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeCellOutput(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeScriptOpt(value.type_));\n  return serializeTable(buffers);\n}\n\nclass CellDep {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOutPoint() {\n    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), {\n      validate: false,\n    });\n  }\n\n  getDepType() {\n    return this.view.getUint8(0 + OutPoint.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellDep.size());\n    this.getOutPoint().validate(compatible);\n  }\n\n  static size() {\n    return 0 + OutPoint.size() + 1;\n  }\n}\n\nfunction SerializeCellDep(value) {\n  const array = new Uint8Array(0 + OutPoint.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n  view.setUint8(0 + OutPoint.size(), value.dep_type);\n  return array.buffer;\n}\n\nclass RawTransaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), {\n      validate: false,\n    }).validate();\n    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), {\n      validate: false,\n    }).validate();\n  }\n\n  getVersion() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getCellDeps() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellDepVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getHeaderDeps() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getInputs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellInputVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getOutputs() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getOutputsData() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeRawTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.version));\n  buffers.push(SerializeCellDepVec(value.cell_deps));\n  buffers.push(SerializeByte32Vec(value.header_deps));\n  buffers.push(SerializeCellInputVec(value.inputs));\n  buffers.push(SerializeCellOutputVec(value.outputs));\n  buffers.push(SerializeBytesVec(value.outputs_data));\n  return serializeTable(buffers);\n}\n\nclass Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawTransaction(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getWitnesses() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawTransaction(value.raw));\n  buffers.push(SerializeBytesVec(value.witnesses));\n  return serializeTable(buffers);\n}\n\nclass RawHeader {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getVersion() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getCompactTarget() {\n    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getEpoch() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getParentHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getTransactionsRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getProposalsHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getUnclesHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getDao() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawHeader.size());\n    this.getVersion().validate(compatible);\n    this.getCompactTarget().validate(compatible);\n    this.getTimestamp().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getEpoch().validate(compatible);\n    this.getParentHash().validate(compatible);\n    this.getTransactionsRoot().validate(compatible);\n    this.getProposalsHash().validate(compatible);\n    this.getUnclesHash().validate(compatible);\n    this.getDao().validate(compatible);\n  }\n\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size()\n    );\n  }\n}\n\nfunction SerializeRawHeader(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeUint64(value.epoch)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.parent_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.transactions_root)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.proposals_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.uncles_hash)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.dao)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  return array.buffer;\n}\n\nclass Header {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRaw() {\n    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), {\n      validate: false,\n    });\n  }\n\n  getNonce() {\n    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Header.size());\n    this.getRaw().validate(compatible);\n    this.getNonce().validate(compatible);\n  }\n\n  static size() {\n    return 0 + RawHeader.size() + Uint128.size();\n  }\n}\n\nfunction SerializeHeader(value) {\n  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n  return array.buffer;\n}\n\nclass UncleBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProposals() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeUncleBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nclass Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), {\n      validate: false,\n    }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nclass CellbaseWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getMessage() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeCellbaseWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeBytes(value.message));\n  return serializeTable(buffers);\n}\n\nclass WitnessArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getInputType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getOutputType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeWitnessArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.lock));\n  buffers.push(SerializeBytesOpt(value.input_type));\n  buffers.push(SerializeBytesOpt(value.output_type));\n  return serializeTable(buffers);\n}\n","import { CellDep, DepType } from \"@ckb-lumos/lumos\";\n\nexport const LAYER1_CONFIG = {\n  omni_lock: {\n    code_hash: \"0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e\",\n    hash_type: \"type\",\n    tx_hash: \"0x9154df4f7336402114d04495175b37390ce86a4906d2d4001cf02c3e6d97f39c\",\n    index: \"0x0\",\n    dep_type: \"code\",\n  },\n  secp256k1_blake160: {\n    code_hash: \"0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8\",\n    hash_type: \"type\",\n    tx_hash: \"0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37\",\n    index: \"0x0\",\n    dep_type: \"dep_group\",\n    short_id: 0,\n  },\n  sudt: {\n    code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n    hash_type: \"type\",\n    tx_hash: \"0xe12877ebd2c3c364dc46c5c992bcfaf4fee33fa13eebdf82c591fc9825aab769\",\n    index: \"0x0\",\n    dep_type: \"code\",\n  },\n};\n\nexport const OMNI_LOCK_CELL_DEP: CellDep = {\n  out_point: {\n    tx_hash: LAYER1_CONFIG.omni_lock.tx_hash,\n    index: LAYER1_CONFIG.omni_lock.index,\n  },\n  dep_type: LAYER1_CONFIG.omni_lock.dep_type as DepType,\n};\n\nexport const SECP256K1_BLACK160_CELL_DEP: CellDep = {\n  out_point: {\n    tx_hash: LAYER1_CONFIG.secp256k1_blake160.tx_hash,\n    index: LAYER1_CONFIG.secp256k1_blake160.index,\n  },\n  dep_type: LAYER1_CONFIG.secp256k1_blake160.dep_type as DepType,\n};\n\nexport const SUDT_CELL_DEP: CellDep = {\n  out_point: {\n    tx_hash: LAYER1_CONFIG.sudt.tx_hash,\n    index: LAYER1_CONFIG.sudt.index,\n  },\n  dep_type: LAYER1_CONFIG.sudt.dep_type as DepType,\n};\n","import { getLayer2Config } from \"./constants/index\";\nimport {\n  Address,\n  Indexer,\n  RPC,\n  config,\n  helpers,\n  Transaction,\n  HexString,\n  utils,\n  core,\n  toolkit,\n  Hash,\n  Cell,\n  HashType,\n  Script,\n  CellDep,\n} from \"@ckb-lumos/lumos\";\nimport { core as godwokenCore } from \"@polyjuice-provider/godwoken\";\nimport { PROVIDER_CONFIG } from \"./constants/providerConfig\";\nimport { PolyjuiceHttpProvider } from \"@polyjuice-provider/web3\";\nimport { SUDT_ERC20_PROXY_ABI } from \"./constants/sudtErc20ProxyAbi\";\nimport { AbiItems, PolyjuiceConfig } from \"@polyjuice-provider/base\";\nimport { GodwokenClient } from \"./godwoken/godwoken\";\nimport Web3 from \"web3\";\nimport { LightGodwokenProvider, LightGodwokenProviderConfig } from \"./lightGodwokenType\";\nimport { WithdrawalRequest } from \"./godwoken/normalizer\";\nimport { SerializeRcLockWitnessLock } from \"./omni-lock/index\";\nimport { TransactionWithStatus } from \"@ckb-lumos/base\";\nimport { LAYER1_CONFIG } from \"./constants/layer1ConfigUtils\";\n\nconst { SCRIPTS, ROLLUP_CONFIG } = getLayer2Config();\n\nexport const POLYJUICE_CONFIG = {\n  web3Url: PROVIDER_CONFIG.GODWOKEN_V1.GW_POLYJUICE_RPC_URL,\n  abiItems: SUDT_ERC20_PROXY_ABI as AbiItems,\n};\n\nexport const polyjuiceProvider = new PolyjuiceHttpProvider(\n  POLYJUICE_CONFIG.web3Url,\n  POLYJUICE_CONFIG as PolyjuiceConfig,\n);\n\nexport default class DefaultLightGodwokenProvider implements LightGodwokenProvider {\n  l2Address: Address = \"\";\n  l1Address: Address = \"\";\n  ckbIndexer;\n  rpc;\n  ethereum;\n  web3;\n  godwokenClient;\n  config;\n\n  constructor(ethAddress: Address, ethereum: any, env: LightGodwokenProviderConfig) {\n    let configObj = PROVIDER_CONFIG.GODWOKEN_V1;\n    if (env === \"v0\") {\n      config.initializeConfig(config.predefined.AGGRON4);\n      configObj = PROVIDER_CONFIG.AGGRON;\n    } else if (env === \"v1\") {\n      config.initializeConfig(config.predefined.AGGRON4);\n      configObj = PROVIDER_CONFIG.GODWOKEN_V1;\n    } else if (env === \"mainnet\") {\n      config.initializeConfig(config.predefined.LINA);\n      configObj = PROVIDER_CONFIG.LINA;\n    } else {\n      throw new Error(\"env not defined, please use AGGRON or LINA.\");\n    }\n    console.log(\"configObj\", configObj);\n\n    this.config = configObj;\n    this.ckbIndexer = new Indexer(configObj.CKB_INDEXER_URL, configObj.CKB_RPC_URL);\n    this.rpc = new RPC(configObj.CKB_RPC_URL);\n    this.godwokenClient = new GodwokenClient(configObj.GW_POLYJUICE_RPC_URL);\n\n    this.ethereum = ethereum;\n    this.l2Address = ethAddress;\n    this.l1Address = this.generateL1Address(this.l2Address);\n    ethereum.on(\"accountsChanged\", (accounts: any) => {\n      console.log(\"eth accounts changed\", accounts);\n      this.l2Address = accounts[0];\n      this.l1Address = this.generateL1Address(this.l2Address);\n    });\n\n    this.web3 = new Web3(polyjuiceProvider);\n  }\n\n  async sendWithdrawTransaction(withdrawalRequest: WithdrawalRequest): Promise<string> {\n    const result = await this.godwokenClient.submitWithdrawalRequest(withdrawalRequest);\n    return result as unknown as string;\n  }\n\n  getL2Address(): string {\n    return this.l2Address;\n  }\n  getL1Address(): string {\n    return this.l1Address;\n  }\n\n  static async CreateProvider(ethereum: any, version: LightGodwokenProviderConfig): Promise<LightGodwokenProvider> {\n    if (!ethereum || !ethereum.isMetaMask) {\n      throw new Error(\"please provide metamask ethereum object\");\n    }\n    return ethereum\n      .request({ method: \"eth_requestAccounts\" })\n      .then((accounts: any) => {\n        console.log(\"eth_requestAccounts\", accounts);\n        return new DefaultLightGodwokenProvider(accounts[0], ethereum, version);\n      })\n      .catch((error: any) => {\n        if (error.code === 4001) {\n          // EIP-1193 userRejectedRequest error\n          console.log(\"Please connect to MetaMask.\");\n        } else {\n          console.error(error);\n        }\n      });\n  }\n\n  generateL1Address(l2Address: Address): Address {\n    const omniLock: Script = {\n      code_hash: LAYER1_CONFIG.omni_lock.code_hash,\n      hash_type: LAYER1_CONFIG.omni_lock.hash_type as HashType,\n      // omni flag       pubkey hash   omni lock flags\n      // chain identity   eth addr      function flag()\n      // 00: Nervos                   00: owner\n      // 01: Ethereum                 01: administrator\n      //                            \n      args: `0x01${l2Address.substring(2)}00`,\n    };\n    return helpers.generateAddress(omniLock);\n  }\n\n  // // TODO the unknown is godwoken submit_withdrawal_tx\n  // sendWithdrawTransaction: (tx: unknown) => Promise<Hash>;\n\n  // // now only supported omni lock, the other lock type will be supported later\n  async sendL1Transaction(tx: Transaction): Promise<Hash> {\n    return await this.rpc.send_transaction(tx, \"passthrough\");\n  }\n\n  async signL1Transaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Transaction> {\n    const message = this.generateMessage(txSkeleton);\n    let signedMessage = await this.ethereum.request({\n      method: \"personal_sign\",\n      params: [this.ethereum.selectedAddress, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    const signedWitness = new toolkit.Reader(\n      core.SerializeWitnessArgs({\n        lock: SerializeRcLockWitnessLock({\n          signature: new toolkit.Reader(signedMessage),\n        }),\n      }),\n    ).serializeJson();\n    txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) => witnesses.push(`${signedWitness}`));\n    const signedTx = helpers.createTransactionFromSkeleton(txSkeleton);\n    return signedTx;\n  }\n\n  generateMessage(tx: helpers.TransactionSkeletonType): HexString {\n    const hasher = new utils.CKBHasher();\n    const rawTxHash = utils.ckbHash(\n      core.SerializeRawTransaction(\n        toolkit.normalizers.NormalizeRawTransaction(helpers.createTransactionFromSkeleton(tx)),\n      ),\n    );\n    const serializedWitness = core.SerializeWitnessArgs({\n      lock: new toolkit.Reader(\n        \"0x\" +\n          \"00\".repeat(\n            SerializeRcLockWitnessLock({\n              signature: new toolkit.Reader(\"0x\" + \"00\".repeat(65)),\n            }).byteLength,\n          ),\n      ),\n    });\n    hasher.update(rawTxHash);\n    this.hashWitness(hasher, serializedWitness);\n    return hasher.digestHex();\n  }\n\n  hashWitness(hasher: utils.CKBHasher, witness: ArrayBuffer): void {\n    const lengthBuffer = new ArrayBuffer(8);\n    const view = new DataView(lengthBuffer);\n    view.setBigUint64(0, BigInt(new toolkit.Reader(witness).length()), true);\n    hasher.update(lengthBuffer);\n    hasher.update(witness);\n  }\n\n  async getPendingTransaction(txHash: Hash): Promise<TransactionWithStatus | null> {\n    let tx: TransactionWithStatus | null = null;\n\n    // retry 10 times, and sleep 1s\n    for (let i = 0; i < 10; i++) {\n      tx = await this.rpc.get_transaction(txHash);\n      if (tx != null) {\n        return tx;\n      }\n      await this.asyncSleep(1000);\n    }\n    return null;\n  }\n\n  async getRollupCellDep(): Promise<CellDep> {\n    const result = await this.godwokenClient.getLastSubmittedInfo();\n    const txHash = result.transaction_hash;\n    const tx = await this.getPendingTransaction(txHash);\n\n    if (tx == null) {\n      throw new Error(\"Last submitted tx not found!\");\n    }\n\n    let rollupIndex = tx.transaction.outputs.findIndex((o: any) => {\n      return o.type && utils.computeScriptHash(o.type) === ROLLUP_CONFIG.rollup_type_hash;\n    });\n    return {\n      out_point: {\n        tx_hash: txHash,\n        index: `0x${rollupIndex.toString(16)}`,\n      },\n      dep_type: \"code\",\n    };\n  }\n\n  async getRollupCell(): Promise<Cell | undefined> {\n    const queryOptions = {\n      type: {\n        code_hash: ROLLUP_CONFIG.rollup_type_script.code_hash as Hash,\n        hash_type: ROLLUP_CONFIG.rollup_type_script.hash_type as HashType,\n        args: ROLLUP_CONFIG.rollup_type_script.args as HexString,\n      },\n    };\n    const collector = this.ckbIndexer.collector(queryOptions);\n    let rollupCell;\n    for await (const cell of collector.collect()) {\n      if (cell === null) {\n        return undefined;\n      } else {\n        rollupCell = cell;\n        break;\n      }\n    }\n    return rollupCell;\n  }\n\n  getLayer2LockScript(): Script {\n    const layer2Lock: Script = {\n      code_hash: SCRIPTS.eth_account_lock.script_type_hash as string,\n      hash_type: \"type\",\n      args: ROLLUP_CONFIG.rollup_type_hash + this.l2Address.slice(2).toLowerCase(),\n    };\n    return layer2Lock;\n  }\n\n  getLayer2LockScriptHash(): Hash {\n    const accountScriptHash = utils.computeScriptHash(this.getLayer2LockScript());\n    console.log(\"accountScriptHash\", accountScriptHash);\n    return accountScriptHash;\n  }\n\n  getLayer1LockScriptHash(): Hash {\n    const ownerCKBLock = helpers.parseAddress(this.l1Address);\n    const ownerLock: Script = {\n      code_hash: ownerCKBLock.code_hash,\n      args: ownerCKBLock.args,\n      hash_type: ownerCKBLock.hash_type as HashType,\n    };\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n    console.log(\"ownerLockHash\", ownerLockHash);\n    return ownerLockHash;\n  }\n\n  async getLastFinalizedBlockNumber(): Promise<number> {\n    const rollupCell = await this.getRollupCell();\n    if (!rollupCell === undefined) {\n      return 0;\n    }\n    const globalState = new godwokenCore.GlobalState(new toolkit.Reader(rollupCell!.data));\n    const lastFinalizedBlockNumber = Number(globalState.getLastFinalizedBlockNumber().toLittleEndianBigUint64());\n    console.log(\"last finalized block number: \", lastFinalizedBlockNumber);\n    return lastFinalizedBlockNumber;\n  }\n\n  async asyncSleep(ms = 0) {\n    return new Promise((r) => setTimeout(r, ms));\n  }\n}\n","export const SUDT_ERC20_PROXY_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"string\",\n        name: \"name_\",\n        type: \"string\",\n      },\n      {\n        internalType: \"string\",\n        name: \"symbol_\",\n        type: \"string\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"totalSupply_\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"sudtId_\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint8\",\n        name: \"decimals_\",\n        type: \"uint8\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Approval\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Transfer\",\n    type: \"event\",\n  },\n  {\n    inputs: [],\n    name: \"sudtId\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [\n      {\n        internalType: \"uint8\",\n        name: \"\",\n        type: \"uint8\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"recipient\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"transfer\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n    ],\n    name: \"allowance\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"approve\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"recipient\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"transferFrom\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"addedValue\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"increaseAllowance\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"subtractedValue\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"decreaseAllowance\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n","import { Cell, Hash, helpers, HexNumber, HexString, Script, toolkit, utils } from \"@ckb-lumos/lumos\";\nimport * as secp256k1 from \"secp256k1\";\nimport { getLayer2Config } from \"./constants/index\";\nimport { OMNI_LOCK_CELL_DEP, SECP256K1_BLACK160_CELL_DEP, SUDT_CELL_DEP } from \"./constants/layer1ConfigUtils\";\nimport {\n  NormalizeDepositLockArgs,\n  NormalizeRawWithdrawalRequest,\n  NormalizeWithdrawalLockArgs,\n  RawWithdrawalRequest,\n  WithdrawalLockArgs,\n} from \"./godwoken/normalizer\";\nimport LightGodwokenProvider, { POLYJUICE_CONFIG } from \"./lightGodwokenProvider\";\nimport {\n  DepositPayload,\n  GetErc20Balances,\n  GetErc20BalancesResult,\n  GetL1CkbBalancePayload,\n  GetL2CkbBalancePayload,\n  GetSudtBalances,\n  GetSudtBalancesResult,\n  GodwokenVersion,\n  LightGodwokenBase,\n  ProxyERC20,\n  SUDT,\n  WithdrawalEventEmitter,\n  WithdrawalEventEmitterPayload,\n  WithdrawResult,\n} from \"./lightGodwokenType\";\nimport {\n  SerializeDepositLockArgs,\n  SerializeRawWithdrawalRequest,\n  SerializeWithdrawalLockArgs,\n} from \"./schemas/index.esm\";\n\nconst { SCRIPTS, ROLLUP_CONFIG } = getLayer2Config();\n\nexport default abstract class DefaultLightGodwoken implements LightGodwokenBase {\n  provider: LightGodwokenProvider;\n\n  constructor(provider: LightGodwokenProvider) {\n    this.provider = provider;\n  }\n\n  abstract getBuiltinErc20List(): ProxyERC20[];\n\n  abstract getBuiltinSUDTList(): SUDT[];\n\n  abstract listWithdraw(): Promise<WithdrawResult[]>;\n\n  abstract getVersion(): GodwokenVersion;\n\n  abstract withdrawWithEvent(payload: WithdrawalEventEmitterPayload): WithdrawalEventEmitter;\n\n  async deposit(payload: DepositPayload): Promise<string> {\n    const neededCapacity = BigInt(payload.capacity);\n    const neededSudtAmount = payload.amount ? BigInt(payload.amount) : BigInt(0);\n    let collectedCapatity = BigInt(0);\n    let collectedSudtAmount = BigInt(0);\n    const collectedCells: Cell[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: helpers.parseAddress(this.provider.l1Address) });\n    for await (const cell of collector.collect()) {\n      console.log(cell);\n      if (\n        !cell.cell_output.type &&\n        (!cell.data || cell.data === \"0x\" || cell.data === \"0x0\") &&\n        collectedCapatity < neededCapacity\n      ) {\n        collectedCapatity += BigInt(cell.cell_output.capacity);\n        collectedCells.push(cell);\n        if (collectedCapatity >= neededCapacity && collectedSudtAmount >= neededSudtAmount) break;\n      } else if (\n        payload.sudtType &&\n        payload.sudtType.args === cell.cell_output.type?.args &&\n        collectedSudtAmount < neededSudtAmount\n      ) {\n        collectedCapatity += BigInt(cell.cell_output.capacity);\n        collectedSudtAmount += BigInt(utils.readBigUInt128LECompatible(cell.data).toBigInt());\n        collectedCells.push(cell);\n        if (collectedCapatity >= neededCapacity && collectedSudtAmount >= neededSudtAmount) break;\n      }\n    }\n    if (collectedCapatity < neededCapacity) {\n      throw new Error(`Not enough CKB, expected: ${neededCapacity}, actual: ${collectedCapatity} `);\n    }\n    if (collectedSudtAmount < neededSudtAmount) {\n      throw new Error(`Not enough SUDT, expected: ${neededSudtAmount}, actual: ${collectedSudtAmount} `);\n    }\n\n    const outputCell = this.generateDepositOutputCell(collectedCells, payload);\n    let txSkeleton = helpers.TransactionSkeleton({ cellProvider: this.provider.ckbIndexer });\n\n    txSkeleton = txSkeleton\n      .update(\"inputs\", (inputs) => {\n        return inputs.push(...collectedCells);\n      })\n      .update(\"outputs\", (outputs) => {\n        return outputs.push(...outputCell);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(OMNI_LOCK_CELL_DEP);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(SECP256K1_BLACK160_CELL_DEP);\n      });\n\n    if (payload.sudtType) {\n      txSkeleton = txSkeleton.update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(SUDT_CELL_DEP);\n      });\n    }\n\n    const signedTx = await this.provider.signL1Transaction(txSkeleton);\n    const txHash = await this.provider.sendL1Transaction(signedTx);\n    return txHash;\n  }\n\n  generateDepositOutputCell(collectedCells: Cell[], payload: DepositPayload): Cell[] {\n    const ownerLock: Script = helpers.parseAddress(this.provider.l1Address);\n    const ownerLockHash: Hash = utils.computeScriptHash(ownerLock);\n    const layer2Lock: Script = this.provider.getLayer2LockScript();\n\n    const depositLockArgs = {\n      owner_lock_hash: ownerLockHash,\n      layer2_lock: layer2Lock,\n      cancel_timeout: \"0xc0000000000004b0\",\n    };\n    const depositLockArgsHexString: HexString = new toolkit.Reader(\n      SerializeDepositLockArgs(NormalizeDepositLockArgs(depositLockArgs)),\n    ).serializeJson();\n    const depositLock: Script = {\n      code_hash: SCRIPTS.deposit_lock.script_type_hash,\n      hash_type: \"type\",\n      args: ROLLUP_CONFIG.rollup_type_hash + depositLockArgsHexString.slice(2),\n    };\n    const sumCapacity = collectedCells.reduce((acc, cell) => acc + BigInt(cell.cell_output.capacity), BigInt(0));\n    const sumSustAmount = collectedCells.reduce((acc, cell) => {\n      if (cell.cell_output.type) {\n        return acc + BigInt(utils.readBigUInt128LE(cell.data));\n      } else {\n        return acc;\n      }\n    }, BigInt(0));\n    const outputCell: Cell = {\n      cell_output: {\n        capacity: \"0x\" + BigInt(payload.capacity).toString(16),\n        lock: depositLock,\n      },\n      data: \"0x\",\n    };\n\n    // pay 0.0001 ckb for tx fee\n    const exchangeCapacity = BigInt(sumCapacity - BigInt(payload.capacity) - BigInt(100000));\n    const exchangeCell: Cell = {\n      cell_output: {\n        capacity: \"0x\" + exchangeCapacity.toString(16),\n        lock: helpers.parseAddress(this.provider.l1Address),\n      },\n      data: \"0x\",\n    };\n\n    if (payload.sudtType && payload.amount && payload.amount !== \"0x\" && payload.amount !== \"0x0\") {\n      outputCell.cell_output.type = payload.sudtType;\n      outputCell.data = utils.toBigUInt128LE(BigInt(payload.amount));\n\n      const sudtData = utils.toBigUInt128LE(sumSustAmount - BigInt(payload.amount));\n      const exchangeSudtCell: Cell = {\n        cell_output: {\n          capacity: \"0x0\",\n          lock: helpers.parseAddress(this.provider.l1Address),\n          type: payload.sudtType,\n        },\n        data: sudtData,\n      };\n      const sudtCapacity: bigint = helpers.minimalCellCapacity(exchangeSudtCell);\n\n      exchangeSudtCell.cell_output.capacity = \"0x\" + sudtCapacity.toString(16);\n\n      // minus sudt capacity from exchange cell\n      exchangeCell.cell_output.capacity = `0x${(exchangeCapacity - sudtCapacity).toString(16)}`;\n      return [outputCell, exchangeCell, exchangeSudtCell];\n    }\n\n    return [outputCell, exchangeCell];\n  }\n\n  /**\n   * get producing 1 block time\n   */\n  getBlockProduceTime(): number {\n    return 45 * 1000;\n  }\n\n  async getWithdrawal(txHash: Hash): Promise<unknown> {\n    const result = await this.provider.godwokenClient.getWithdrawal(txHash);\n    console.log(\"getWithdrawal result:\", result);\n    return result;\n  }\n\n  async signMessageMetamaskPersonalSign(message: Hash): Promise<HexString> {\n    let signedMessage = await this.provider.ethereum.request({\n      method: \"personal_sign\",\n      params: [this.provider.l2Address, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    return signedMessage;\n  }\n\n  async signMessageMetamaskEthSign(message: Hash): Promise<HexString> {\n    let signedMessage = await this.provider.ethereum.request({\n      method: \"eth_sign\",\n      params: [this.provider.l2Address, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    return signedMessage;\n  }\n\n  signMessage(message: Hash, privateKey: HexString): HexString {\n    const signObject = secp256k1.ecdsaSign(\n      new Uint8Array(new toolkit.Reader(message).toArrayBuffer()),\n      new Uint8Array(new toolkit.Reader(privateKey).toArrayBuffer()),\n    );\n    const signatureBuffer = new ArrayBuffer(65);\n    const signatureArray = new Uint8Array(signatureBuffer);\n    signatureArray.set(signObject.signature, 0);\n    let v = signObject.recid;\n    if (v >= 27) {\n      v -= 27;\n    }\n    signatureArray.set([v], 64);\n\n    const signature = new toolkit.Reader(signatureBuffer).serializeJson();\n    return signature;\n  }\n\n  generateWithdrawalMessageToSign(rawWithdrawalRequest: RawWithdrawalRequest, rollupTypeHash: Hash): Hash {\n    const serializedRawWithdrawalRequest: HexString = new toolkit.Reader(\n      SerializeRawWithdrawalRequest(NormalizeRawWithdrawalRequest(rawWithdrawalRequest)),\n    ).serializeJson();\n    const data = new toolkit.Reader(rollupTypeHash + serializedRawWithdrawalRequest.slice(2)).toArrayBuffer();\n    const message = utils.ckbHash(data).serializeJson();\n    return message;\n  }\n\n  minimalWithdrawalCapacity(isSudt: boolean): HexNumber {\n    // fixed size, the specific value is not important.\n    const dummyHash: Hash = \"0x\" + \"00\".repeat(32);\n    const dummyHexNumber: HexNumber = \"0x0\";\n    const dummyRollupTypeHash: Hash = dummyHash;\n    const dummyWithdrawalLockArgs: WithdrawalLockArgs = {\n      account_script_hash: dummyHash,\n      withdrawal_block_hash: dummyHash,\n      withdrawal_block_number: dummyHexNumber,\n      sudt_script_hash: dummyHash,\n      sell_amount: dummyHexNumber,\n      sell_capacity: dummyHexNumber,\n      owner_lock_hash: dummyHash,\n      payment_lock_hash: dummyHash,\n    };\n    const serialized: HexString = new toolkit.Reader(\n      SerializeWithdrawalLockArgs(NormalizeWithdrawalLockArgs(dummyWithdrawalLockArgs)),\n    ).serializeJson();\n    const args = dummyRollupTypeHash + serialized.slice(2);\n    const lock: Script = {\n      code_hash: dummyHash,\n      hash_type: \"data\",\n      args,\n    };\n    let type: Script | undefined = undefined;\n    let data = \"0x\";\n    if (isSudt) {\n      type = {\n        code_hash: dummyHash,\n        hash_type: \"data\",\n        args: dummyHash,\n      };\n      data = \"0x\" + \"00\".repeat(16);\n    }\n    const cell: Cell = {\n      cell_output: {\n        lock,\n        type,\n        capacity: dummyHexNumber,\n      },\n      data,\n    };\n    const capacity: bigint = helpers.minimalCellCapacity(cell);\n    return \"0x\" + capacity.toString(16);\n  }\n\n  async getL2CkbBalance(payload?: GetL2CkbBalancePayload): Promise<HexNumber> {\n    const balance = await this.provider.web3.eth.getBalance(payload?.l2Address || this.provider.l2Address);\n    return \"0x\" + Number(balance).toString(16);\n  }\n\n  async getL1CkbBalance(payload?: GetL1CkbBalancePayload): Promise<HexNumber> {\n    const collector = this.provider.ckbIndexer.collector({\n      lock: helpers.parseAddress(this.provider.l1Address),\n      type: \"empty\",\n      outputDataLenRange: [\"0x0\", \"0x1\"],\n    });\n    let collectedSum = BigInt(0);\n    for await (const cell of collector.collect()) {\n      collectedSum += BigInt(cell.cell_output.capacity);\n    }\n    return \"0x\" + collectedSum.toString(16);\n  }\n\n  async getErc20Balances(payload: GetErc20Balances): Promise<GetErc20BalancesResult> {\n    const result: GetErc20BalancesResult = { balances: [] };\n    let promises = [];\n    for (let index = 0; index < payload.addresses.length; index++) {\n      const address = payload.addresses[index];\n      const usdcContract = new this.provider.web3.eth.Contract(POLYJUICE_CONFIG.abiItems, address);\n      const usdcBalancePromise = usdcContract.methods.balanceOf(this.provider.l2Address).call();\n      promises.push(usdcBalancePromise);\n    }\n    await Promise.all(promises).then((values) => {\n      values.forEach((value) => {\n        result.balances.push(\"0x\" + Number(value).toString(16));\n      });\n    });\n    return result;\n  }\n\n  async getSudtBalances(payload: GetSudtBalances): Promise<GetSudtBalancesResult> {\n    const result: GetSudtBalancesResult = { balances: [] };\n    for (let index = 0; index < payload.types.length; index++) {\n      const type = payload.types[index];\n      const collector = this.provider.ckbIndexer.collector({\n        lock: helpers.parseAddress(this.provider.l1Address),\n        type,\n      });\n      let collectedSum = BigInt(0);\n      for await (const cell of collector.collect()) {\n        collectedSum += BigInt(utils.readBigUInt128LECompatible(cell.data).toBigInt());\n        collectedSum += BigInt(0);\n      }\n      result.balances.push(\"0x\" + collectedSum.toString(16));\n    }\n    return result;\n  }\n\n  async injectCapacity(\n    tx: helpers.TransactionSkeletonType,\n    fromScript: Script,\n    capacity: bigint,\n  ): Promise<helpers.TransactionSkeletonType> {\n    // additional 0.001 ckb for tx fee\n    // the tx fee could calculated by tx size\n    // this is just a simple example\n    const neededCapacity = capacity + BigInt(100000);\n    let collectedSum = BigInt(0);\n    const collectedCells: Cell[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: fromScript, type: \"empty\" });\n    for await (const cell of collector.collect()) {\n      if (!cell.data || cell.data === \"0x\" || cell.data === \"0x0\" || cell.data === \"0x00\") {\n        collectedSum += BigInt(cell.cell_output.capacity);\n        collectedCells.push(cell);\n        if (collectedSum >= neededCapacity) break;\n      }\n    }\n    if (collectedSum < neededCapacity) {\n      throw new Error(`Not enough CKB, expected: ${neededCapacity}, actual: ${collectedSum} `);\n    }\n    const changeOutput: Cell = {\n      cell_output: {\n        capacity: \"0x\" + BigInt(collectedSum - neededCapacity).toString(16),\n        lock: fromScript,\n      },\n      data: \"0x\",\n    };\n    tx = tx.update(\"inputs\", (inputs) => inputs.push(...collectedCells));\n    tx = tx.update(\"outputs\", (outputs) => outputs.push(changeOutput));\n    return tx;\n  }\n}\n","export const TOKEN_LIST = [\n  {\n    symbol: \"USDC\",\n    name: \"USD Coin\",\n    decimals: 18,\n    tokenURI: \"https://cryptologos.cc/logos/usd-coin-usdc-logo.svg?v=002\",\n    sudt_script_hash: \"\",\n    address: \"0xca6FcAAA5129aD9e5219397527A17c26E5AD6a6a\",\n    issuerLockHash: \"0x58bef38794236b315b7c23fd8132d7f42676228d659b291936e8c6c7ba9f064e\",\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x58bef38794236b315b7c23fd8132d7f42676228d659b291936e8c6c7ba9f064e\",\n    },\n  },\n  {\n    symbol: \"ETH\",\n    name: \"Ethereum\",\n    decimals: 18,\n    tokenURI: \"https://cryptologos.cc/logos/ethereum-eth-logo.svg?v=002\",\n    sudt_script_hash: \"\",\n    address: \"0xB1235Dd5bd72d9Ef2F0E311fC5ce7df0583B6458\",\n    issuerLockHash: \"0x1b072aa0ded384067106ea0c43c85bd71bafa5afdb432123511da46b390a4e33\",\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x1b072aa0ded384067106ea0c43c85bd71bafa5afdb432123511da46b390a4e33\",\n    },\n  },\n  {\n    symbol: \"TAI\",\n    name: \"NexisDAO TAI\",\n    decimals: 18,\n    tokenURI:\n      \"data:image/png;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAQDAwQDAwQEAwQFBAQFBgoHBgYGBg0JCggKDw0QEA8NDw4RExgUERIXEg4PFRwVFxkZGxsbEBQdHx0aHxgaGxr/2wBDAQQFBQYFBgwHBwwaEQ8RGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhr/wAARCAAoACgDASIAAhEBAxEB/8QAGgAAAgMBAQAAAAAAAAAAAAAAAAgEBQYBCf/EADQQAAEDAwEEBwUJAAAAAAAAAAIAAQQDBRIGBxETURUhIjJCUmIWgYKisggUFyczNEFTZ//EABkBAAMBAQEAAAAAAAAAAAAAAAMFBgIEB//EACQRAAEEAgEDBQEAAAAAAAAAAAMAAQIEERIFEyHCFCIxMoKS/9oADAMBAAIRAxEAPwB85kwIdPI/c3NZyVc68ot+TgHJmVHtFmhV0xqApFSbTj04FdiKA2+QI8Msipevy+pKXC1zGgEIWXbHe7Mfhj6js9Qh+IxHFcsti7aSUtctkKTSH1Ti5Fv35OpsW5Vo795zDk6V32y2hjZBuhbRtAdBvW4PS2RfqY5YY445Y9rHJZGbrmNNMgvG2O93gvFH09ZzEfhPHH5ks9ObbaJP52l4oIpyD7op8YcsJdNiB+v+W5IWE2cy6Q6a08cc5px6lvoMJT/3BNgOL1fX5vUhbrXR2IPv8x7KpCRyQy6muzsT71An2O2XQSa5W+JMEv76An9SvLjGePJPyH1soqS2iyCSUVNtX6ctZJBgCgWzKJGKmBRvxSKjwsezjwy7KeqBYbZaxFrbbokPHu8CgIfSkJpVvy3hv/rZN8hL0HQebsSjGP68UyCHVdHvDihS7bQevIHyB1uhJqXHWLgurB8MmjCwr6ZDCVTcT9z8ln5FurR37ubc2QhW/KVBGC5JN3ZYmOMnylqD7L9YbBQs3T4vSpaz9pOL927WPDIeFj5t/iTLx7dWkP3cG5uhCj6zPylhh2HyzIg4sr6NFCIGFP3vzQhC9JEKAIMMbYZkRf/Z\",\n    sudt_script_hash: \"\",\n    address: \"0x8290f27935A2D353adc834c9F3c5F6ef19635C2D\",\n    issuerLockHash: \"0x13d640a864c7e84d60afd8ca9c6689d345a18f63e2e426c9623a2811776cf211\",\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x13d640a864c7e84d60afd8ca9c6689d345a18f63e2e426c9623a2811776cf211\",\n    },\n  },\n];\n","import {\n  Cell,\n  CellDep,\n  core,\n  DepType,\n  Hash,\n  HashType,\n  helpers,\n  HexNumber,\n  HexString,\n  Script,\n  toolkit,\n  utils,\n  WitnessArgs,\n} from \"@ckb-lumos/lumos\";\nimport EventEmitter from \"events\";\nimport { core as godwokenCore } from \"@polyjuice-provider/godwoken\";\nimport { OMNI_LOCK_CELL_DEP, SECP256K1_BLACK160_CELL_DEP, SUDT_CELL_DEP } from \"./constants/layer1ConfigUtils\";\nimport { RawWithdrawalRequest, WithdrawalRequest } from \"./godwoken/normalizer\";\nimport DefaultLightGodwoken from \"./lightGodwoken\";\nimport {\n  UnlockPayload,\n  WithdrawalEventEmitter,\n  WithdrawalEventEmitterPayload,\n  GodwokenVersion,\n  LightGodwokenV0,\n  WithdrawResult,\n  ProxyERC20,\n  SUDT,\n} from \"./lightGodwokenType\";\nimport { getLayer2Config } from \"./constants/index\";\nimport { SerializeUnlockWithdrawalViaFinalize } from \"./schemas/index.esm\";\nimport { TOKEN_LIST } from \"./constants/tokens\";\nconst { SCRIPTS, ROLLUP_CONFIG } = getLayer2Config();\n\nexport default class DefaultLightGodwokenV0 extends DefaultLightGodwoken implements LightGodwokenV0 {\n  getVersion(): GodwokenVersion {\n    return \"v0\";\n  }\n\n  getBuiltinErc20List(): ProxyERC20[] {\n    const map: ProxyERC20[] = [];\n    TOKEN_LIST.forEach((token) => {\n      const tokenL1Script: Script = {\n        code_hash: token.l1Lock.code_hash,\n        args: token.l1Lock.args,\n        hash_type: token.l1Lock.hash_type as HashType,\n      };\n      const tokenScriptHash = utils.computeScriptHash(tokenL1Script);\n      map.push({\n        name: token.name,\n        symbol: token.symbol,\n        decimals: token.decimals,\n        address: token.address,\n        tokenURI: token.tokenURI,\n        sudt_script_hash: tokenScriptHash,\n      });\n    });\n    return map;\n  }\n\n  getBuiltinSUDTList(): SUDT[] {\n    const map: SUDT[] = [];\n    TOKEN_LIST.forEach((token) => {\n      const tokenL1Script: Script = {\n        code_hash: token.l1Lock.code_hash,\n        args: token.l1Lock.args,\n        hash_type: token.l1Lock.hash_type as HashType,\n      };\n      map.push({\n        type: tokenL1Script,\n        name: token.name,\n        symbol: token.symbol,\n        decimals: token.decimals,\n        tokenURI: token.tokenURI,\n      });\n    });\n    return map;\n  }\n\n  async listWithdraw(): Promise<WithdrawResult[]> {\n    const searchParams = this.getWithdrawalCellSearchParams(this.provider.l2Address);\n    console.log(\"searchParams is:\", searchParams);\n    const collectedCells: WithdrawResult[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: searchParams.script });\n    const lastFinalizedBlockNumber = await this.provider.getLastFinalizedBlockNumber();\n\n    const ownerCKBLock = helpers.parseAddress(this.provider.l1Address);\n    const ownerLock: Script = {\n      code_hash: ownerCKBLock.code_hash,\n      args: ownerCKBLock.args,\n      hash_type: ownerCKBLock.hash_type as HashType,\n    };\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n    console.log(\"ownerLockHash is:\", ownerLockHash);\n\n    for await (const cell of collector.collect()) {\n      const rawLockArgs = cell.cell_output.lock.args;\n      const lockArgs = new godwokenCore.WithdrawalLockArgs(new toolkit.Reader(`0x${rawLockArgs.slice(66)}`));\n\n      if (lockArgs == null) {\n        continue;\n      }\n\n      const withdrawBlock = Number(lockArgs.getWithdrawalBlockNumber().toLittleEndianBigUint64());\n      const containsOwnerLock = cell.cell_output.lock.args.includes(ownerLockHash.substring(2));\n\n      let sudtTypeHash = \"0x\" + \"00\".repeat(32);\n      let erc20: ProxyERC20 | undefined = undefined;\n      let amount: HexNumber = \"0x0\";\n\n      if (cell.cell_output.type) {\n        const sudtType: Script = {\n          code_hash: cell.cell_output.type.code_hash,\n          args: cell.cell_output.type.args,\n          hash_type: cell.cell_output.type.hash_type as HashType,\n        };\n        sudtTypeHash = utils.computeScriptHash(sudtType);\n        const builtinErc20List = this.getBuiltinErc20List();\n        erc20 = builtinErc20List.find((e) => e.sudt_script_hash === sudtTypeHash);\n        amount = `0x${utils.readBigUInt128LE(cell.data).toString(16)}`;\n      }\n\n      if (containsOwnerLock) {\n        collectedCells.push({\n          cell,\n          withdrawalBlockNumber: withdrawBlock,\n          remainingBlockNumber: Math.max(0, withdrawBlock - lastFinalizedBlockNumber),\n          capacity: cell.cell_output.capacity,\n          amount,\n          sudt_script_hash: sudtTypeHash,\n          erc20,\n        });\n      }\n    }\n    const sortedWithdrawals = collectedCells.sort((a, b) => {\n      return a.withdrawalBlockNumber - b.withdrawalBlockNumber;\n    });\n    console.log(\"found withdraw cells:\", sortedWithdrawals);\n    return sortedWithdrawals;\n  }\n\n  getWithdrawalCellSearchParams(ethAddress: string) {\n    if (ethAddress.length !== 42 || !ethAddress.startsWith(\"0x\")) {\n      throw new Error(\"eth address format error!\");\n    }\n    const accountScriptHash = this.provider.getLayer2LockScriptHash();\n\n    return {\n      script: {\n        code_hash: SCRIPTS.withdrawal_lock.script_type_hash,\n        hash_type: \"type\" as HashType,\n        args: `${ROLLUP_CONFIG.rollup_type_hash}${accountScriptHash.slice(2)}`,\n      },\n      script_type: \"lock\",\n    };\n  }\n\n  withdrawWithEvent(payload: WithdrawalEventEmitterPayload): WithdrawalEventEmitter {\n    const eventEmitter = new EventEmitter();\n    this.withdraw(eventEmitter, payload);\n    return eventEmitter;\n  }\n\n  async withdraw(eventEmitter: EventEmitter, payload: WithdrawalEventEmitterPayload): Promise<void> {\n    eventEmitter.emit(\"sending\");\n    const rollupTypeHash = ROLLUP_CONFIG.rollup_type_hash;\n    const ethAccountTypeHash = SCRIPTS.eth_account_lock.script_type_hash;\n    console.log(\" helpers.parseAddress(payload.withdrawal_address || this.provider.l1Address)\", payload, this.provider);\n\n    const ownerLock = helpers.parseAddress(payload.withdrawal_address || this.provider.l1Address);\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n    const ethAddress = this.provider.l2Address;\n    const l2AccountScript: Script = {\n      code_hash: ethAccountTypeHash,\n      hash_type: \"type\",\n      args: rollupTypeHash + ethAddress.slice(2),\n    };\n    const accountScriptHash = utils.computeScriptHash(l2AccountScript);\n    console.log(\"account script hash:\", accountScriptHash);\n    const fromId = await this.provider.godwokenClient.getAccountIdByScriptHash(accountScriptHash);\n    if (!fromId) {\n      throw new Error(\"account not found\");\n    }\n    const isSudt = payload.sudt_script_hash !== \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n    const minCapacity = this.minimalWithdrawalCapacity(isSudt);\n    if (BigInt(payload.capacity) < BigInt(minCapacity)) {\n      throw new Error(\n        `Withdrawal required ${BigInt(minCapacity)} shannons at least, provided ${BigInt(payload.capacity)}.`,\n      );\n    }\n    const nonce: HexNumber = await this.provider.godwokenClient.getNonce(fromId);\n    console.log(\"nonce:\", nonce);\n    const sellCapacity: HexNumber = \"0x0\";\n    const sellAmount: HexNumber = \"0x0\";\n    const paymentLockHash: HexNumber = \"0x\" + \"00\".repeat(32);\n    const feeSudtId: HexNumber = \"0x1\";\n    const feeAmount: HexNumber = \"0x0\";\n    const rawWithdrawalRequest: RawWithdrawalRequest = {\n      nonce: \"0x\" + BigInt(nonce).toString(16),\n      capacity: \"0x\" + BigInt(payload.capacity).toString(16),\n      amount: \"0x\" + BigInt(payload.amount).toString(16),\n      sudt_script_hash: payload.sudt_script_hash,\n      account_script_hash: accountScriptHash,\n      sell_amount: sellAmount,\n      sell_capacity: sellCapacity,\n      owner_lock_hash: ownerLockHash,\n      payment_lock_hash: paymentLockHash,\n      fee: {\n        sudt_id: feeSudtId,\n        amount: feeAmount,\n      },\n    };\n    console.log(\"rawWithdrawalRequest:\", rawWithdrawalRequest);\n    const message = this.generateWithdrawalMessageToSign(rawWithdrawalRequest, rollupTypeHash);\n    console.log(\"message:\", message);\n    const signatureMetamaskPersonalSign: HexString = await this.signMessageMetamaskPersonalSign(message);\n    console.log(\"signatureMetamaskPersonalSign:\", signatureMetamaskPersonalSign);\n    const withdrawalRequest: WithdrawalRequest = {\n      raw: rawWithdrawalRequest,\n      signature: signatureMetamaskPersonalSign,\n    };\n    console.log(\"withdrawalRequest:\", withdrawalRequest);\n    // using RPC `submitWithdrawalRequest` to submit withdrawal request to godwoken\n    let result: unknown;\n    try {\n      result = await this.provider.godwokenClient.submitWithdrawalRequest(withdrawalRequest);\n    } catch (e) {\n      eventEmitter.emit(\"error\", e);\n      return;\n    }\n    eventEmitter.emit(\"sent\", result);\n    console.log(\"withdrawal request result:\", result);\n    const maxLoop = 100;\n    let loop = 0;\n    const nIntervId = setInterval(async () => {\n      loop++;\n      const withdrawal: any = await this.getWithdrawal(result as unknown as Hash);\n      if (withdrawal && withdrawal.status === \"pending\") {\n        console.log(\"withdrawal pending:\", withdrawal);\n        eventEmitter.emit(\"pending\", result);\n      }\n      if (withdrawal && withdrawal.status === \"committed\") {\n        console.log(\"withdrawal committed:\", withdrawal);\n        eventEmitter.emit(\"success\", result);\n        clearInterval(nIntervId);\n      }\n      if (withdrawal === null && loop > maxLoop) {\n        eventEmitter.emit(\"fail\", result);\n        clearInterval(nIntervId);\n      }\n    }, 10000);\n  }\n\n  async unlock(payload: UnlockPayload): Promise<Hash> {\n    const l1Address = this.provider.l1Address;\n    const l1Lock = helpers.parseAddress(l1Address);\n    const outputCells: Cell[] = [];\n    if (payload.cell.cell_output.type) {\n      const dummySudtCell = {\n        cell_output: {\n          capacity: \"0x0\",\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      };\n      const sudtCapacity: bigint = helpers.minimalCellCapacity(dummySudtCell);\n      const capacityLeft = BigInt(payload.cell.cell_output.capacity) - sudtCapacity;\n\n      outputCells.push({\n        cell_output: {\n          capacity: `0x${capacityLeft.toString(16)}`,\n          lock: l1Lock,\n        },\n        data: \"0x\",\n      });\n      outputCells.push({\n        cell_output: {\n          capacity: `0x${sudtCapacity.toString(16)}`,\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      });\n    } else {\n      outputCells.push({\n        cell_output: {\n          capacity: payload.cell.cell_output.capacity,\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      });\n    }\n    const data =\n      \"0x00000000\" +\n      new toolkit.Reader(SerializeUnlockWithdrawalViaFinalize(toolkit.normalizers.NormalizeWitnessArgs({})))\n        .serializeJson()\n        .slice(2);\n    const newWitnessArgs: WitnessArgs = {\n      lock: data,\n    };\n    const withdrawalWitness = new toolkit.Reader(\n      core.SerializeWitnessArgs(toolkit.normalizers.NormalizeWitnessArgs(newWitnessArgs)),\n    ).serializeJson();\n\n    let txSkeleton = helpers.TransactionSkeleton({ cellProvider: this.provider.ckbIndexer });\n    const withdrawalLockDep: CellDep = {\n      out_point: {\n        tx_hash: SCRIPTS.withdrawal_lock.cell_dep.out_point.tx_hash,\n        index: SCRIPTS.withdrawal_lock.cell_dep.out_point.index,\n      },\n      dep_type: SCRIPTS.withdrawal_lock.cell_dep.dep_type as DepType,\n    };\n    const rollupCellDep: CellDep = await this.provider.getRollupCellDep();\n    txSkeleton = txSkeleton\n      .update(\"inputs\", (inputs) => {\n        return inputs.push(payload.cell);\n      })\n      .update(\"outputs\", (outputs) => {\n        return outputs.push(...outputCells);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(withdrawalLockDep);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(rollupCellDep);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(OMNI_LOCK_CELL_DEP);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(SECP256K1_BLACK160_CELL_DEP);\n      })\n      .update(\"witnesses\", (witnesses) => {\n        return witnesses.push(withdrawalWitness);\n      });\n\n    if (payload.cell.cell_output.type) {\n      txSkeleton = txSkeleton.update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(SUDT_CELL_DEP);\n      });\n    }\n\n    txSkeleton = await this.injectCapacity(txSkeleton, l1Lock, BigInt(0));\n\n    const signedTx = await this.provider.signL1Transaction(txSkeleton);\n    const txHash = await this.provider.sendL1Transaction(signedTx);\n    return txHash;\n  }\n}\n","import { Address, Cell, Hash, HexNumber, Transaction, helpers, Script } from \"@ckb-lumos/lumos\";\nimport { WithdrawalRequest } from \"./godwoken/normalizer\";\n\nexport interface GetL2CkbBalancePayload {\n  l2Address?: string;\n}\n\nexport interface GetL1CkbBalancePayload {\n  l1Address?: string;\n}\ninterface Token {\n  name: string;\n  symbol: string;\n  decimals: number;\n  tokenURI: string;\n}\n\ninterface ERC20 extends Token {\n  address: string;\n}\nexport interface ProxyERC20 extends ERC20 {\n  sudt_script_hash: Hash;\n}\nexport interface SUDT extends Token {\n  type: Script;\n}\n\nexport interface GetErc20BalancesResult {\n  balances: HexNumber[];\n}\n\nexport interface GetSudtBalancesResult {\n  balances: HexNumber[];\n}\n\nexport interface GetErc20Balances {\n  addresses: string[];\n}\n\nexport interface GetSudtBalances {\n  types: Script[];\n}\n\nexport interface GodwokenNetworkConfig {\n  testnetV1: \"https://godwoken-testnet-web3-v1-rpc.ckbapp.dev\";\n}\n\ninterface WithdrawListener {\n  (event: \"sending\", listener: () => void): void;\n  (event: \"sent\", listener: (txHash: Hash) => void): void;\n  (event: \"pending\", listener: (txHash: Hash) => void): void;\n  (event: \"success\", listener: (txHash: Hash) => void): void;\n  (event: \"error\", listener: (e: Error) => void): void;\n}\n\nexport interface WithdrawalEventEmitter {\n  on: WithdrawListener;\n}\n\nexport interface WithdrawalEventEmitterPayload {\n  // CKB capacity\n  capacity: HexNumber;\n  // L1 mapped sUDT amount\n  amount: HexNumber;\n  /**\n   * {@link L1MappedErc20}\n   */\n  sudt_script_hash: Hash;\n\n  /**\n   * withdraw to L1 address\n   */\n  withdrawal_address?: Address;\n}\n\nexport interface WithdrawResult {\n  cell: Cell;\n\n  withdrawalBlockNumber: number;\n\n  // relative to withdrawalBlockNumber\n  remainingBlockNumber: number;\n\n  capacity: HexNumber;\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n\n  erc20?: ProxyERC20;\n}\n\nexport interface UnlockPayload {\n  cell: Cell;\n}\n\nexport interface DepositPayload {\n  capacity: HexNumber;\n  amount?: HexNumber;\n  sudtType?: Script;\n}\n\ntype Promisable<T> = Promise<T> | T;\n\nexport const CKB_SUDT_ID = 1;\n\nexport interface LightGodwokenProvider {\n  getL2Address(): Promisable<string>;\n\n  getL1Address(): Promisable<string>;\n\n  // TODO the unknown is godwoken submit_withdrawal_tx\n  sendWithdrawTransaction: (withdrawalRequest: WithdrawalRequest) => Promise<Hash>;\n\n  signL1Transaction: (tx: helpers.TransactionSkeletonType) => Promise<Transaction>;\n\n  // now only supported omni lock, the other lock type will be supported later\n  sendL1Transaction: (tx: Transaction) => Promise<Hash>;\n}\n\nexport type GodwokenVersion = \"v0\" | \"v1\";\nexport type LightGodwokenProviderConfig = \"v0\" | \"v1\" | \"mainnet\";\n\nexport interface LightGodwokenBase {\n  provider: LightGodwokenProvider;\n\n  getVersion: () => GodwokenVersion;\n\n  /**\n   * get producing 1 block time\n   */\n  getBlockProduceTime: () => Promise<number> | number;\n\n  listWithdraw: () => Promise<WithdrawResult[]>;\n\n  deposit: (payload: DepositPayload) => Promise<Hash>;\n\n  withdrawWithEvent: (payload: WithdrawalEventEmitterPayload) => WithdrawalEventEmitter;\n\n  getL2CkbBalance: (payload?: GetL2CkbBalancePayload) => Promise<HexNumber>;\n\n  getL1CkbBalance: (payload?: GetL1CkbBalancePayload) => Promise<HexNumber>;\n\n  getBuiltinErc20List: () => ProxyERC20[];\n\n  getBuiltinSUDTList: () => SUDT[];\n\n  getErc20Balances: (payload: GetErc20Balances) => Promise<GetErc20BalancesResult>;\n\n  getSudtBalances: (payload: GetSudtBalances) => Promise<GetSudtBalancesResult>;\n}\n\nexport interface LightGodwokenV0 extends LightGodwokenBase {\n  unlock: (payload: UnlockPayload) => Promise<Hash>;\n}\nexport type LightGodwokenV1 = LightGodwokenBase;\n","import { helpers, Script, utils, BI, HashType, HexNumber, Hash } from \"@ckb-lumos/lumos\";\nimport {\n  Godwoken as GodwokenV1,\n  RawWithdrawalRequestV1,\n  WithdrawalRequestExtra,\n  WithdrawalRequestV1,\n} from \"./godwoken-v1/src/index\";\nimport EventEmitter from \"events\";\nimport { getLayer2Config } from \"./constants/index\";\nimport {\n  WithdrawalEventEmitter,\n  WithdrawalEventEmitterPayload,\n  CKB_SUDT_ID,\n  GodwokenVersion,\n  LightGodwokenV1,\n  ProxyERC20,\n  WithdrawResult,\n  SUDT,\n} from \"./lightGodwokenType\";\nimport DefaultLightGodwoken from \"./lightGodwoken\";\nconst { SCRIPTS, ROLLUP_CONFIG } = getLayer2Config();\n\nexport default class DefaultLightGodwokenV1 extends DefaultLightGodwoken implements LightGodwokenV1 {\n  getVersion(): GodwokenVersion {\n    return \"v1\";\n  }\n  getBuiltinSUDTList(): SUDT[] {\n    return [];\n  }\n  getBuiltinErc20List(): ProxyERC20[] {\n    return [];\n  }\n  async listWithdraw(): Promise<WithdrawResult[]> {\n    const searchParams = this.getWithdrawalCellSearchParams(this.provider.l2Address);\n    console.log(\"searchParams is:\", searchParams);\n    const collectedCells: WithdrawResult[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: searchParams.script });\n    const lastFinalizedBlockNumber = await this.provider.getLastFinalizedBlockNumber();\n\n    const ownerLockHash = this.provider.getLayer1LockScriptHash();\n\n    for await (const cell of collector.collect()) {\n      console.log(\"iteration --> cell is:\", cell);\n\n      // // a rollup_type_hash exists before this args, to make args friendly to prefix search\n      // struct WithdrawalLockArgs {\n      //   withdrawal_block_hash: Byte32,\n      //   withdrawal_block_number: Uint64,\n      //   account_script_hash: Byte32,\n      //   // layer1 lock to withdraw after challenge period\n      //   owner_lock_hash: Byte32,\n      // }\n\n      // according to the args shape:\n      // withdrawal_block_number byte location is 64~72\n      // owner_lock_hash byte location is 104~136\n      const rawLockArgs = cell.cell_output.lock.args;\n      if (rawLockArgs === null || rawLockArgs === undefined) {\n        console.warn(\"cell args is not valid\", cell);\n        continue;\n      }\n      const lockArgsOwnerScriptHash = rawLockArgs.slice(210, 274);\n      console.log(\"lockArgsOwnerScriptHash is:\", lockArgsOwnerScriptHash);\n\n      const withdrawBlock = utils.readBigUInt64LECompatible(`0x${rawLockArgs.slice(130, 146)}`);\n      console.log(\"withdrawBlock is:\", withdrawBlock.toNumber());\n\n      let sudtTypeHash = \"0x\" + \"00\".repeat(32);\n      let erc20: ProxyERC20 | undefined = undefined;\n      let amount: HexNumber = \"0x0\";\n\n      if (cell.cell_output.type) {\n        const sudtType: Script = {\n          code_hash: cell.cell_output.type.code_hash,\n          args: cell.cell_output.type.args,\n          hash_type: cell.cell_output.type.hash_type as HashType,\n        };\n        sudtTypeHash = utils.computeScriptHash(sudtType);\n        const builtinErc20List = this.getBuiltinErc20List();\n        erc20 = builtinErc20List.find((e) => e.sudt_script_hash === sudtTypeHash);\n        amount = `0x${utils.readBigUInt128LE(cell.data).toString(16)}`;\n      }\n\n      if (lockArgsOwnerScriptHash === ownerLockHash.slice(2)) {\n        collectedCells.push({\n          cell,\n          withdrawalBlockNumber: withdrawBlock.toNumber(),\n          remainingBlockNumber: Math.max(0, withdrawBlock.toNumber() - lastFinalizedBlockNumber),\n          capacity: cell.cell_output.capacity,\n          amount,\n          sudt_script_hash: sudtTypeHash,\n          erc20,\n        });\n      }\n    }\n    const sortedWithdrawals = collectedCells.sort((a, b) => {\n      return a.withdrawalBlockNumber - b.withdrawalBlockNumber;\n    });\n    console.log(\"found withdraw cells:\", sortedWithdrawals);\n    return sortedWithdrawals;\n  }\n\n  getWithdrawalCellSearchParams(ethAddress: string) {\n    if (ethAddress.length !== 42 || !ethAddress.startsWith(\"0x\")) {\n      throw new Error(\"eth address format error!\");\n    }\n    return {\n      script: {\n        code_hash: SCRIPTS.withdrawal_lock.script_type_hash,\n        hash_type: \"type\" as HashType,\n        args: \"0x\",\n      },\n      script_type: \"lock\",\n    };\n  }\n\n  withdrawWithEvent(payload: WithdrawalEventEmitterPayload): WithdrawalEventEmitter {\n    const eventEmitter = new EventEmitter();\n    this.withdraw(eventEmitter, payload);\n    return eventEmitter;\n  }\n\n  async withdraw(eventEmitter: EventEmitter, payload: WithdrawalEventEmitterPayload): Promise<void> {\n    eventEmitter.emit(\"sending\");\n    const godwokenWeb3 = new GodwokenV1(this.provider.config.GW_POLYJUICE_RPC_URL);\n    const chainId = await godwokenWeb3.getChainId();\n    const ownerCkbAddress = payload.withdrawal_address || this.provider.l1Address;\n    const ownerLock = helpers.parseAddress(ownerCkbAddress);\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n    const ethAddress = this.provider.l2Address;\n    const l2AccountScript: Script = {\n      code_hash: SCRIPTS.eth_account_lock.script_type_hash,\n      hash_type: \"type\",\n      args: ROLLUP_CONFIG.rollup_type_hash + ethAddress.slice(2),\n    };\n    const layer2AccountScriptHash = utils.computeScriptHash(l2AccountScript);\n\n    const address = layer2AccountScriptHash.slice(0, 42);\n    const balance = await godwokenWeb3.getBalance(CKB_SUDT_ID, address);\n    if (BI.from(balance).lt(BI.from(payload.capacity))) {\n      throw new Error(`Insufficient balance(${balance}) on Godwoken`);\n    }\n    const fromId = await godwokenWeb3.getAccountIdByScriptHash(layer2AccountScriptHash);\n    const nonce: number = await godwokenWeb3.getNonce(fromId!);\n\n    const rawWithdrawalRequest: RawWithdrawalRequestV1 = {\n      chain_id: chainId,\n      nonce: BI.from(nonce).toHexString(),\n      capacity: payload.capacity,\n      amount: payload.amount,\n      sudt_script_hash: payload.sudt_script_hash,\n      account_script_hash: layer2AccountScriptHash,\n      owner_lock_hash: ownerLockHash,\n      fee: \"0x0\",\n    };\n    const typedMsg = {\n      domain: {\n        name: \"Godwoken\",\n        version: \"1\",\n        chainId: Number(chainId),\n      },\n      message: {\n        accountScriptHash: layer2AccountScriptHash,\n        nonce,\n        chainId: Number(chainId),\n        fee: 0,\n        layer1OwnerLock: {\n          codeHash: ownerLock.code_hash,\n          hashType: ownerLock.hash_type,\n          args: ownerLock.args,\n        },\n        withdraw: {\n          ckbCapacity: BI.from(payload.capacity).toNumber(),\n          UDTAmount: BI.from(payload.amount).toNumber(),\n          UDTScriptHash: payload.sudt_script_hash,\n        },\n      },\n      primaryType: \"Withdrawal\" as const,\n      types: {\n        EIP712Domain: [\n          { name: \"name\", type: \"string\" },\n          { name: \"version\", type: \"string\" },\n          { name: \"chainId\", type: \"uint256\" },\n        ],\n        Withdrawal: [\n          { name: \"accountScriptHash\", type: \"bytes32\" },\n          { name: \"nonce\", type: \"uint256\" },\n          { name: \"chainId\", type: \"uint256\" },\n          { name: \"fee\", type: \"uint256\" },\n          { name: \"layer1OwnerLock\", type: \"Script\" },\n          { name: \"withdraw\", type: \"WithdrawalAsset\" },\n        ],\n        Script: [\n          { name: \"codeHash\", type: \"bytes32\" },\n          { name: \"hashType\", type: \"string\" },\n          { name: \"args\", type: \"bytes\" },\n        ],\n        WithdrawalAsset: [\n          { name: \"ckbCapacity\", type: \"uint256\" },\n          { name: \"UDTAmount\", type: \"uint256\" },\n          { name: \"UDTScriptHash\", type: \"bytes32\" },\n        ],\n      },\n    };\n    console.log(\"typedMsg:\", typedMsg);\n\n    let signedMessage = await this.provider.ethereum.request({\n      method: \"eth_signTypedData_v4\",\n      params: [this.provider.l2Address, JSON.stringify(typedMsg)],\n    });\n\n    // construct WithdrawalRequestExx tra\n    const withdrawalReq: WithdrawalRequestV1 = {\n      raw: rawWithdrawalRequest,\n      signature: signedMessage,\n    };\n    const withdrawalReqExtra: WithdrawalRequestExtra = {\n      request: withdrawalReq,\n      owner_lock: ownerLock,\n    };\n    console.log(\"WithdrawalRequestExtra:\", withdrawalReqExtra);\n\n    // submit WithdrawalRequestExtra\n    const result = await godwokenWeb3.submitWithdrawalReqV1(withdrawalReqExtra);\n    console.log(\"result:\", result);\n\n    if (result !== null) {\n      const errorMessage = (result as any).message;\n      if (errorMessage !== undefined && errorMessage !== null) {\n        eventEmitter.emit(\"error\", errorMessage);\n      }\n    }\n    eventEmitter.emit(\"sent\", result);\n    console.log(\"withdrawal request result:\", result);\n    const maxLoop = 100;\n    let loop = 0;\n    const nIntervId = setInterval(async () => {\n      loop++;\n      const withdrawal: any = await this.getWithdrawal(result as Hash);\n      if (withdrawal && withdrawal.status === \"pending\") {\n        console.log(\"withdrawal pending:\", withdrawal);\n        eventEmitter.emit(\"pending\", result);\n      }\n      if (withdrawal && withdrawal.status === \"committed\") {\n        console.log(\"withdrawal committed:\", withdrawal);\n        eventEmitter.emit(\"success\", result);\n        clearInterval(nIntervId);\n      }\n      if (withdrawal === null && loop > maxLoop) {\n        eventEmitter.emit(\"fail\", result);\n        clearInterval(nIntervId);\n      }\n    }, 10000);\n  }\n}\n","import detectEthereumProvider from \"@metamask/detect-provider\";\nimport React, { createContext, useEffect, useState } from \"react\";\nimport { LightGodwoken } from \"../light-godwoken\";\nimport { LightGodwoken as DefaultLightGodwoken } from \"../light-godwoken/index\";\nimport DefaultLightGodwokenProvider from \"../light-godwoken/lightGodwokenProvider\";\n\nexport const LightGodwokenContext = createContext<LightGodwoken | null>(null);\n\nconst addNetwork = (ethereum: any) => {\n  const params = [\n    {\n      chainId: \"0x315db00000006\",\n      chainName: \"GodwokenV1\",\n      nativeCurrency: {\n        name: \"pETH\",\n        symbol: \"pETH\",\n        decimals: 18,\n      },\n      rpcUrls: [\"https://godwoken-testnet-web3-v1-rpc.ckbapp.dev\"],\n      blockExplorerUrls: [\"https://v1.aggron.gwscan.com/\"],\n    },\n  ];\n\n  ethereum\n    .request({ method: \"wallet_addEthereumChain\", params })\n    .then(() => console.log(\"Success\"))\n    .catch((error: Error) => console.log(\"Error\", error.message));\n};\n\nexport const Provider: React.FC = (props) => {\n  const [lightGodwoken, setLightGodwoken] = useState<LightGodwoken>();\n\n  useEffect(() => {\n    detectEthereumProvider().then((ethereum: any) => {\n      addNetwork(ethereum);\n\n      ethereum.request({ method: \"eth_accounts\" }).then((accounts: string[]) => {\n        if (!accounts || !accounts[0]) return;\n\n        const instance = new DefaultLightGodwoken(new DefaultLightGodwokenProvider(accounts[0], ethereum, \"v1\"));\n        setLightGodwoken(instance);\n      });\n\n      ethereum.on(\"accountsChanged\", (accounts: string[] | undefined) => {\n        if (!accounts || !accounts[0]) return setLightGodwoken(undefined);\n\n        const provider = new DefaultLightGodwoken(\n          new DefaultLightGodwokenProvider(ethereum.selectedAddress, ethereum, \"v1\"),\n        );\n        setLightGodwoken(provider);\n      });\n    });\n  }, []);\n\n  return <LightGodwokenContext.Provider value={lightGodwoken || null}>{props.children}</LightGodwokenContext.Provider>;\n};\n","import { useContext } from \"react\";\nimport { LightGodwokenContext } from \"../contexts/LightGodwokenContext\";\nimport { LightGodwoken } from \"../light-godwoken\";\n\nexport const useLightGodwoken = (): LightGodwoken | null => {\n  const lightGodwoken = useContext(LightGodwokenContext);\n\n  return lightGodwoken;\n};\n","export const getDisplayAmount = (balance: BigInt, decimals = 8) => {\n  const valueStr = balance.toString();\n  if (decimals === 0) {\n    return valueStr;\n  }\n\n  const intPart = valueStr.slice(0, -decimals) || \"0\";\n  const unit = intPart === \"0\" ? 1e8 : 1e4;\n  let decPart = valueStr\n    .slice(-decimals)\n    .padStart(decimals, \"0\")\n    .slice(0, intPart === \"0\" ? 9 : 5);\n  decPart = (Math.round(Number(`0.${decPart}`) * unit) / unit)\n    .toFixed(intPart === \"0\" ? 8 : 4)\n    .replace(/(\\d)0+$/, \"$1\")\n    .slice(2);\n\n  return `${intPart}${decPart === \"0\" ? \"\" : `.${decPart}`}`;\n};\n\nexport const getFullDisplayAmount = (value: BigInt, decimals = 8, options: { maxDecimalPlace?: number } = {}) => {\n  const { maxDecimalPlace = 4 } = options;\n\n  const valueStr = value.toString();\n  if (decimals === 0) {\n    return valueStr;\n  }\n\n  const intPart = valueStr.slice(0, -decimals) || \"0\";\n  const decPart = valueStr\n    .slice(-decimals)\n    .padStart(decimals, \"0\")\n    .replace(/(\\d)0+$/, \"$1\")\n    .slice(0, maxDecimalPlace);\n\n  return `${intPart}${decPart === \"0\" ? \"\" : `.${decPart}`}`;\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nconst StyledInput = styled.input<{ error?: boolean; fontSize?: string; align?: string }>`\n  width: 0;\n  position: relative;\n  font-weight: 500;\n  outline: none;\n  border: none;\n  flex: 1 1 auto;\n  background-color: transparent;\n  font-size: 16px;\n  text-align: ${({ align }) => align && align};\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  padding: 0px;\n  -webkit-appearance: textfield;\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  [type=\"number\"] {\n    -moz-appearance: textfield;\n  }\n\n  ::-webkit-outer-spin-button,\n  ::-webkit-inner-spin-button {\n    -webkit-appearance: none;\n  }\n\n  :disabled {\n    cursor: text;\n  }\n`;\n\nexport function escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\nconst inputRegex = RegExp(`^\\\\d*(?:\\\\\\\\[.])?\\\\d*$`); // match escaped \".\" characters via in a non-capturing group\n\nexport const Input = React.memo(function InnerInput({\n  value,\n  onUserInput,\n  placeholder,\n  ...rest\n}: {\n  value: string | number;\n  onUserInput: (input: string) => void;\n  error?: boolean;\n  fontSize?: string;\n  align?: \"right\" | \"left\";\n} & Omit<React.HTMLProps<HTMLInputElement>, \"ref\" | \"onChange\" | \"as\">) {\n  const enforcer = (nextUserInput: string) => {\n    if (nextUserInput === \"\" || inputRegex.test(escapeRegExp(nextUserInput))) {\n      onUserInput(nextUserInput);\n    }\n  };\n\n  return (\n    <StyledInput\n      {...rest}\n      value={value}\n      onChange={(event) => {\n        // replace commas with periods, because we exclusively uses period as the decimal separator\n        enforcer(event.target.value.replace(/,/g, \".\"));\n      }}\n      // universal input options\n      inputMode=\"decimal\"\n      title=\"Token Amount\"\n      autoComplete=\"off\"\n      autoCorrect=\"off\"\n      // text-specific options\n      type=\"text\"\n      pattern=\"^[0-9]*[.,]?[0-9]*$\"\n      placeholder={placeholder || \"0.0\"}\n      minLength={1}\n      maxLength={79}\n      spellCheck=\"false\"\n    />\n  );\n});\n\nexport default Input;\n","import { Typography } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nimport { getDisplayAmount } from \"../utils/formatTokenAmount\";\nimport NumericalInput from \"./NumericalInput\";\n\nconst StyleWrapper = styled.div`\n  font-size: 14px;\n  border-radius: 16px;\n  background-color: rgb(60, 58, 75);\n  box-shadow: rgb(74 74 104 / 10%) 0px 2px 2px -1px;\n  .first-row {\n    margin-bottom: 3px;\n    padding: 0.75rem 1rem 0px;\n  }\n  .anticon {\n    font-size: 12px;\n  }\n\n  .input-wrapper {\n    padding: 0.75rem 0.5rem 0.75rem 1rem;\n  }\n`;\nconst Row = styled.div`\n  display: flex;\n  justify-content: space-between;\n  .ant-typography {\n    color: white;\n    font-size: 16px;\n    font-weight: 400;\n    line-height: 1.5;\n  }\n  .ckb-logo {\n    height: 24px;\n    width: 24px;\n    margin-right: 8px;\n  }\n  .max-button {\n    height: 32px;\n    padding: 0px 16px;\n    background-color: transparent;\n    color: rgb(255, 67, 66);\n    font-weight: 600;\n    &:hover {\n      cursor: pointer;\n    }\n  }\n`;\n\ninterface CKBInputPanelProps {\n  value: string;\n  onUserInput: (value: string) => void;\n  isL1?: boolean;\n  label?: React.ReactElement | string;\n}\nexport default function CKBInputPanel({ value, onUserInput, label, isL1 }: CKBInputPanelProps) {\n  const [showMaxButton, setShowMaxButton] = useState(true);\n  const [ckbBalance, setCkbBalance] = useState(\"\");\n  const lightGodwoken = useLightGodwoken();\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const balance = isL1\n        ? (await lightGodwoken?.getL1CkbBalance()) || \"\"\n        : (await lightGodwoken?.getL2CkbBalance()) || \"\";\n      setCkbBalance(balance);\n    };\n    fetchData();\n  }, [lightGodwoken, isL1]);\n\n  useEffect(() => {\n    if (value !== getDisplayAmount(BigInt(ckbBalance), 8)) {\n      setShowMaxButton(true);\n    } else {\n      setShowMaxButton(false);\n    }\n  }, [value, ckbBalance]);\n\n  const handelMaxClick = () => {\n    onUserInput(getDisplayAmount(BigInt(ckbBalance) - BigInt(64 * 10 ** 8), 8));\n    setShowMaxButton(false);\n  };\n  return (\n    <StyleWrapper>\n      <Row className=\"first-row\">\n        <Typography.Text>{label}</Typography.Text>\n        <Typography.Text>Balance: {getDisplayAmount(BigInt(ckbBalance), 8) || \"\"}</Typography.Text>\n      </Row>\n      <Row className=\"input-wrapper\">\n        <NumericalInput\n          className=\"token-amount-input\"\n          value={value}\n          placeholder=\"Minimum 400 CKB\"\n          onUserInput={(val) => {\n            onUserInput(val);\n          }}\n        />\n        {showMaxButton && (\n          <Typography.Text className=\"max-button\" onClick={handelMaxClick}>\n            MAX\n          </Typography.Text>\n        )}\n        <img className=\"ckb-logo\" src=\"./static/ckb.svg\" alt=\"\" />\n        <Typography.Text>CKB</Typography.Text>\n      </Row>\n    </StyleWrapper>\n  );\n}\n","import { CopyOutlined } from \"@ant-design/icons\";\nimport { Button, Input, Tooltip } from \"antd\";\nimport React, { useMemo } from \"react\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../../hooks/useLightGodwoken\";\n\nconst TipWrapper = styled.div`\n  color: #fff;\n  .text-pair {\n    display: flex;\n    justify-content: space-between;\n  }\n`;\n\nfunction truncateMiddle(str: string, first = 6, last = 4): string {\n  return str.substring(0, first) + \"...\" + str.substring(str.length - last);\n}\n\nexport const Address: React.FC = () => {\n  const lightGodwoken = useLightGodwoken();\n\n  const l2Address = useMemo(() => {\n    if (!lightGodwoken) return undefined;\n    return lightGodwoken.provider.getL2Address();\n  }, [lightGodwoken]);\n\n  if (!lightGodwoken || !l2Address) return null;\n  const copyL1Address = () => {\n    navigator.clipboard.writeText(lightGodwoken?.provider.getL1Address() || \"\");\n  };\n  const copyL2Address = () => {\n    navigator.clipboard.writeText(lightGodwoken?.provider.getL2Address() || \"\");\n  };\n  return (\n    <Tooltip\n      title={\n        <TipWrapper>\n          <div className=\"address-content\">\n            <label htmlFor=\"\">ETH ADDRESS</label>\n            <Input.Group compact>\n              <Input style={{ width: \"calc(100% - 33px)\" }} value={lightGodwoken.provider.getL2Address()} />\n              <Tooltip title=\"copy git url\">\n                <Button icon={<CopyOutlined />} onClick={copyL2Address} />\n              </Tooltip>\n            </Input.Group>\n          </div>\n          {/* <div className=\"text-pair\">\n            <Text>L2 CKB Balance</Text>\n            <Text>{getFullDisplayAmount(BigInt(l2CkbBalance), 8)}</Text>\n          </div> */}\n          <div className=\"address-content\">\n            <label htmlFor=\"\">L1 WALLET ADDRESS</label>\n            <Input.Group compact>\n              <Input style={{ width: \"calc(100% - 33px)\" }} value={lightGodwoken.provider.getL1Address()} />\n              <Tooltip title=\"copy git url\">\n                <Button icon={<CopyOutlined />} onClick={copyL1Address} />\n              </Tooltip>\n            </Input.Group>\n          </div>\n        </TipWrapper>\n      }\n    >\n      {truncateMiddle(l2Address)}\n    </Tooltip>\n  );\n};\n","import detectEthereumProvider from \"@metamask/detect-provider\";\nimport { Button } from \"antd\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../../hooks/useLightGodwoken\";\nimport { Address } from \"../Address\";\nconst StyleWrapper = styled(Button)`\n  &.ant-btn-primary {\n    background: rgb(60, 58, 75);\n    border: none;\n  }\n`;\nexport const ConnectButton: React.FC = () => {\n  const lightGodwoken = useLightGodwoken();\n\n  function connectWallet() {\n    if (lightGodwoken) return;\n\n    detectEthereumProvider().then((ethereum: any) => {\n      ethereum.request({ method: \"eth_requestAccounts\" });\n    });\n  }\n\n  return (\n    <StyleWrapper type=\"primary\" onClick={connectWallet}>\n      {lightGodwoken ? <Address /> : \"Connect\"}\n    </StyleWrapper>\n  );\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport { ConnectButton } from \"../components/ConnectButton\";\n\nconst StyledPage = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n  padding: 16px;\n  background: radial-gradient(89.56% 89.56% at 50.04% 10.44%, rgb(60, 58, 75) 0%, rgb(28, 27, 37) 92.56%);\n  margin-bottom: 20px;\n  color: white;\n\n  .address:hover {\n    cursor: pointer;\n  }\n\n  a + a {\n    padding-left: 10px;\n  }\n`;\n\nconst PageHeader: React.FC<React.HTMLAttributes<HTMLDivElement>> = () => {\n  return (\n    <StyledPage>\n      <div className=\"title\">Light Godwoken</div>\n      <div className=\"address\">\n        <ConnectButton />\n      </div>\n    </StyledPage>\n  );\n};\n\nexport default PageHeader;\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport PageHeader from \"./PageHeader\";\n\nconst StyledPage = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 100%;\n  min-height: calc(100vh);\n  background: radial-gradient(89.56% 89.56% at 50.04% 10.44%, rgb(60, 58, 75) 0%, rgb(28, 27, 37) 92.56%);\n`;\n\nconst Page: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ children, ...props }) => {\n  return (\n    <StyledPage {...props}>\n      <PageHeader></PageHeader>\n      {children}\n    </StyledPage>\n  );\n};\n\nexport default Page;\n","import { InfoCircleOutlined, LoadingOutlined } from \"@ant-design/icons\";\nimport { BI, Script } from \"@ckb-lumos/lumos\";\nimport { Button, message, Modal, notification, Tooltip, Typography } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nimport CKBInputPanel from \"./CKBInputPanel\";\nimport Page from \"./Page\";\nimport { useQuery } from \"react-query\";\nimport { getDisplayAmount } from \"../utils/formatTokenAmount\";\nimport { ConnectButton } from \"../components/ConnectButton\";\n\nconst { Text } = Typography;\n\nconst PageContent = styled.div`\n  width: 436px;\n  background: rgb(39, 37, 52);\n  border-radius: 24px;\n  color: white;\n`;\nconst PageHeader = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  padding: 24px;\n\n  a,\n  .ant-typography {\n    color: white;\n  }\n\n  .title {\n    font-weight: bold;\n    font-size: 20px;\n    padding-bottom: 5px;\n  }\n\n  .description {\n    font-size: 14px;\n  }\n`;\nconst PageMain = styled.div`\n  padding: 24px;\n  grid-auto-rows: auto;\n  row-gap: 8px;\n\n  .icon {\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    padding-top: 8px;\n    padding-bottom: 8px;\n  }\n\n  .l1-faucet {\n    display: flex;\n    flex-direction: column;\n    padding-top: 20px;\n\n    .ant-typography {\n      color: white;\n      padding-right: 5px;\n    }\n\n    a {\n      color: rgb(255, 67, 66);\n    }\n  }\n`;\nconst L1WalletAddress = styled.div`\n  display: flex;\n  flex-direction: column;\n  margin: 24px;\n  padding: 16px;\n  border: 1px solid rgb(60, 58, 75);\n  border-radius: 16px;\n\n  .ant-typography {\n    color: white;\n  }\n\n  .title {\n    font-size: 16px;\n    padding-bottom: 10px;\n  }\n\n  .address {\n    font-size: 16px;\n    padding-bottom: 10px;\n  }\n\n  .copy {\n    color: rgb(255, 67, 66);\n\n    .ant-typography {\n      font-size: 14px;\n      color: rgb(255, 67, 66);\n      padding-right: 5px;\n    }\n\n    &:hover {\n      cursor: pointer;\n    }\n  }\n`;\nconst WithDrawalButton = styled.div`\n  margin-top: 20px;\n  display: flex;\n  justify-content: center;\n\n  .submit-button {\n    align-items: center;\n    border: 0px;\n    border-radius: 16px;\n    box-shadow: rgb(14 14 44 / 40%) 0px -1px 0px 0px inset;\n    cursor: pointer;\n    display: inline-flex;\n    font-family: inherit;\n    font-size: 16px;\n    font-weight: 600;\n    -webkit-box-pack: center;\n    justify-content: center;\n    letter-spacing: 0.03em;\n    line-height: 1;\n    opacity: 1;\n    outline: 0px;\n    transition: background-color 0.2s ease 0s, opacity 0.2s ease 0s;\n    height: 48px;\n    padding: 0px 24px;\n    background-color: rgb(255, 67, 66);\n    color: white;\n    width: 100%;\n\n    &:disabled {\n      background-color: rgb(60, 55, 66);\n      border-color: rgb(60, 55, 66);\n      box-shadow: none;\n      color: rgb(104, 102, 123);\n      cursor: not-allowed;\n    }\n  }\n\n  button:hover {\n    cursor: pointer;\n  }\n`;\nconst ConfirmModal = styled(Modal)`\n  color: white;\n\n  .ant-modal-content {\n    border-radius: 32px;\n    background: rgb(39, 37, 52);\n    box-shadow: rgb(14 14 44 / 10%) 0px 20px 36px -8px, rgb(0 0 0 / 5%) 0px 1px 1px;\n    border: 1px solid rgb(60, 58, 75);\n    color: white;\n  }\n\n  .ant-modal-header {\n    background: rgb(39, 37, 52);\n    border: 1px solid rgb(60, 58, 75);\n    border-top-left-radius: 32px;\n    border-top-right-radius: 32px;\n    padding: 12px 24px;\n    height: 73px;\n    display: flex;\n    align-items: center;\n  }\n\n  .ant-modal-title,\n  .ant-list-item {\n    color: white;\n  }\n\n  .ant-modal-body {\n    padding: 24px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n\n  .ant-modal-close-x {\n    color: white;\n  }\n\n  .ant-typography {\n    color: white;\n    justify-content: space-between;\n  }\n\n  .tips {\n    margin: 24px 0;\n  }\n\n  .anticon-loading {\n    font-size: 50px;\n    color: rgb(255, 67, 66);\n  }\n\n  .icon-container {\n    padding-bottom: 20px;\n  }\n`;\n\ninterface Token {\n  name: string;\n  symbol: string;\n  decimals: number;\n  tokenURI: string;\n}\n\ninterface SUDT extends Token {\n  type: Script;\n}\n\nfunction L2Balance() {\n  const lightGodwoken = useLightGodwoken();\n\n  const l2Address = lightGodwoken?.provider.l2Address;\n  const { data: balance } = useQuery(\n    [\"queryL2Balance\", { address: l2Address }],\n    () => {\n      return lightGodwoken?.getL2CkbBalance();\n    },\n    {\n      enabled: !!lightGodwoken,\n    },\n  );\n\n  if (!l2Address) return null;\n  if (!balance) {\n    return (\n      <span>\n        <LoadingOutlined />\n      </span>\n    );\n  }\n  return <span>L2 Balance: {getDisplayAmount(BigInt(balance), 8)} CKB</span>;\n}\n\nfunction FaucetTip() {\n  const [faucetTip, setFaucetTip] = useState(false);\n  const lightGodwoken = useLightGodwoken();\n\n  useEffect(() => {\n    if (!lightGodwoken) return;\n\n    lightGodwoken.getL1CkbBalance().then((balance) => {\n      if (BI.from(balance).eq(0)) {\n        setFaucetTip(true);\n      }\n    });\n  }, [lightGodwoken]);\n\n  return (\n    <div>\n      <p>\n        <b>Important</b>: To claim L2 Godwoken testnet tokens, you must first have L1 testnet tokens in your L1 account.\n      </p>\n      <p> Copy your L1 address (after your wallet is connected) and use the L1 testnet faucet to claim L1 tokens.</p>\n\n      {!lightGodwoken ? (\n        <ConnectButton />\n      ) : (\n        <Button\n          type=\"primary\"\n          onClick={async () => {\n            await navigator.clipboard.writeText(lightGodwoken?.provider.getL1Address() || \"\");\n            message.success(\"copied L1 address to clipboard\");\n            window.location.href = \"https://faucet.nervos.org\";\n          }}\n        >\n          Copy L1 address and claim from faucet\n        </Button>\n      )}\n    </div>\n  );\n}\n\nexport default function Deposit() {\n  const [ckbInput, setCkbInput] = useState(\"\");\n  const [outputValue, setOutputValue] = useState(\"\");\n  const [isModalVisible, setIsModalVisible] = useState(false);\n  const [submitButtonDisable, setSubmitButtonDisable] = useState(true);\n  const [selectedSudt, setSelectedSudt] = useState<SUDT>();\n  const lightGodwoken = useLightGodwoken();\n\n  const showModal = async () => {\n    setIsModalVisible(true);\n    if (lightGodwoken) {\n      const capacity = BigInt(Number(ckbInput) * Math.pow(10, 8));\n      let amount = \"0x0\";\n      if (selectedSudt) {\n        amount = \"0x\" + BigInt(Number(outputValue) * Math.pow(10, selectedSudt.decimals)).toString(16);\n      }\n      const hash = await lightGodwoken.deposit({\n        capacity: \"0x\" + capacity.toString(16),\n        amount: amount,\n        sudtType: selectedSudt?.type,\n      });\n      notification.success({ message: `deposit Tx(${hash}) is successful` });\n      setIsModalVisible(false);\n    }\n  };\n\n  const handleCancel = () => {\n    setIsModalVisible(false);\n  };\n\n  useEffect(() => {\n    if (Number(ckbInput) >= 400) {\n      setSubmitButtonDisable(false);\n    } else {\n      setSubmitButtonDisable(true);\n    }\n  }, [ckbInput]);\n\n  const handleSelectedChange = (value: Token) => {\n    setSelectedSudt(value as SUDT);\n  };\n\n  const copyAddress = () => {\n    void navigator.clipboard.writeText(lightGodwoken?.provider.getL1Address() || \"\");\n    void message.success(\"copied to clipboard\");\n  };\n  return (\n    <Page>\n      <PageContent>\n        <PageHeader className=\"header\">\n          <Text className=\"title\">Deposit To Layer2</Text>\n          <FaucetTip />\n        </PageHeader>\n        <PageMain className=\"main\">\n          <CKBInputPanel\n            value={ckbInput}\n            onUserInput={setCkbInput}\n            label={\n              <span>\n                Deposit&nbsp;\n                <Tooltip title=\"For some reason it is needed to leave at least 64 CKB on L1 when using this app, this issue will be optimised in the future.\">\n                  <InfoCircleOutlined style={{ verticalAlign: \"middle\" }} />\n                </Tooltip>\n              </span>\n            }\n            isL1\n          />\n\n          <WithDrawalButton>\n            <Button className=\"submit-button\" disabled={submitButtonDisable} onClick={showModal}>\n              Deposit\n            </Button>\n          </WithDrawalButton>\n\n          <div>\n            <L2Balance />\n          </div>\n        </PageMain>\n        <div className=\"footer\"></div>\n      </PageContent>\n      <ConfirmModal title=\"Confirm Transaction\" visible={isModalVisible} onCancel={handleCancel} footer={null}>\n        <div className=\"icon-container\">\n          <LoadingOutlined />\n        </div>\n        <Text>Waiting For Confirmation</Text>\n        <Text>\n          Depositing {outputValue} {selectedSudt?.symbol} and {ckbInput} CKB\n        </Text>\n        <div className=\"tips\">Confirm this transaction in your wallet</div>\n      </ConfirmModal>\n    </Page>\n  );\n}\n","import \"antd/dist/antd.css\";\nimport React from \"react\";\nimport { HashRouter as Router, Route, Routes } from \"react-router-dom\";\nimport { Provider as LightGodwokenProvider } from \"./contexts/LightGodwokenContext\";\nimport Deposit from \"./views/Deposit\";\nimport { QueryClient, QueryClientProvider } from \"react-query\";\n\nfunction App() {\n  return (\n    <QueryClientProvider client={new QueryClient()}>\n      <LightGodwokenProvider>\n        <Router>\n          <Routes>\n            <Route path=\"/\" element={<Deposit />}></Route>\n            <Route path=\"/deposit\" element={<Deposit />}></Route>\n          </Routes>\n        </Router>\n      </LightGodwokenProvider>\n    </QueryClientProvider>\n  );\n}\n\nexport default App;\n","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { config } from \"@ckb-lumos/lumos\";\n\nconfig.initializeConfig(config.predefined.AGGRON4);\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\"),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","/* eslint-disable */\n(function (global, factory) {\n  typeof exports === \"object\" && typeof module !== \"undefined\"\n    ? factory(exports)\n    : typeof define === \"function\" && define.amd\n    ? define([\"exports\"], factory)\n    : ((global = typeof globalThis !== \"undefined\" ? globalThis : global || self), factory((global.Godwoken = {})));\n})(this, function (exports) {\n  \"use strict\";\n\n  function dataLengthError(actual, required) {\n    throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n  }\n\n  function assertDataLength(actual, required) {\n    if (actual !== required) {\n      dataLengthError(actual, required);\n    }\n  }\n\n  function assertArrayBuffer(reader) {\n    if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n      reader = reader.toArrayBuffer();\n    }\n    if (!(reader instanceof ArrayBuffer)) {\n      throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n    }\n    return reader;\n  }\n\n  function verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n    if (view.byteLength < 4) {\n      dataLengthError(view.byteLength, \">4\");\n    }\n    const requiredByteLength = view.getUint32(0, true);\n    assertDataLength(view.byteLength, requiredByteLength);\n    if (requiredByteLength === 4) {\n      return [requiredByteLength];\n    }\n    if (requiredByteLength < 8) {\n      dataLengthError(view.byteLength, \">8\");\n    }\n    const firstOffset = view.getUint32(4, true);\n    if (firstOffset % 4 !== 0 || firstOffset < 8) {\n      throw new Error(`Invalid first offset: ${firstOffset}`);\n    }\n    const itemCount = firstOffset / 4 - 1;\n    if (itemCount < expectedFieldCount) {\n      throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n    } else if (!compatible && itemCount > expectedFieldCount) {\n      throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n    }\n    if (requiredByteLength < firstOffset) {\n      throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n    }\n    const offsets = [];\n    for (let i = 0; i < itemCount; i++) {\n      const start = 4 + i * 4;\n      offsets.push(view.getUint32(start, true));\n    }\n    offsets.push(requiredByteLength);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      if (offsets[i] > offsets[i + 1]) {\n        throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n      }\n    }\n    return offsets;\n  }\n\n  function serializeTable(buffers) {\n    const itemCount = buffers.length;\n    let totalSize = 4 * (itemCount + 1);\n    const offsets = [];\n\n    for (let i = 0; i < itemCount; i++) {\n      offsets.push(totalSize);\n      totalSize += buffers[i].byteLength;\n    }\n\n    const buffer = new ArrayBuffer(totalSize);\n    const array = new Uint8Array(buffer);\n    const view = new DataView(buffer);\n\n    view.setUint32(0, totalSize, true);\n    for (let i = 0; i < itemCount; i++) {\n      view.setUint32(4 + i * 4, offsets[i], true);\n      array.set(new Uint8Array(buffers[i]), offsets[i]);\n    }\n    return buffer;\n  }\n\n  class Uint32Vec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * Uint32.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new Uint32(this.view.buffer.slice(4 + i * Uint32.size(), 4 + (i + 1) * Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeUint32Vec(value) {\n    const array = new Uint8Array(4 + Uint32.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeUint32(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * Uint32.size());\n    }\n    return array.buffer;\n  }\n\n  class BlockMerkleState {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getMerkleRoot() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getCount() {\n      return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, BlockMerkleState.size());\n      this.getMerkleRoot().validate(compatible);\n      this.getCount().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint64.size();\n    }\n  }\n\n  function SerializeBlockMerkleState(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n    array.set(new Uint8Array(SerializeUint64(value.count)), 0 + Byte32.size());\n    return array.buffer;\n  }\n\n  class AccountMerkleState {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getMerkleRoot() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getCount() {\n      return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, AccountMerkleState.size());\n      this.getMerkleRoot().validate(compatible);\n      this.getCount().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint32.size();\n    }\n  }\n\n  function SerializeAccountMerkleState(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n    array.set(new Uint8Array(SerializeUint32(value.count)), 0 + Byte32.size());\n    return array.buffer;\n  }\n\n  class GlobalStateV0 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getRollupConfigHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getAccount() {\n      return new AccountMerkleState(\n        this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n        { validate: false },\n      );\n    }\n\n    getBlock() {\n      return new BlockMerkleState(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getRevertedBlockRoot() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getTipBlockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getLastFinalizedBlockNumber() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n          0 +\n            Byte32.size() +\n            AccountMerkleState.size() +\n            BlockMerkleState.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getStatus() {\n      return this.view.getUint8(\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, GlobalStateV0.size());\n      this.getRollupConfigHash().validate(compatible);\n      this.getAccount().validate(compatible);\n      this.getBlock().validate(compatible);\n      this.getRevertedBlockRoot().validate(compatible);\n      this.getTipBlockHash().validate(compatible);\n      this.getLastFinalizedBlockNumber().validate(compatible);\n    }\n    static size() {\n      return (\n        0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        1\n      );\n    }\n  }\n\n  function SerializeGlobalStateV0(value) {\n    const array = new Uint8Array(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        1,\n    );\n    const view = new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n    array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n    array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n    array.set(\n      new Uint8Array(SerializeByte32(value.reverted_block_root)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.tip_block_hash)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n    );\n    view.setUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size(),\n      value.status,\n    );\n    return array.buffer;\n  }\n\n  class GlobalState {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getRollupConfigHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getAccount() {\n      return new AccountMerkleState(\n        this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n        { validate: false },\n      );\n    }\n\n    getBlock() {\n      return new BlockMerkleState(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getRevertedBlockRoot() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getTipBlockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getTipBlockTimestamp() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n          0 +\n            Byte32.size() +\n            AccountMerkleState.size() +\n            BlockMerkleState.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getLastFinalizedBlockNumber() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 +\n            Byte32.size() +\n            AccountMerkleState.size() +\n            BlockMerkleState.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size(),\n          0 +\n            Byte32.size() +\n            AccountMerkleState.size() +\n            BlockMerkleState.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size() +\n            Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getStatus() {\n      return this.view.getUint8(\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Uint64.size(),\n      );\n    }\n\n    getVersion() {\n      return this.view.getUint8(\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          1,\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, GlobalState.size());\n      this.getRollupConfigHash().validate(compatible);\n      this.getAccount().validate(compatible);\n      this.getBlock().validate(compatible);\n      this.getRevertedBlockRoot().validate(compatible);\n      this.getTipBlockHash().validate(compatible);\n      this.getTipBlockTimestamp().validate(compatible);\n      this.getLastFinalizedBlockNumber().validate(compatible);\n    }\n    static size() {\n      return (\n        0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        1 +\n        1\n      );\n    }\n  }\n\n  function SerializeGlobalState(value) {\n    const array = new Uint8Array(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        1 +\n        1,\n    );\n    const view = new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n    array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n    array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n    array.set(\n      new Uint8Array(SerializeByte32(value.reverted_block_root)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.tip_block_hash)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.tip_block_timestamp)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size(),\n    );\n    view.setUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size(),\n      value.status,\n    );\n    view.setUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        1,\n      value.version,\n    );\n    return array.buffer;\n  }\n\n  class RollupConfig {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[10], offsets[11]), { validate: false }).validate();\n      if (offsets[12] - offsets[11] !== 1) {\n        throw new Error(`Invalid offset for reward_burn_rate: ${offsets[11]} - ${offsets[12]}`);\n      }\n      new Byte32Vec(this.view.buffer.slice(offsets[12], offsets[13]), { validate: false }).validate();\n      new Byte32Vec(this.view.buffer.slice(offsets[13], offsets[14]), { validate: false }).validate();\n    }\n\n    getL1SudtScriptTypeHash() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getCustodianScriptTypeHash() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getDepositScriptTypeHash() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getWithdrawalScriptTypeHash() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getChallengeScriptTypeHash() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getStakeScriptTypeHash() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getL2SudtValidatorScriptTypeHash() {\n      const start = 28;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBurnLockHash() {\n      const start = 32;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRequiredStakingCapacity() {\n      const start = 36;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getChallengeMaturityBlocks() {\n      const start = 40;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getFinalityBlocks() {\n      const start = 44;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRewardBurnRate() {\n      const start = 48;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n    }\n\n    getAllowedEoaTypeHashes() {\n      const start = 52;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getAllowedContractTypeHashes() {\n      const start = 56;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRollupConfig(value) {\n    const buffers = [];\n    buffers.push(SerializeByte32(value.l1_sudt_script_type_hash));\n    buffers.push(SerializeByte32(value.custodian_script_type_hash));\n    buffers.push(SerializeByte32(value.deposit_script_type_hash));\n    buffers.push(SerializeByte32(value.withdrawal_script_type_hash));\n    buffers.push(SerializeByte32(value.challenge_script_type_hash));\n    buffers.push(SerializeByte32(value.stake_script_type_hash));\n    buffers.push(SerializeByte32(value.l2_sudt_validator_script_type_hash));\n    buffers.push(SerializeByte32(value.burn_lock_hash));\n    buffers.push(SerializeUint64(value.required_staking_capacity));\n    buffers.push(SerializeUint64(value.challenge_maturity_blocks));\n    buffers.push(SerializeUint64(value.finality_blocks));\n    const rewardBurnRateView = new DataView(new ArrayBuffer(1));\n    rewardBurnRateView.setUint8(0, value.reward_burn_rate);\n    buffers.push(rewardBurnRateView.buffer);\n    buffers.push(SerializeByte32Vec(value.allowed_eoa_type_hashes));\n    buffers.push(SerializeByte32Vec(value.allowed_contract_type_hashes));\n    return serializeTable(buffers);\n  }\n\n  class RawL2Transaction {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Uint32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    }\n\n    getFromId() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getToId() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getNonce() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getArgs() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRawL2Transaction(value) {\n    const buffers = [];\n    buffers.push(SerializeUint32(value.from_id));\n    buffers.push(SerializeUint32(value.to_id));\n    buffers.push(SerializeUint32(value.nonce));\n    buffers.push(SerializeBytes(value.args));\n    return serializeTable(buffers);\n  }\n\n  class L2Transaction {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getRaw() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getSignature() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeL2Transaction(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2Transaction(value.raw));\n    buffers.push(SerializeBytes(value.signature));\n    return serializeTable(buffers);\n  }\n\n  class L2TransactionVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new L2Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeL2TransactionVec(value) {\n    return serializeTable(value.map((item) => SerializeL2Transaction(item)));\n  }\n\n  class SubmitTransactions {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getTxWitnessRoot() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTxCount() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getPrevStateCheckpoint() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeSubmitTransactions(value) {\n    const buffers = [];\n    buffers.push(SerializeByte32(value.tx_witness_root));\n    buffers.push(SerializeUint32(value.tx_count));\n    buffers.push(SerializeByte32(value.prev_state_checkpoint));\n    return serializeTable(buffers);\n  }\n\n  class SubmitWithdrawals {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getWithdrawalWitnessRoot() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getWithdrawalCount() {\n      return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, SubmitWithdrawals.size());\n      this.getWithdrawalWitnessRoot().validate(compatible);\n      this.getWithdrawalCount().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint32.size();\n    }\n  }\n\n  function SerializeSubmitWithdrawals(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.withdrawal_witness_root)), 0);\n    array.set(new Uint8Array(SerializeUint32(value.withdrawal_count)), 0 + Byte32.size());\n    return array.buffer;\n  }\n\n  class RawL2Block {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new AccountMerkleState(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n      new AccountMerkleState(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n      new Byte32Vec(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n      new SubmitWithdrawals(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n      new SubmitTransactions(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n    }\n\n    getNumber() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockProducerId() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getParentBlockHash() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getStakeCellOwnerLockHash() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTimestamp() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getPrevAccount() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getPostAccount() {\n      const start = 28;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getStateCheckpointList() {\n      const start = 32;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getSubmitWithdrawals() {\n      const start = 36;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new SubmitWithdrawals(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getSubmitTransactions() {\n      const start = 40;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new SubmitTransactions(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRawL2Block(value) {\n    const buffers = [];\n    buffers.push(SerializeUint64(value.number));\n    buffers.push(SerializeUint32(value.block_producer_id));\n    buffers.push(SerializeByte32(value.parent_block_hash));\n    buffers.push(SerializeByte32(value.stake_cell_owner_lock_hash));\n    buffers.push(SerializeUint64(value.timestamp));\n    buffers.push(SerializeAccountMerkleState(value.prev_account));\n    buffers.push(SerializeAccountMerkleState(value.post_account));\n    buffers.push(SerializeByte32Vec(value.state_checkpoint_list));\n    buffers.push(SerializeSubmitWithdrawals(value.submit_withdrawals));\n    buffers.push(SerializeSubmitTransactions(value.submit_transactions));\n    return serializeTable(buffers);\n  }\n\n  class RawL2BlockVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new RawL2Block(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRawL2BlockVec(value) {\n    return serializeTable(value.map((item) => SerializeRawL2Block(item)));\n  }\n\n  class L2Block {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new L2TransactionVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new WithdrawalRequestVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    }\n\n    getRaw() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvState() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvStateProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTransactions() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new L2TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockProof() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getWithdrawals() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new WithdrawalRequestVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeL2Block(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2Block(value.raw));\n    buffers.push(SerializeKVPairVec(value.kv_state));\n    buffers.push(SerializeBytes(value.kv_state_proof));\n    buffers.push(SerializeL2TransactionVec(value.transactions));\n    buffers.push(SerializeBytes(value.block_proof));\n    buffers.push(SerializeWithdrawalRequestVec(value.withdrawals));\n    return serializeTable(buffers);\n  }\n\n  class DepositRequest {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Script(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    }\n\n    getCapacity() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getAmount() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getSudtScriptHash() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getScript() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeDepositRequest(value) {\n    const buffers = [];\n    buffers.push(SerializeUint64(value.capacity));\n    buffers.push(SerializeUint128(value.amount));\n    buffers.push(SerializeByte32(value.sudt_script_hash));\n    buffers.push(SerializeScript(value.script));\n    return serializeTable(buffers);\n  }\n\n  class DepositRequestVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new DepositRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new DepositRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeDepositRequestVec(value) {\n    return serializeTable(value.map((item) => SerializeDepositRequest(item)));\n  }\n\n  class RawWithdrawalRequest {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getNonce() {\n      return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n    }\n\n    getCapacity() {\n      return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n        validate: false,\n      });\n    }\n\n    getAmount() {\n      return new Uint128(\n        this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size()),\n        { validate: false },\n      );\n    }\n\n    getSudtScriptHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint64.size() + Uint128.size(),\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getAccountScriptHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getSellAmount() {\n      return new Uint128(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getSellCapacity() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getOwnerLockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size(),\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getPaymentLockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getFee() {\n      return new Fee(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Fee.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, RawWithdrawalRequest.size());\n      this.getNonce().validate(compatible);\n      this.getCapacity().validate(compatible);\n      this.getAmount().validate(compatible);\n      this.getSudtScriptHash().validate(compatible);\n      this.getAccountScriptHash().validate(compatible);\n      this.getSellAmount().validate(compatible);\n      this.getSellCapacity().validate(compatible);\n      this.getOwnerLockHash().validate(compatible);\n      this.getPaymentLockHash().validate(compatible);\n      this.getFee().validate(compatible);\n    }\n    static size() {\n      return (\n        0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Fee.size()\n      );\n    }\n  }\n\n  function SerializeRawWithdrawalRequest(value) {\n    const array = new Uint8Array(\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Fee.size(),\n    );\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint32(value.nonce)), 0);\n    array.set(new Uint8Array(SerializeUint64(value.capacity)), 0 + Uint32.size());\n    array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size() + Uint64.size());\n    array.set(\n      new Uint8Array(SerializeByte32(value.sudt_script_hash)),\n      0 + Uint32.size() + Uint64.size() + Uint128.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.account_script_hash)),\n      0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint128(value.sell_amount)),\n      0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.sell_capacity)),\n      0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.payment_lock_hash)),\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeFee(value.fee)),\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    return array.buffer;\n  }\n\n  function SerializeRawWithdrawalRequestV1(value) {\n    const array = new Uint8Array(\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size(),\n    );\n    const view = new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint32(value.nonce)), 0);\n    array.set(new Uint8Array(SerializeUint64(value.chain_id)), 0 + Uint32.size());\n    array.set(new Uint8Array(SerializeUint64(value.capacity)), 0 + Uint32.size() + Uint64.size());\n    array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size() + Uint64.size() + Uint64.size());\n    array.set(\n      new Uint8Array(SerializeByte32(value.sudt_script_hash)),\n      0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.account_script_hash)),\n      0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n      0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.fee)),\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    return array.buffer;\n  }\n\n  class WithdrawalRequestVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new WithdrawalRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeWithdrawalRequestVec(value) {\n    return serializeTable(value.map((item) => SerializeWithdrawalRequest(item)));\n  }\n\n  class WithdrawalRequest {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawWithdrawalRequest(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getRaw() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawWithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getSignature() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeWithdrawalRequest(value) {\n    const buffers = [];\n    buffers.push(SerializeRawWithdrawalRequest(value.raw));\n    buffers.push(SerializeBytes(value.signature));\n    return serializeTable(buffers);\n  }\n\n  class KVPair {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getK() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getV() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeKVPair(value) {\n    const buffers = [];\n    buffers.push(SerializeByte32(value.k));\n    buffers.push(SerializeByte32(value.v));\n    return serializeTable(buffers);\n  }\n\n  class KVPairVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new KVPair(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new KVPair(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeKVPairVec(value) {\n    return serializeTable(value.map((item) => SerializeKVPair(item)));\n  }\n\n  class BlockInfo {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getBlockProducerId() {\n      return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n    }\n\n    getNumber() {\n      return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n        validate: false,\n      });\n    }\n\n    getTimestamp() {\n      return new Uint64(\n        this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint64.size()),\n        { validate: false },\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, BlockInfo.size());\n      this.getBlockProducerId().validate(compatible);\n      this.getNumber().validate(compatible);\n      this.getTimestamp().validate(compatible);\n    }\n    static size() {\n      return 0 + Uint32.size() + Uint64.size() + Uint64.size();\n    }\n  }\n\n  function SerializeBlockInfo(value) {\n    const array = new Uint8Array(0 + Uint32.size() + Uint64.size() + Uint64.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint32(value.block_producer_id)), 0);\n    array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size());\n    array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint64.size());\n    return array.buffer;\n  }\n\n  class DepositLockArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getOwnerLockHash() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getLayer2Lock() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getCancelTimeout() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeDepositLockArgs(value) {\n    const buffers = [];\n    buffers.push(SerializeByte32(value.owner_lock_hash));\n    buffers.push(SerializeScript(value.layer2_lock));\n    buffers.push(SerializeUint64(value.cancel_timeout));\n    return serializeTable(buffers);\n  }\n\n  class CustodianLockArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new DepositLockArgs(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getDepositLockArgs() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new DepositLockArgs(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getDepositBlockHash() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getDepositBlockNumber() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCustodianLockArgs(value) {\n    const buffers = [];\n    buffers.push(SerializeDepositLockArgs(value.deposit_lock_args));\n    buffers.push(SerializeByte32(value.deposit_block_hash));\n    buffers.push(SerializeUint64(value.deposit_block_number));\n    return serializeTable(buffers);\n  }\n\n  class UnlockCustodianViaRevertWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getDepositLockHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, UnlockCustodianViaRevertWitness.size());\n      this.getDepositLockHash().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size();\n    }\n  }\n\n  function SerializeUnlockCustodianViaRevertWitness(value) {\n    const array = new Uint8Array(0 + Byte32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.deposit_lock_hash)), 0);\n    return array.buffer;\n  }\n\n  class WithdrawalLockArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getAccountScriptHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getWithdrawalBlockHash() {\n      return new Byte32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Byte32.size()), {\n        validate: false,\n      });\n    }\n\n    getWithdrawalBlockNumber() {\n      return new Uint64(\n        this.view.buffer.slice(0 + Byte32.size() + Byte32.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size()),\n        { validate: false },\n      );\n    }\n\n    getSudtScriptHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + Byte32.size() + Uint64.size(),\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getSellAmount() {\n      return new Uint128(\n        this.view.buffer.slice(\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getSellCapacity() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getOwnerLockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n          0 +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getPaymentLockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size(),\n          0 +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, WithdrawalLockArgs.size());\n      this.getAccountScriptHash().validate(compatible);\n      this.getWithdrawalBlockHash().validate(compatible);\n      this.getWithdrawalBlockNumber().validate(compatible);\n      this.getSudtScriptHash().validate(compatible);\n      this.getSellAmount().validate(compatible);\n      this.getSellCapacity().validate(compatible);\n      this.getOwnerLockHash().validate(compatible);\n      this.getPaymentLockHash().validate(compatible);\n    }\n    static size() {\n      return (\n        0 +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size()\n      );\n    }\n  }\n\n  function SerializeWithdrawalLockArgs(value) {\n    const array = new Uint8Array(\n      0 +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.account_script_hash)), 0);\n    array.set(new Uint8Array(SerializeByte32(value.withdrawal_block_hash)), 0 + Byte32.size());\n    array.set(new Uint8Array(SerializeUint64(value.withdrawal_block_number)), 0 + Byte32.size() + Byte32.size());\n    array.set(\n      new Uint8Array(SerializeByte32(value.sudt_script_hash)),\n      0 + Byte32.size() + Byte32.size() + Uint64.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint128(value.sell_amount)),\n      0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.sell_capacity)),\n      0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n      0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.payment_lock_hash)),\n      0 +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size(),\n    );\n    return array.buffer;\n  }\n\n  class UnlockWithdrawalWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        assertDataLength(this.view.byteLength, \">4\");\n      }\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 1:\n          new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 2:\n          new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    unionType() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return \"UnlockWithdrawalViaFinalize\";\n        case 1:\n          return \"UnlockWithdrawalViaRevert\";\n        case 2:\n          return \"UnlockWithdrawalViaTrade\";\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    value() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false });\n        case 1:\n          return new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false });\n        case 2:\n          return new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false });\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n  }\n\n  function SerializeUnlockWithdrawalWitness(value) {\n    switch (value.type) {\n      case \"UnlockWithdrawalViaFinalize\": {\n        const itemBuffer = SerializeUnlockWithdrawalViaFinalize(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 0, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"UnlockWithdrawalViaRevert\": {\n        const itemBuffer = SerializeUnlockWithdrawalViaRevert(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 1, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"UnlockWithdrawalViaTrade\": {\n        const itemBuffer = SerializeUnlockWithdrawalViaTrade(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 2, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      default:\n        throw new Error(`Invalid type: ${value.type}`);\n    }\n  }\n\n  class UnlockWithdrawalViaFinalize {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      verifyAndExtractOffsets(this.view, 0, true);\n    }\n  }\n\n  function SerializeUnlockWithdrawalViaFinalize(value) {\n    const buffers = [];\n    return serializeTable(buffers);\n  }\n\n  class UnlockWithdrawalViaRevert {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getCustodianLockHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, UnlockWithdrawalViaRevert.size());\n      this.getCustodianLockHash().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size();\n    }\n  }\n\n  function SerializeUnlockWithdrawalViaRevert(value) {\n    const array = new Uint8Array(0 + Byte32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.custodian_lock_hash)), 0);\n    return array.buffer;\n  }\n\n  class UnlockWithdrawalViaTrade {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    }\n\n    getOwnerLock() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeUnlockWithdrawalViaTrade(value) {\n    const buffers = [];\n    buffers.push(SerializeScript(value.owner_lock));\n    return serializeTable(buffers);\n  }\n\n  class StakeLockArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getOwnerLockHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getStakeBlockNumber() {\n      return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, StakeLockArgs.size());\n      this.getOwnerLockHash().validate(compatible);\n      this.getStakeBlockNumber().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint64.size();\n    }\n  }\n\n  function SerializeStakeLockArgs(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0);\n    array.set(new Uint8Array(SerializeUint64(value.stake_block_number)), 0 + Byte32.size());\n    return array.buffer;\n  }\n\n  class MetaContractArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        assertDataLength(this.view.byteLength, \">4\");\n      }\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          new CreateAccount(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    unionType() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return \"CreateAccount\";\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    value() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return new CreateAccount(this.view.buffer.slice(4), { validate: false });\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n  }\n\n  function SerializeMetaContractArgs(value) {\n    switch (value.type) {\n      case \"CreateAccount\": {\n        const itemBuffer = SerializeCreateAccount(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 0, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      default:\n        throw new Error(`Invalid type: ${value.type}`);\n    }\n  }\n\n  class Fee {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getSudtId() {\n      return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n    }\n\n    getAmount() {\n      return new Uint128(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint128.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, Fee.size());\n      this.getSudtId().validate(compatible);\n      this.getAmount().validate(compatible);\n    }\n    static size() {\n      return 0 + Uint32.size() + Uint128.size();\n    }\n  }\n\n  function SerializeFee(value) {\n    const array = new Uint8Array(0 + Uint32.size() + Uint128.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint32(value.sudt_id)), 0);\n    array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size());\n    return array.buffer;\n  }\n\n  class CreateAccount {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Fee(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getScript() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getFee() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Fee(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCreateAccount(value) {\n    const buffers = [];\n    buffers.push(SerializeScript(value.script));\n    buffers.push(SerializeFee(value.fee));\n    return serializeTable(buffers);\n  }\n\n  class SUDTArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        assertDataLength(this.view.byteLength, \">4\");\n      }\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          new SUDTQuery(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 1:\n          new SUDTTransfer(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    unionType() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return \"SUDTQuery\";\n        case 1:\n          return \"SUDTTransfer\";\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    value() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return new SUDTQuery(this.view.buffer.slice(4), { validate: false });\n        case 1:\n          return new SUDTTransfer(this.view.buffer.slice(4), { validate: false });\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n  }\n\n  function SerializeSUDTArgs(value) {\n    switch (value.type) {\n      case \"SUDTQuery\": {\n        const itemBuffer = SerializeSUDTQuery(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 0, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"SUDTTransfer\": {\n        const itemBuffer = SerializeSUDTTransfer(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 1, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      default:\n        throw new Error(`Invalid type: ${value.type}`);\n    }\n  }\n\n  class SUDTQuery {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    }\n\n    getShortAddress() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeSUDTQuery(value) {\n    const buffers = [];\n    buffers.push(SerializeBytes(value.short_address));\n    return serializeTable(buffers);\n  }\n\n  class SUDTTransfer {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Uint128(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getTo() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getAmount() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getFee() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeSUDTTransfer(value) {\n    const buffers = [];\n    buffers.push(SerializeBytes(value.to));\n    buffers.push(SerializeUint128(value.amount));\n    buffers.push(SerializeUint128(value.fee));\n    return serializeTable(buffers);\n  }\n\n  class ChallengeTarget {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getBlockHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getTargetIndex() {\n      return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    getTargetType() {\n      return this.view.getUint8(0 + Byte32.size() + Uint32.size());\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, ChallengeTarget.size());\n      this.getBlockHash().validate(compatible);\n      this.getTargetIndex().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint32.size() + 1;\n    }\n  }\n\n  function SerializeChallengeTarget(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint32.size() + 1);\n    const view = new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.block_hash)), 0);\n    array.set(new Uint8Array(SerializeUint32(value.target_index)), 0 + Byte32.size());\n    view.setUint8(0 + Byte32.size() + Uint32.size(), value.target_type);\n    return array.buffer;\n  }\n\n  class ChallengeLockArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new ChallengeTarget(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getTarget() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new ChallengeTarget(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRewardsReceiverLock() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeChallengeLockArgs(value) {\n    const buffers = [];\n    buffers.push(SerializeChallengeTarget(value.target));\n    buffers.push(SerializeScript(value.rewards_receiver_lock));\n    return serializeTable(buffers);\n  }\n\n  class ChallengeWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getRawL2Block() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockProof() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeChallengeWitness(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2Block(value.raw_l2block));\n    buffers.push(SerializeBytes(value.block_proof));\n    return serializeTable(buffers);\n  }\n\n  class ScriptVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeScriptVec(value) {\n    return serializeTable(value.map((item) => SerializeScript(item)));\n  }\n\n  class BlockHashEntry {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getNumber() {\n      return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n    }\n\n    getHash() {\n      return new Byte32(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + Byte32.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, BlockHashEntry.size());\n      this.getNumber().validate(compatible);\n      this.getHash().validate(compatible);\n    }\n    static size() {\n      return 0 + Uint64.size() + Byte32.size();\n    }\n  }\n\n  function SerializeBlockHashEntry(value) {\n    const array = new Uint8Array(0 + Uint64.size() + Byte32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint64(value.number)), 0);\n    array.set(new Uint8Array(SerializeByte32(value.hash)), 0 + Uint64.size());\n    return array.buffer;\n  }\n\n  class BlockHashEntryVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * BlockHashEntry.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new BlockHashEntry(\n        this.view.buffer.slice(4 + i * BlockHashEntry.size(), 4 + (i + 1) * BlockHashEntry.size()),\n        { validate: false },\n      );\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeBlockHashEntryVec(value) {\n    const array = new Uint8Array(4 + BlockHashEntry.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeBlockHashEntry(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * BlockHashEntry.size());\n    }\n    return array.buffer;\n  }\n\n  class VerifyTransactionContext {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new BytesVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new ScriptVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new BlockHashEntryVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    }\n\n    getAccountCount() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvState() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getLoadData() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getScripts() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getReturnDataHash() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockHashes() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new BlockHashEntryVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeVerifyTransactionContext(value) {\n    const buffers = [];\n    buffers.push(SerializeUint32(value.account_count));\n    buffers.push(SerializeKVPairVec(value.kv_state));\n    buffers.push(SerializeBytesVec(value.load_data));\n    buffers.push(SerializeScriptVec(value.scripts));\n    buffers.push(SerializeByte32(value.return_data_hash));\n    buffers.push(SerializeBlockHashEntryVec(value.block_hashes));\n    return serializeTable(buffers);\n  }\n\n  class CKBMerkleProof {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint32Vec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getIndices() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getLemmas() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCKBMerkleProof(value) {\n    const buffers = [];\n    buffers.push(SerializeUint32Vec(value.indices));\n    buffers.push(SerializeByte32Vec(value.lemmas));\n    return serializeTable(buffers);\n  }\n\n  class VerifyTransactionWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new L2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new RawL2Block(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new VerifyTransactionContext(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    }\n\n    getL2Tx() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRawL2Block() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTxProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvStateProof() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockHashesProof() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getContext() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new VerifyTransactionContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeVerifyTransactionWitness(value) {\n    const buffers = [];\n    buffers.push(SerializeL2Transaction(value.l2tx));\n    buffers.push(SerializeRawL2Block(value.raw_l2block));\n    buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n    buffers.push(SerializeBytes(value.kv_state_proof));\n    buffers.push(SerializeBytes(value.block_hashes_proof));\n    buffers.push(SerializeVerifyTransactionContext(value.context));\n    return serializeTable(buffers);\n  }\n\n  class VerifyTransactionSignatureContext {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new ScriptVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getAccountCount() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvState() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getScripts() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeVerifyTransactionSignatureContext(value) {\n    const buffers = [];\n    buffers.push(SerializeUint32(value.account_count));\n    buffers.push(SerializeKVPairVec(value.kv_state));\n    buffers.push(SerializeScriptVec(value.scripts));\n    return serializeTable(buffers);\n  }\n\n  class VerifyTransactionSignatureWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new L2Transaction(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new VerifyTransactionSignatureContext(this.view.buffer.slice(offsets[4], offsets[5]), {\n        validate: false,\n      }).validate();\n    }\n\n    getRawL2Block() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getL2Tx() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTxProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvStateProof() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getContext() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new VerifyTransactionSignatureContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeVerifyTransactionSignatureWitness(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2Block(value.raw_l2block));\n    buffers.push(SerializeL2Transaction(value.l2tx));\n    buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n    buffers.push(SerializeBytes(value.kv_state_proof));\n    buffers.push(SerializeVerifyTransactionSignatureContext(value.context));\n    return serializeTable(buffers);\n  }\n\n  class VerifyWithdrawalWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new WithdrawalRequest(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getRawL2Block() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getWithdrawalRequest() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getWithdrawalProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeVerifyWithdrawalWitness(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2Block(value.raw_l2block));\n    buffers.push(SerializeWithdrawalRequest(value.withdrawal_request));\n    buffers.push(SerializeCKBMerkleProof(value.withdrawal_proof));\n    return serializeTable(buffers);\n  }\n\n  class RollupSubmitBlock {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new L2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getBlock() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new L2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRevertedBlockHashes() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRevertedBlockProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRollupSubmitBlock(value) {\n    const buffers = [];\n    buffers.push(SerializeL2Block(value.block));\n    buffers.push(SerializeByte32Vec(value.reverted_block_hashes));\n    buffers.push(SerializeBytes(value.reverted_block_proof));\n    return serializeTable(buffers);\n  }\n\n  class RollupEnterChallenge {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new ChallengeWitness(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    }\n\n    getWitness() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new ChallengeWitness(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRollupEnterChallenge(value) {\n    const buffers = [];\n    buffers.push(SerializeChallengeWitness(value.witness));\n    return serializeTable(buffers);\n  }\n\n  class RollupCancelChallenge {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      verifyAndExtractOffsets(this.view, 0, true);\n    }\n  }\n\n  function SerializeRollupCancelChallenge(value) {\n    const buffers = [];\n    return serializeTable(buffers);\n  }\n\n  class RollupRevert {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2BlockVec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new RawL2Block(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    }\n\n    getRevertedBlocks() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2BlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockProof() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRevertedBlockProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getNewTipBlock() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRollupRevert(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2BlockVec(value.reverted_blocks));\n    buffers.push(SerializeBytes(value.block_proof));\n    buffers.push(SerializeBytes(value.reverted_block_proof));\n    buffers.push(SerializeRawL2Block(value.new_tip_block));\n    return serializeTable(buffers);\n  }\n\n  class RollupAction {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        assertDataLength(this.view.byteLength, \">4\");\n      }\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 1:\n          new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 2:\n          new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 3:\n          new RollupRevert(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    unionType() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return \"RollupSubmitBlock\";\n        case 1:\n          return \"RollupEnterChallenge\";\n        case 2:\n          return \"RollupCancelChallenge\";\n        case 3:\n          return \"RollupRevert\";\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    value() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false });\n        case 1:\n          return new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false });\n        case 2:\n          return new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false });\n        case 3:\n          return new RollupRevert(this.view.buffer.slice(4), { validate: false });\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n  }\n\n  function SerializeRollupAction(value) {\n    switch (value.type) {\n      case \"RollupSubmitBlock\": {\n        const itemBuffer = SerializeRollupSubmitBlock(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 0, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"RollupEnterChallenge\": {\n        const itemBuffer = SerializeRollupEnterChallenge(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 1, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"RollupCancelChallenge\": {\n        const itemBuffer = SerializeRollupCancelChallenge(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 2, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"RollupRevert\": {\n        const itemBuffer = SerializeRollupRevert(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 3, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      default:\n        throw new Error(`Invalid type: ${value.type}`);\n    }\n  }\n\n  class Uint16 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 2);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    toBigEndianUint16() {\n      return this.view.getUint16(0, false);\n    }\n\n    toLittleEndianUint16() {\n      return this.view.getUint16(0, true);\n    }\n\n    static size() {\n      return 2;\n    }\n  }\n\n  function SerializeUint16(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 2);\n    return buffer;\n  }\n\n  class Uint32 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 4);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    toBigEndianUint32() {\n      return this.view.getUint32(0, false);\n    }\n\n    toLittleEndianUint32() {\n      return this.view.getUint32(0, true);\n    }\n\n    static size() {\n      return 4;\n    }\n  }\n\n  function SerializeUint32(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 4);\n    return buffer;\n  }\n\n  class Uint64 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 8);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    toBigEndianBigUint64() {\n      return this.view.getBigUint64(0, false);\n    }\n\n    toLittleEndianBigUint64() {\n      return this.view.getBigUint64(0, true);\n    }\n\n    static size() {\n      return 8;\n    }\n  }\n\n  function SerializeUint64(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 8);\n    return buffer;\n  }\n\n  class Uint128 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 16);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    static size() {\n      return 16;\n    }\n  }\n\n  function SerializeUint128(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 16);\n    return buffer;\n  }\n\n  class Byte32 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 32);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    static size() {\n      return 32;\n    }\n  }\n\n  function SerializeByte32(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 32);\n    return buffer;\n  }\n\n  class Uint256 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 32);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    static size() {\n      return 32;\n    }\n  }\n\n  function SerializeUint256(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 32);\n    return buffer;\n  }\n\n  class Bytes {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n    }\n\n    raw() {\n      return this.view.buffer.slice(4);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(4 + i);\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeBytes(value) {\n    const item = assertArrayBuffer(value);\n    const array = new Uint8Array(4 + item.byteLength);\n    new DataView(array.buffer).setUint32(0, item.byteLength, true);\n    array.set(new Uint8Array(item), 4);\n    return array.buffer;\n  }\n\n  class BytesOpt {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.hasValue()) {\n        this.value().validate(compatible);\n      }\n    }\n\n    value() {\n      return new Bytes(this.view.buffer, { validate: false });\n    }\n\n    hasValue() {\n      return this.view.byteLength > 0;\n    }\n  }\n\n  function SerializeBytesOpt(value) {\n    if (value) {\n      return SerializeBytes(value);\n    } else {\n      return new ArrayBuffer(0);\n    }\n  }\n\n  class BytesVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeBytesVec(value) {\n    return serializeTable(value.map((item) => SerializeBytes(item)));\n  }\n\n  class Byte32Vec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * Byte32.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {\n        validate: false,\n      });\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeByte32Vec(value) {\n    const array = new Uint8Array(4 + Byte32.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeByte32(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n    }\n    return array.buffer;\n  }\n\n  class ScriptOpt {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.hasValue()) {\n        this.value().validate(compatible);\n      }\n    }\n\n    value() {\n      return new Script(this.view.buffer, { validate: false });\n    }\n\n    hasValue() {\n      return this.view.byteLength > 0;\n    }\n  }\n\n  function SerializeScriptOpt(value) {\n    if (value) {\n      return SerializeScript(value);\n    } else {\n      return new ArrayBuffer(0);\n    }\n  }\n\n  class ProposalShortId {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 10);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    static size() {\n      return 10;\n    }\n  }\n\n  function SerializeProposalShortId(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 10);\n    return buffer;\n  }\n\n  class UncleBlockVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new UncleBlock(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeUncleBlockVec(value) {\n    return serializeTable(value.map((item) => SerializeUncleBlock(item)));\n  }\n\n  class TransactionVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeTransactionVec(value) {\n    return serializeTable(value.map((item) => SerializeTransaction(item)));\n  }\n\n  class ProposalShortIdVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new ProposalShortId(\n        this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()),\n        { validate: false },\n      );\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeProposalShortIdVec(value) {\n    const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeProposalShortId(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n    }\n    return array.buffer;\n  }\n\n  class CellDepVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * CellDep.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {\n        validate: false,\n      });\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeCellDepVec(value) {\n    const array = new Uint8Array(4 + CellDep.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeCellDep(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n    }\n    return array.buffer;\n  }\n\n  class CellInputVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * CellInput.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {\n        validate: false,\n      });\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeCellInputVec(value) {\n    const array = new Uint8Array(4 + CellInput.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeCellInput(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n    }\n    return array.buffer;\n  }\n\n  class CellOutputVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new CellOutput(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCellOutputVec(value) {\n    return serializeTable(value.map((item) => SerializeCellOutput(item)));\n  }\n\n  class Script {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      if (offsets[2] - offsets[1] !== 1) {\n        throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);\n      }\n      new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getCodeHash() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getHashType() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n    }\n\n    getArgs() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeScript(value) {\n    const buffers = [];\n    buffers.push(SerializeByte32(value.code_hash));\n    const hashTypeView = new DataView(new ArrayBuffer(1));\n    hashTypeView.setUint8(0, value.hash_type);\n    buffers.push(hashTypeView.buffer);\n    buffers.push(SerializeBytes(value.args));\n    return serializeTable(buffers);\n  }\n\n  class OutPoint {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getTxHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getIndex() {\n      return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, OutPoint.size());\n      this.getTxHash().validate(compatible);\n      this.getIndex().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint32.size();\n    }\n  }\n\n  function SerializeOutPoint(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n    array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n    return array.buffer;\n  }\n\n  class CellInput {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getSince() {\n      return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n    }\n\n    getPreviousOutput() {\n      return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, CellInput.size());\n      this.getSince().validate(compatible);\n      this.getPreviousOutput().validate(compatible);\n    }\n    static size() {\n      return 0 + Uint64.size() + OutPoint.size();\n    }\n  }\n\n  function SerializeCellInput(value) {\n    const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n    array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n    return array.buffer;\n  }\n\n  class CellOutput {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getCapacity() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getLock() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getType() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new ScriptOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCellOutput(value) {\n    const buffers = [];\n    buffers.push(SerializeUint64(value.capacity));\n    buffers.push(SerializeScript(value.lock));\n    buffers.push(SerializeScriptOpt(value.type_));\n    return serializeTable(buffers);\n  }\n\n  class CellDep {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getOutPoint() {\n      return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), { validate: false });\n    }\n\n    getDepType() {\n      return this.view.getUint8(0 + OutPoint.size());\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, CellDep.size());\n      this.getOutPoint().validate(compatible);\n    }\n    static size() {\n      return 0 + OutPoint.size() + 1;\n    }\n  }\n\n  function SerializeCellDep(value) {\n    const array = new Uint8Array(0 + OutPoint.size() + 1);\n    const view = new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n    view.setUint8(0 + OutPoint.size(), value.dep_type);\n    return array.buffer;\n  }\n\n  class RawTransaction {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    }\n\n    getVersion() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getCellDeps() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new CellDepVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getHeaderDeps() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getInputs() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new CellInputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getOutputs() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new CellOutputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getOutputsData() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRawTransaction(value) {\n    const buffers = [];\n    buffers.push(SerializeUint32(value.version));\n    buffers.push(SerializeCellDepVec(value.cell_deps));\n    buffers.push(SerializeByte32Vec(value.header_deps));\n    buffers.push(SerializeCellInputVec(value.inputs));\n    buffers.push(SerializeCellOutputVec(value.outputs));\n    buffers.push(SerializeBytesVec(value.outputs_data));\n    return serializeTable(buffers);\n  }\n\n  class Transaction {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getRaw() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawTransaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getWitnesses() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeTransaction(value) {\n    const buffers = [];\n    buffers.push(SerializeRawTransaction(value.raw));\n    buffers.push(SerializeBytesVec(value.witnesses));\n    return serializeTable(buffers);\n  }\n\n  class RawHeader {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getVersion() {\n      return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n    }\n\n    getCompactTarget() {\n      return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    getTimestamp() {\n      return new Uint64(\n        this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()),\n        { validate: false },\n      );\n    }\n\n    getNumber() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint32.size() + Uint64.size(),\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getEpoch() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getParentHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getTransactionsRoot() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getProposalsHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getExtraHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getDao() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, RawHeader.size());\n      this.getVersion().validate(compatible);\n      this.getCompactTarget().validate(compatible);\n      this.getTimestamp().validate(compatible);\n      this.getNumber().validate(compatible);\n      this.getEpoch().validate(compatible);\n      this.getParentHash().validate(compatible);\n      this.getTransactionsRoot().validate(compatible);\n      this.getProposalsHash().validate(compatible);\n      this.getExtraHash().validate(compatible);\n      this.getDao().validate(compatible);\n    }\n    static size() {\n      return (\n        0 +\n        Uint32.size() +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size()\n      );\n    }\n  }\n\n  function SerializeRawHeader(value) {\n    const array = new Uint8Array(\n      0 +\n        Uint32.size() +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n    array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n    array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n    array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n    array.set(\n      new Uint8Array(SerializeUint64(value.epoch)),\n      0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.parent_hash)),\n      0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.transactions_root)),\n      0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.proposals_hash)),\n      0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.extra_hash)),\n      0 +\n        Uint32.size() +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.dao)),\n      0 +\n        Uint32.size() +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    return array.buffer;\n  }\n\n  class Header {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getRaw() {\n      return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), { validate: false });\n    }\n\n    getNonce() {\n      return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, Header.size());\n      this.getRaw().validate(compatible);\n      this.getNonce().validate(compatible);\n    }\n    static size() {\n      return 0 + RawHeader.size() + Uint128.size();\n    }\n  }\n\n  function SerializeHeader(value) {\n    const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n    array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n    return array.buffer;\n  }\n\n  class UncleBlock {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getHeader() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getProposals() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeUncleBlock(value) {\n    const buffers = [];\n    buffers.push(SerializeHeader(value.header));\n    buffers.push(SerializeProposalShortIdVec(value.proposals));\n    return serializeTable(buffers);\n  }\n\n  class Block {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    }\n\n    getHeader() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getUncles() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTransactions() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getProposals() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeBlock(value) {\n    const buffers = [];\n    buffers.push(SerializeHeader(value.header));\n    buffers.push(SerializeUncleBlockVec(value.uncles));\n    buffers.push(SerializeTransactionVec(value.transactions));\n    buffers.push(SerializeProposalShortIdVec(value.proposals));\n    return serializeTable(buffers);\n  }\n\n  class BlockV1 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    }\n\n    getHeader() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getUncles() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTransactions() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getProposals() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getExtension() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeBlockV1(value) {\n    const buffers = [];\n    buffers.push(SerializeHeader(value.header));\n    buffers.push(SerializeUncleBlockVec(value.uncles));\n    buffers.push(SerializeTransactionVec(value.transactions));\n    buffers.push(SerializeProposalShortIdVec(value.proposals));\n    buffers.push(SerializeBytes(value.extension));\n    return serializeTable(buffers);\n  }\n\n  class CellbaseWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getLock() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getMessage() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCellbaseWitness(value) {\n    const buffers = [];\n    buffers.push(SerializeScript(value.lock));\n    buffers.push(SerializeBytes(value.message));\n    return serializeTable(buffers);\n  }\n\n  class WitnessArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getLock() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getInputType() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getOutputType() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeWitnessArgs(value) {\n    const buffers = [];\n    buffers.push(SerializeBytesOpt(value.lock));\n    buffers.push(SerializeBytesOpt(value.input_type));\n    buffers.push(SerializeBytesOpt(value.output_type));\n    return serializeTable(buffers);\n  }\n\n  exports.AccountMerkleState = AccountMerkleState;\n  exports.Block = Block;\n  exports.BlockHashEntry = BlockHashEntry;\n  exports.BlockHashEntryVec = BlockHashEntryVec;\n  exports.BlockInfo = BlockInfo;\n  exports.BlockMerkleState = BlockMerkleState;\n  exports.BlockV1 = BlockV1;\n  exports.Byte32 = Byte32;\n  exports.Byte32Vec = Byte32Vec;\n  exports.Bytes = Bytes;\n  exports.BytesOpt = BytesOpt;\n  exports.BytesVec = BytesVec;\n  exports.CKBMerkleProof = CKBMerkleProof;\n  exports.CellDep = CellDep;\n  exports.CellDepVec = CellDepVec;\n  exports.CellInput = CellInput;\n  exports.CellInputVec = CellInputVec;\n  exports.CellOutput = CellOutput;\n  exports.CellOutputVec = CellOutputVec;\n  exports.CellbaseWitness = CellbaseWitness;\n  exports.ChallengeLockArgs = ChallengeLockArgs;\n  exports.ChallengeTarget = ChallengeTarget;\n  exports.ChallengeWitness = ChallengeWitness;\n  exports.CreateAccount = CreateAccount;\n  exports.CustodianLockArgs = CustodianLockArgs;\n  exports.DepositLockArgs = DepositLockArgs;\n  exports.DepositRequest = DepositRequest;\n  exports.DepositRequestVec = DepositRequestVec;\n  exports.Fee = Fee;\n  exports.GlobalState = GlobalState;\n  exports.GlobalStateV0 = GlobalStateV0;\n  exports.Header = Header;\n  exports.KVPair = KVPair;\n  exports.KVPairVec = KVPairVec;\n  exports.L2Block = L2Block;\n  exports.L2Transaction = L2Transaction;\n  exports.L2TransactionVec = L2TransactionVec;\n  exports.MetaContractArgs = MetaContractArgs;\n  exports.OutPoint = OutPoint;\n  exports.ProposalShortId = ProposalShortId;\n  exports.ProposalShortIdVec = ProposalShortIdVec;\n  exports.RawHeader = RawHeader;\n  exports.RawL2Block = RawL2Block;\n  exports.RawL2BlockVec = RawL2BlockVec;\n  exports.RawL2Transaction = RawL2Transaction;\n  exports.RawTransaction = RawTransaction;\n  exports.RawWithdrawalRequest = RawWithdrawalRequest;\n  exports.RollupAction = RollupAction;\n  exports.RollupCancelChallenge = RollupCancelChallenge;\n  exports.RollupConfig = RollupConfig;\n  exports.RollupEnterChallenge = RollupEnterChallenge;\n  exports.RollupRevert = RollupRevert;\n  exports.RollupSubmitBlock = RollupSubmitBlock;\n  exports.SUDTArgs = SUDTArgs;\n  exports.SUDTQuery = SUDTQuery;\n  exports.SUDTTransfer = SUDTTransfer;\n  exports.Script = Script;\n  exports.ScriptOpt = ScriptOpt;\n  exports.ScriptVec = ScriptVec;\n  exports.SerializeAccountMerkleState = SerializeAccountMerkleState;\n  exports.SerializeBlock = SerializeBlock;\n  exports.SerializeBlockHashEntry = SerializeBlockHashEntry;\n  exports.SerializeBlockHashEntryVec = SerializeBlockHashEntryVec;\n  exports.SerializeBlockInfo = SerializeBlockInfo;\n  exports.SerializeBlockMerkleState = SerializeBlockMerkleState;\n  exports.SerializeBlockV1 = SerializeBlockV1;\n  exports.SerializeByte32 = SerializeByte32;\n  exports.SerializeByte32Vec = SerializeByte32Vec;\n  exports.SerializeBytes = SerializeBytes;\n  exports.SerializeBytesOpt = SerializeBytesOpt;\n  exports.SerializeBytesVec = SerializeBytesVec;\n  exports.SerializeCKBMerkleProof = SerializeCKBMerkleProof;\n  exports.SerializeCellDep = SerializeCellDep;\n  exports.SerializeCellDepVec = SerializeCellDepVec;\n  exports.SerializeCellInput = SerializeCellInput;\n  exports.SerializeCellInputVec = SerializeCellInputVec;\n  exports.SerializeCellOutput = SerializeCellOutput;\n  exports.SerializeCellOutputVec = SerializeCellOutputVec;\n  exports.SerializeCellbaseWitness = SerializeCellbaseWitness;\n  exports.SerializeChallengeLockArgs = SerializeChallengeLockArgs;\n  exports.SerializeChallengeTarget = SerializeChallengeTarget;\n  exports.SerializeChallengeWitness = SerializeChallengeWitness;\n  exports.SerializeCreateAccount = SerializeCreateAccount;\n  exports.SerializeCustodianLockArgs = SerializeCustodianLockArgs;\n  exports.SerializeDepositLockArgs = SerializeDepositLockArgs;\n  exports.SerializeDepositRequest = SerializeDepositRequest;\n  exports.SerializeDepositRequestVec = SerializeDepositRequestVec;\n  exports.SerializeFee = SerializeFee;\n  exports.SerializeGlobalState = SerializeGlobalState;\n  exports.SerializeGlobalStateV0 = SerializeGlobalStateV0;\n  exports.SerializeHeader = SerializeHeader;\n  exports.SerializeKVPair = SerializeKVPair;\n  exports.SerializeKVPairVec = SerializeKVPairVec;\n  exports.SerializeL2Block = SerializeL2Block;\n  exports.SerializeL2Transaction = SerializeL2Transaction;\n  exports.SerializeL2TransactionVec = SerializeL2TransactionVec;\n  exports.SerializeMetaContractArgs = SerializeMetaContractArgs;\n  exports.SerializeOutPoint = SerializeOutPoint;\n  exports.SerializeProposalShortId = SerializeProposalShortId;\n  exports.SerializeProposalShortIdVec = SerializeProposalShortIdVec;\n  exports.SerializeRawHeader = SerializeRawHeader;\n  exports.SerializeRawL2Block = SerializeRawL2Block;\n  exports.SerializeRawL2BlockVec = SerializeRawL2BlockVec;\n  exports.SerializeRawL2Transaction = SerializeRawL2Transaction;\n  exports.SerializeRawTransaction = SerializeRawTransaction;\n  exports.SerializeRawWithdrawalRequest = SerializeRawWithdrawalRequest;\n  exports.SerializeRollupAction = SerializeRollupAction;\n  exports.SerializeRollupCancelChallenge = SerializeRollupCancelChallenge;\n  exports.SerializeRollupConfig = SerializeRollupConfig;\n  exports.SerializeRollupEnterChallenge = SerializeRollupEnterChallenge;\n  exports.SerializeRollupRevert = SerializeRollupRevert;\n  exports.SerializeRollupSubmitBlock = SerializeRollupSubmitBlock;\n  exports.SerializeSUDTArgs = SerializeSUDTArgs;\n  exports.SerializeSUDTQuery = SerializeSUDTQuery;\n  exports.SerializeSUDTTransfer = SerializeSUDTTransfer;\n  exports.SerializeScript = SerializeScript;\n  exports.SerializeScriptOpt = SerializeScriptOpt;\n  exports.SerializeScriptVec = SerializeScriptVec;\n  exports.SerializeStakeLockArgs = SerializeStakeLockArgs;\n  exports.SerializeSubmitTransactions = SerializeSubmitTransactions;\n  exports.SerializeSubmitWithdrawals = SerializeSubmitWithdrawals;\n  exports.SerializeTransaction = SerializeTransaction;\n  exports.SerializeTransactionVec = SerializeTransactionVec;\n  exports.SerializeUint128 = SerializeUint128;\n  exports.SerializeUint16 = SerializeUint16;\n  exports.SerializeUint256 = SerializeUint256;\n  exports.SerializeUint32 = SerializeUint32;\n  exports.SerializeUint32Vec = SerializeUint32Vec;\n  exports.SerializeUint64 = SerializeUint64;\n  exports.SerializeUncleBlock = SerializeUncleBlock;\n  exports.SerializeUncleBlockVec = SerializeUncleBlockVec;\n  exports.SerializeUnlockCustodianViaRevertWitness = SerializeUnlockCustodianViaRevertWitness;\n  exports.SerializeUnlockWithdrawalViaFinalize = SerializeUnlockWithdrawalViaFinalize;\n  exports.SerializeUnlockWithdrawalViaRevert = SerializeUnlockWithdrawalViaRevert;\n  exports.SerializeUnlockWithdrawalViaTrade = SerializeUnlockWithdrawalViaTrade;\n  exports.SerializeUnlockWithdrawalWitness = SerializeUnlockWithdrawalWitness;\n  exports.SerializeVerifyTransactionContext = SerializeVerifyTransactionContext;\n  exports.SerializeVerifyTransactionSignatureContext = SerializeVerifyTransactionSignatureContext;\n  exports.SerializeVerifyTransactionSignatureWitness = SerializeVerifyTransactionSignatureWitness;\n  exports.SerializeVerifyTransactionWitness = SerializeVerifyTransactionWitness;\n  exports.SerializeVerifyWithdrawalWitness = SerializeVerifyWithdrawalWitness;\n  exports.SerializeWithdrawalLockArgs = SerializeWithdrawalLockArgs;\n  exports.SerializeWithdrawalRequest = SerializeWithdrawalRequest;\n  exports.SerializeWithdrawalRequestVec = SerializeWithdrawalRequestVec;\n  exports.SerializeWitnessArgs = SerializeWitnessArgs;\n  exports.StakeLockArgs = StakeLockArgs;\n  exports.SubmitTransactions = SubmitTransactions;\n  exports.SubmitWithdrawals = SubmitWithdrawals;\n  exports.Transaction = Transaction;\n  exports.TransactionVec = TransactionVec;\n  exports.Uint128 = Uint128;\n  exports.Uint16 = Uint16;\n  exports.Uint256 = Uint256;\n  exports.Uint32 = Uint32;\n  exports.Uint32Vec = Uint32Vec;\n  exports.Uint64 = Uint64;\n  exports.UncleBlock = UncleBlock;\n  exports.UncleBlockVec = UncleBlockVec;\n  exports.UnlockCustodianViaRevertWitness = UnlockCustodianViaRevertWitness;\n  exports.UnlockWithdrawalViaFinalize = UnlockWithdrawalViaFinalize;\n  exports.UnlockWithdrawalViaRevert = UnlockWithdrawalViaRevert;\n  exports.UnlockWithdrawalViaTrade = UnlockWithdrawalViaTrade;\n  exports.UnlockWithdrawalWitness = UnlockWithdrawalWitness;\n  exports.VerifyTransactionContext = VerifyTransactionContext;\n  exports.VerifyTransactionSignatureContext = VerifyTransactionSignatureContext;\n  exports.VerifyTransactionSignatureWitness = VerifyTransactionSignatureWitness;\n  exports.VerifyTransactionWitness = VerifyTransactionWitness;\n  exports.VerifyWithdrawalWitness = VerifyWithdrawalWitness;\n  exports.WithdrawalLockArgs = WithdrawalLockArgs;\n  exports.WithdrawalRequest = WithdrawalRequest;\n  exports.WithdrawalRequestVec = WithdrawalRequestVec;\n  exports.WitnessArgs = WitnessArgs;\n\n  Object.defineProperty(exports, \"__esModule\", { value: true });\n});\n"],"sourceRoot":""}