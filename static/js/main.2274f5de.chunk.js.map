{"version":3,"sources":["light-godwoken/godwoken-v1/src/schema_v1/index.js","light-godwoken/godwoken-v1/src/types.ts","light-godwoken/godwoken-v1/src/index.ts","light-godwoken/godwoken-v1/src/normalizer.ts","light-godwoken/constants/localLayer2Config.ts","light-godwoken/constants/index.ts","light-godwoken/constants/providerConfig.ts","light-godwoken/godwoken/normalizer.ts","light-godwoken/schemas/index.esm.js","light-godwoken/godwoken/godwoken.ts","light-godwoken/omni-lock/omni.js","light-godwoken/constants/layer1ConfigUtils.ts","light-godwoken/lightGodwokenProvider.ts","light-godwoken/constants/sudtErc20ProxyAbi.ts","light-godwoken/lightGodwoken.ts","light-godwoken/constants/tokens.ts","light-godwoken/LightGodwokenV0.ts","light-godwoken/lightGodwokenType.ts","light-godwoken/LightGodwokenV1.ts","contexts/LightGodwokenContext.tsx","hooks/useLightGodwoken.ts","utils/formatTokenAmount.ts","views/NumericalInput.tsx","views/CKBInputPanel.tsx","components/Address/index.tsx","components/ConnectButton/index.tsx","views/PageHeader.tsx","views/Page.tsx","views/Deposit.tsx","App.js","reportWebVitals.js","index.js","light-godwoken/godwoken-v1/schemas/index.js"],"names":["dataLengthError","actual","required","Error","assertDataLength","assertArrayBuffer","reader","Object","toArrayBuffer","Function","ArrayBuffer","serializeTable","buffers","itemCount","length","totalSize","offsets","i","push","byteLength","buffer","array","Uint8Array","view","DataView","setUint32","set","SerializeWithdrawalRequest","value","Uint32","size","Uint64","Uint128","Byte32","SerializeUint32","nonce","SerializeUint64","chain_id","capacity","SerializeUint128","amount","SerializeByte32","sudt_script_hash","account_script_hash","owner_lock_hash","fee","SerializeRawWithdrawalRequestV1","raw","SerializeBytes","signature","SerializeWithdrawalRequestExtra","request","SerializeScript","owner_lock","constructor","validate","this","indexAt","getUint8","toBigEndianUint32","getUint32","toLittleEndianUint32","item","code_hash","hashTypeView","setUint8","hash_type","args","Status","Godwoken","url","rpc","RPC","result","console","debug","method_name","name","l2tx","data","Reader","core","NormalizeL2Transaction","serializeJson","rpcCall","_send","rawL2Tx","hex","NormalizeRawL2Transaction","NormalizeWithdrawalRequest","reqExtra","normalizer","address","sudt_id","sudt_id_hex","toString","balance","BigInt","account_id","getScriptHash","slice","getBalance","key","account_id_hex","script_hash","id","undefined","parseInt","data_hash","l2_tx_hash","normalizeHexNumber","debugPath","intValue","start","substr","normalizeRawData","normalizeObject","obj","keys","f","entries","toNormalize","normalize","rawL2Transaction","from_id","to_id","l2Transaction","NormalizeRawWithdrawalRequest","raw_request","sell_amount","sell_capacity","payment_lock_hash","NormalizeFee","NormalizeRawWithdrawalRequestV1","raw_request_v1","NormalizeWithdrawalRequestV1","request_v1","NormalizeWithdrawalReqExtra","withdrawalReqExtra","normalizers","NormalizeScript","NormalizeCreateAccount","createAccount","script","SCRIPTS","eth_account_lock","script_type_hash","cell_dep","out_point","tx_hash","index","dep_type","deposit_lock","polyjuice_generator","l2_sudt_validator","meta_contract_validator","custodian_lock","l2_sudt_generator","state_validator_lock","challenge_lock","meta_contract_generator","always_success","state_validator","polyjuice_validator","poa_state","stake_lock","withdrawal_lock","tron_account_lock","ROLLUP_CONFIG","rollup_type_hash","rollup_type_script","genesis","timestamp","meta_contract_validator_type_hash","rollup_config","l1_sudt_script_type_hash","custodian_script_type_hash","deposit_script_type_hash","withdrawal_script_type_hash","challenge_script_type_hash","stake_script_type_hash","l2_sudt_validator_script_type_hash","burn_lock_hash","required_staking_capacity","challenge_maturity_blocks","finality_blocks","reward_burn_rate","allowed_eoa_type_hashes","allowed_contract_type_hashes","secp_data_dep","rpc_client","indexer_url","ckb_url","SCRIPTS_V0","ROLLUP_CONFIG_V0","SCRIPTS_V1","omni_lock","secp256k1_blake160","short_id","sudt","ROLLUP_CONFIG_V1","getLayer2Config","env","log","LocalLayer2Config","PROVIDER_CONFIG","CKB_INDEXER_URL","CKB_RPC_URL","GW_POLYJUICE_RPC_URL","SerializeRawWithdrawalRequest","Fee","SerializeFee","SerializeDepositLockArgs","layer2_lock","cancel_timeout","SerializeUnlockWithdrawalViaFinalize","getSudtId","getAmount","compatible","toBigEndianBigUint64","getBigUint64","toLittleEndianBigUint64","GodwokenClient","scriptHash","shortAddress","txHash","accountId","SerializeRcIdentity","SerializeIdentity","identity","map","maskView","mask","SerializeSmtProof","proof","SerializeSmtProofEntry","SerializeSmtProofEntryVec","proofs","SerializeRcLockWitnessLock","SerializeBytesOpt","SerializeRcIdentityOpt","rc_identity","preimage","LAYER1_CONFIG","OMNI_LOCK_CELL_DEP","SECP256K1_BLACK160_CELL_DEP","SUDT_CELL_DEP","POLYJUICE_CONFIG","web3Url","abiItems","inputs","internalType","type","stateMutability","anonymous","indexed","outputs","polyjuiceProvider","PolyjuiceHttpProvider","DefaultLightGodwokenProvider","ethAddress","ethereum","l2Address","l1Address","ckbIndexer","web3","godwokenClient","config","configObj","initializeConfig","predefined","AGGRON4","LINA","Indexer","generateL1Address","on","accounts","Web3","withdrawalRequest","submitWithdrawalRequest","getL2Address","getL1Address","version","isMetaMask","method","then","catch","error","code","omniLock","substring","helpers","generateAddress","tx","send_transaction","txSkeleton","message","generateMessage","signedMessage","params","selectedAddress","v","Number","padStart","signedWitness","toolkit","SerializeWitnessArgs","lock","update","witnesses","createTransactionFromSkeleton","hasher","utils","CKBHasher","rawTxHash","ckbHash","SerializeRawTransaction","NormalizeRawTransaction","serializedWitness","repeat","hashWitness","digestHex","witness","lengthBuffer","setBigUint64","get_transaction","asyncSleep","getLastSubmittedInfo","transaction_hash","getPendingTransaction","rollupIndex","transaction","findIndex","o","computeScriptHash","queryOptions","collector","rollupCell","cell","collect","getLayer2LockScript","toLowerCase","getLayer2LockScriptHash","accountScriptHash","getLayer1LockScriptHash","ownerCKBLock","parseAddress","ownerLock","ownerLockHash","getRollupCell","globalState","godwokenCore","GlobalState","lastFinalizedBlockNumber","getLastFinalizedBlockNumber","ms","Promise","r","setTimeout","DefaultLightGodwoken","provider","payload","neededCapacity","neededSudtAmount","collectedCapatity","collectedSudtAmount","collectedCells","cell_output","sudtType","readBigUInt128LECompatible","toBigInt","outputCell","generateDepositOutputCell","TransactionSkeleton","cellProvider","cell_deps","signedTx","signL1Transaction","sendL1Transaction","depositLockArgs","depositLockArgsHexString","NormalizeDepositLockArgs","depositLock","sumCapacity","reduce","acc","sumSustAmount","readBigUInt128LE","exchangeCapacity","exchangeCell","toBigUInt128LE","sudtData","exchangeSudtCell","sudtCapacity","minimalCellCapacity","getBlockProduceTime","getWithdrawal","signMessage","privateKey","signObject","secp256k1","signatureBuffer","signatureArray","recid","generateWithdrawalMessageToSign","rawWithdrawalRequest","rollupTypeHash","serializedRawWithdrawalRequest","minimalWithdrawalCapacity","isSudt","dummyHash","dummyHexNumber","dummyRollupTypeHash","dummyWithdrawalLockArgs","withdrawal_block_hash","withdrawal_block_number","serialized","SerializeWithdrawalLockArgs","withdrawal_lock_args","NormalizeWithdrawalLockArgs","eth","outputDataLenRange","collectedSum","balances","promises","addresses","usdcBalancePromise","Contract","methods","balanceOf","call","all","values","forEach","types","fromScript","changeOutput","TOKEN_LIST","symbol","decimals","tokenURI","issuerLockHash","l1Lock","DefaultLightGodwokenV0","getVersion","getBuiltinErc20List","token","tokenL1Script","tokenScriptHash","getBuiltinSUDTList","searchParams","getWithdrawalCellSearchParams","rawLockArgs","lockArgs","WithdrawalLockArgs","withdrawBlock","getWithdrawalBlockNumber","containsOwnerLock","includes","erc20","sudtTypeHash","find","e","withdrawalBlockNumber","remainingBlockNumber","Math","max","sortedWithdrawals","sort","a","b","startsWith","script_type","withdrawWithEvent","eventEmitter","EventEmitter","withdraw","emit","ethAccountTypeHash","withdrawal_address","l2AccountScript","fromId","getAccountIdByScriptHash","minCapacity","getNonce","paymentLockHash","signatureMetamaskPersonalSign","signMessageMetamaskPersonalSign","loop","nIntervId","setInterval","async","withdrawal","status","clearInterval","outputCells","dummySudtCell","capacityLeft","newWitnessArgs","NormalizeWitnessArgs","withdrawalWitness","withdrawalLockDep","rollupCellDep","getRollupCellDep","injectCapacity","LightGodwokenContext","createContext","Provider","props","lightGodwoken","setLightGodwoken","useState","useEffect","detectEthereumProvider","chainId","chainName","nativeCurrency","rpcUrls","blockExplorerUrls","addNetwork","instance","children","useLightGodwoken","useContext","getDisplayAmount","valueStr","intPart","unit","decPart","round","toFixed","replace","StyledInput","styled","input","align","inputRegex","RegExp","Input","React","memo","onUserInput","placeholder","rest","onChange","event","nextUserInput","target","test","inputMode","title","autoComplete","autoCorrect","pattern","minLength","maxLength","spellCheck","StyleWrapper","div","Row","CKBInputPanel","label","isL1","showMaxButton","setShowMaxButton","ckbBalance","setCkbBalance","getL1CkbBalance","getL2CkbBalance","fetchData","className","Text","NumericalInput","val","onClick","src","alt","TipWrapper","truncateMiddle","str","first","last","Address","useMemo","htmlFor","Group","compact","style","width","icon","CopyOutlined","navigator","clipboard","writeText","Button","ConnectButton","StyledPage","PageHeader","Page","Typography","PageContent","PageMain","L1WalletAddress","WithDrawalButton","ConfirmModal","Modal","L2Balance","useQuery","enabled","LoadingOutlined","Deposit","ckbInput","setCkbInput","outputValue","setOutputValue","isModalVisible","setIsModalVisible","submitButtonDisable","setSubmitButtonDisable","selectedSudt","setSelectedSudt","InfoCircleOutlined","verticalAlign","disabled","pow","hash","deposit","notification","success","href","rel","visible","onCancel","footer","App","client","QueryClient","path","element","reportWebVitals","onPerfEntry","import","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","exports","verifyAndExtractOffsets","expectedFieldCount","requiredByteLength","firstOffset","Uint32Vec","SerializeUint32Vec","itemBuffer","BlockMerkleState","getMerkleRoot","getCount","SerializeBlockMerkleState","merkle_root","count","AccountMerkleState","SerializeAccountMerkleState","GlobalStateV0","getRollupConfigHash","getAccount","getBlock","getRevertedBlockRoot","getTipBlockHash","getStatus","SerializeGlobalStateV0","rollup_config_hash","account","block","reverted_block_root","tip_block_hash","last_finalized_block_number","getTipBlockTimestamp","SerializeGlobalState","tip_block_timestamp","RollupConfig","Byte32Vec","getL1SudtScriptTypeHash","offset","offset_end","getCustodianScriptTypeHash","getDepositScriptTypeHash","getWithdrawalScriptTypeHash","getChallengeScriptTypeHash","getStakeScriptTypeHash","getL2SudtValidatorScriptTypeHash","getBurnLockHash","getRequiredStakingCapacity","getChallengeMaturityBlocks","getFinalityBlocks","getRewardBurnRate","getAllowedEoaTypeHashes","getAllowedContractTypeHashes","SerializeRollupConfig","rewardBurnRateView","SerializeByte32Vec","RawL2Transaction","Bytes","getFromId","getToId","getArgs","SerializeRawL2Transaction","L2Transaction","getRaw","getSignature","SerializeL2Transaction","L2TransactionVec","SerializeL2TransactionVec","SubmitTransactions","getTxWitnessRoot","getTxCount","getPrevStateCheckpoint","SerializeSubmitTransactions","tx_witness_root","tx_count","prev_state_checkpoint","SubmitWithdrawals","getWithdrawalWitnessRoot","getWithdrawalCount","SerializeSubmitWithdrawals","withdrawal_witness_root","withdrawal_count","RawL2Block","getNumber","getBlockProducerId","getParentBlockHash","getStakeCellOwnerLockHash","getTimestamp","getPrevAccount","getPostAccount","getStateCheckpointList","getSubmitWithdrawals","getSubmitTransactions","SerializeRawL2Block","number","block_producer_id","parent_block_hash","stake_cell_owner_lock_hash","prev_account","post_account","state_checkpoint_list","submit_withdrawals","submit_transactions","RawL2BlockVec","SerializeRawL2BlockVec","L2Block","KVPairVec","WithdrawalRequestVec","getKvState","getKvStateProof","getTransactions","getBlockProof","getWithdrawals","SerializeL2Block","SerializeKVPairVec","kv_state","kv_state_proof","transactions","block_proof","SerializeWithdrawalRequestVec","withdrawals","DepositRequest","Script","getCapacity","getSudtScriptHash","getScript","SerializeDepositRequest","DepositRequestVec","SerializeDepositRequestVec","RawWithdrawalRequest","getAccountScriptHash","getSellAmount","getSellCapacity","getOwnerLockHash","getPaymentLockHash","getFee","WithdrawalRequest","KVPair","getK","getV","SerializeKVPair","k","BlockInfo","SerializeBlockInfo","DepositLockArgs","getLayer2Lock","getCancelTimeout","CustodianLockArgs","getDepositLockArgs","getDepositBlockHash","getDepositBlockNumber","SerializeCustodianLockArgs","deposit_lock_args","deposit_block_hash","deposit_block_number","UnlockCustodianViaRevertWitness","getDepositLockHash","SerializeUnlockCustodianViaRevertWitness","deposit_lock_hash","getWithdrawalBlockHash","UnlockWithdrawalWitness","t","UnlockWithdrawalViaFinalize","UnlockWithdrawalViaRevert","UnlockWithdrawalViaTrade","unionType","SerializeUnlockWithdrawalWitness","SerializeUnlockWithdrawalViaRevert","SerializeUnlockWithdrawalViaTrade","getCustodianLockHash","custodian_lock_hash","getOwnerLock","StakeLockArgs","getStakeBlockNumber","SerializeStakeLockArgs","stake_block_number","MetaContractArgs","CreateAccount","SerializeMetaContractArgs","SerializeCreateAccount","SUDTArgs","SUDTQuery","SUDTTransfer","SerializeSUDTArgs","SerializeSUDTQuery","SerializeSUDTTransfer","getShortAddress","short_address","getTo","to","ChallengeTarget","getBlockHash","getTargetIndex","getTargetType","SerializeChallengeTarget","block_hash","target_index","target_type","ChallengeLockArgs","getTarget","getRewardsReceiverLock","SerializeChallengeLockArgs","rewards_receiver_lock","ChallengeWitness","getRawL2Block","SerializeChallengeWitness","raw_l2block","ScriptVec","SerializeScriptVec","BlockHashEntry","getHash","SerializeBlockHashEntry","BlockHashEntryVec","SerializeBlockHashEntryVec","VerifyTransactionContext","BytesVec","getAccountCount","getLoadData","getScripts","getReturnDataHash","getBlockHashes","SerializeVerifyTransactionContext","account_count","SerializeBytesVec","load_data","scripts","return_data_hash","block_hashes","CKBMerkleProof","getIndices","getLemmas","SerializeCKBMerkleProof","indices","lemmas","VerifyTransactionWitness","getL2Tx","getTxProof","getBlockHashesProof","getContext","SerializeVerifyTransactionWitness","tx_proof","block_hashes_proof","context","VerifyTransactionSignatureContext","SerializeVerifyTransactionSignatureContext","VerifyTransactionSignatureWitness","SerializeVerifyTransactionSignatureWitness","VerifyWithdrawalWitness","getWithdrawalRequest","getWithdrawalProof","SerializeVerifyWithdrawalWitness","withdrawal_request","withdrawal_proof","RollupSubmitBlock","getRevertedBlockHashes","getRevertedBlockProof","SerializeRollupSubmitBlock","reverted_block_hashes","reverted_block_proof","RollupEnterChallenge","getWitness","SerializeRollupEnterChallenge","RollupCancelChallenge","SerializeRollupCancelChallenge","RollupRevert","getRevertedBlocks","getNewTipBlock","SerializeRollupRevert","reverted_blocks","new_tip_block","RollupAction","SerializeRollupAction","Uint16","toBigEndianUint16","getUint16","toLittleEndianUint16","SerializeUint16","Uint256","SerializeUint256","BytesOpt","hasValue","ScriptOpt","SerializeScriptOpt","ProposalShortId","SerializeProposalShortId","UncleBlockVec","UncleBlock","SerializeUncleBlockVec","SerializeUncleBlock","TransactionVec","Transaction","SerializeTransactionVec","SerializeTransaction","ProposalShortIdVec","SerializeProposalShortIdVec","CellDepVec","CellDep","SerializeCellDepVec","SerializeCellDep","CellInputVec","CellInput","SerializeCellInputVec","SerializeCellInput","CellOutputVec","CellOutput","SerializeCellOutputVec","SerializeCellOutput","getCodeHash","getHashType","OutPoint","getTxHash","getIndex","SerializeOutPoint","getSince","getPreviousOutput","since","previous_output","getLock","getType","type_","getOutPoint","getDepType","RawTransaction","getCellDeps","getHeaderDeps","getInputs","getOutputs","getOutputsData","header_deps","outputs_data","getWitnesses","RawHeader","getCompactTarget","getEpoch","getParentHash","getTransactionsRoot","getProposalsHash","getExtraHash","getDao","SerializeRawHeader","compact_target","epoch","parent_hash","transactions_root","proposals_hash","extra_hash","dao","Header","SerializeHeader","getHeader","getProposals","header","proposals","Block","getUncles","SerializeBlock","uncles","BlockV1","getExtension","SerializeBlockV1","extension","CellbaseWitness","getMessage","SerializeCellbaseWitness","WitnessArgs","getInputType","getOutputType","input_type","output_type","defineProperty","factory"],"mappings":"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","file":"static/js/main.2274f5de.chunk.js","sourcesContent":["function dataLengthError(actual, required) {\n  throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n}\n\nfunction assertDataLength(actual, required) {\n  if (actual !== required) {\n    dataLengthError(actual, required);\n  }\n}\n\nfunction assertArrayBuffer(reader) {\n  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n    reader = reader.toArrayBuffer();\n  }\n  if (!(reader instanceof ArrayBuffer)) {\n    throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n  }\n  return reader;\n}\n\nfunction verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n  if (view.byteLength < 4) {\n    dataLengthError(view.byteLength, \">4\");\n  }\n  const requiredByteLength = view.getUint32(0, true);\n  assertDataLength(view.byteLength, requiredByteLength);\n  if (requiredByteLength === 4) {\n    return [requiredByteLength];\n  }\n  if (requiredByteLength < 8) {\n    dataLengthError(view.byteLength, \">8\");\n  }\n  const firstOffset = view.getUint32(4, true);\n  if (firstOffset % 4 !== 0 || firstOffset < 8) {\n    throw new Error(`Invalid first offset: ${firstOffset}`);\n  }\n  const itemCount = firstOffset / 4 - 1;\n  if (itemCount < expectedFieldCount) {\n    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  } else if (!compatible && itemCount > expectedFieldCount) {\n    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  }\n  if (requiredByteLength < firstOffset) {\n    throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n  }\n  const offsets = [];\n  for (let i = 0; i < itemCount; i++) {\n    const start = 4 + i * 4;\n    offsets.push(view.getUint32(start, true));\n  }\n  offsets.push(requiredByteLength);\n  for (let i = 0; i < offsets.length - 1; i++) {\n    if (offsets[i] > offsets[i + 1]) {\n      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n    }\n  }\n  return offsets;\n}\n\nfunction serializeTable(buffers) {\n  const itemCount = buffers.length;\n  let totalSize = 4 * (itemCount + 1);\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    offsets.push(totalSize);\n    totalSize += buffers[i].byteLength;\n  }\n\n  const buffer = new ArrayBuffer(totalSize);\n  const array = new Uint8Array(buffer);\n  const view = new DataView(buffer);\n\n  view.setUint32(0, totalSize, true);\n  for (let i = 0; i < itemCount; i++) {\n    view.setUint32(4 + i * 4, offsets[i], true);\n    array.set(new Uint8Array(buffers[i]), offsets[i]);\n  }\n  return buffer;\n}\n\nexport class Uint32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Uint32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Uint32(this.view.buffer.slice(4 + i * Uint32.size(), 4 + (i + 1) * Uint32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeUint32Vec(value) {\n  const array = new Uint8Array(4 + Uint32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeUint32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Uint32.size());\n  }\n  return array.buffer;\n}\n\nexport class BlockMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class AccountMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, AccountMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeAccountMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class GlobalStateV0 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(\n      this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n      { validate: false },\n    );\n  }\n\n  getBlock() {\n    return new BlockMerkleState(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getStatus() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size(),\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalStateV0.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      1\n    );\n  }\n}\n\nexport function SerializeGlobalStateV0(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      1,\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.reverted_block_root)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.tip_block_hash)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n    value.status,\n  );\n  return array.buffer;\n}\n\nexport class GlobalState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(\n      this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n      { validate: false },\n    );\n  }\n\n  getBlock() {\n    return new BlockMerkleState(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getStatus() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size(),\n    );\n  }\n\n  getVersion() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        1,\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalState.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getTipBlockTimestamp().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1 +\n      1\n    );\n  }\n}\n\nexport function SerializeGlobalState(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1 +\n      1,\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.reverted_block_root)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.tip_block_hash)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.tip_block_timestamp)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size(),\n    value.status,\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1,\n    value.version,\n  );\n  return array.buffer;\n}\n\nexport class AllowedTypeHash {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getType() {\n    return this.view.getUint8(0);\n  }\n\n  getHash() {\n    return new Byte32(this.view.buffer.slice(0 + 1, 0 + 1 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, AllowedTypeHash.size());\n    this.getHash().validate(compatible);\n  }\n  static size() {\n    return 0 + 1 + Byte32.size();\n  }\n}\n\nexport function SerializeAllowedTypeHash(value) {\n  const array = new Uint8Array(0 + 1 + Byte32.size());\n  const view = new DataView(array.buffer);\n  view.setUint8(0, value.type_);\n  array.set(new Uint8Array(SerializeByte32(value.hash)), 0 + 1);\n  return array.buffer;\n}\n\nexport class AllowedTypeHashVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * AllowedTypeHash.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new AllowedTypeHash(\n      this.view.buffer.slice(4 + i * AllowedTypeHash.size(), 4 + (i + 1) * AllowedTypeHash.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeAllowedTypeHashVec(value) {\n  const array = new Uint8Array(4 + AllowedTypeHash.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeAllowedTypeHash(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * AllowedTypeHash.size());\n  }\n  return array.buffer;\n}\n\nexport class RollupConfig {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[10], offsets[11]), { validate: false }).validate();\n    if (offsets[12] - offsets[11] !== 1) {\n      throw new Error(`Invalid offset for reward_burn_rate: ${offsets[11]} - ${offsets[12]}`);\n    }\n    new Uint32(this.view.buffer.slice(offsets[12], offsets[13]), { validate: false }).validate();\n    new AllowedTypeHashVec(this.view.buffer.slice(offsets[13], offsets[14]), { validate: false }).validate();\n    new AllowedTypeHashVec(this.view.buffer.slice(offsets[14], offsets[15]), { validate: false }).validate();\n  }\n\n  getL1SudtScriptTypeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCustodianScriptTypeHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositScriptTypeHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalScriptTypeHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeScriptTypeHash() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeScriptTypeHash() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2SudtValidatorScriptTypeHash() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBurnLockHash() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRequiredStakingCapacity() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeMaturityBlocks() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFinalityBlocks() {\n    const start = 44;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardBurnRate() {\n    const start = 48;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getCompatibleChainId() {\n    const start = 52;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAllowedEoaTypeHashes() {\n    const start = 56;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AllowedTypeHashVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAllowedContractTypeHashes() {\n    const start = 60;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new AllowedTypeHashVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupConfig(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.l1_sudt_script_type_hash));\n  buffers.push(SerializeByte32(value.custodian_script_type_hash));\n  buffers.push(SerializeByte32(value.deposit_script_type_hash));\n  buffers.push(SerializeByte32(value.withdrawal_script_type_hash));\n  buffers.push(SerializeByte32(value.challenge_script_type_hash));\n  buffers.push(SerializeByte32(value.stake_script_type_hash));\n  buffers.push(SerializeByte32(value.l2_sudt_validator_script_type_hash));\n  buffers.push(SerializeByte32(value.burn_lock_hash));\n  buffers.push(SerializeUint64(value.required_staking_capacity));\n  buffers.push(SerializeUint64(value.challenge_maturity_blocks));\n  buffers.push(SerializeUint64(value.finality_blocks));\n  const rewardBurnRateView = new DataView(new ArrayBuffer(1));\n  rewardBurnRateView.setUint8(0, value.reward_burn_rate);\n  buffers.push(rewardBurnRateView.buffer);\n  buffers.push(SerializeUint32(value.compatible_chain_id));\n  buffers.push(SerializeAllowedTypeHashVec(value.allowed_eoa_type_hashes));\n  buffers.push(SerializeAllowedTypeHashVec(value.allowed_contract_type_hashes));\n  return serializeTable(buffers);\n}\n\nexport class RawL2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getFromId() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getToId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNonce() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getArgs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.from_id));\n  buffers.push(SerializeUint32(value.to_id));\n  buffers.push(SerializeUint32(value.nonce));\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class L2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Transaction(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class L2TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new L2Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2TransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeL2Transaction(item)));\n}\n\nexport class SubmitTransactions {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxWitnessRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getTxCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getPrevStateCheckpoint() {\n    return new Byte32(\n      this.view.buffer.slice(0 + Byte32.size() + Uint32.size(), 0 + Byte32.size() + Uint32.size() + Byte32.size()),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SubmitTransactions.size());\n    this.getTxWitnessRoot().validate(compatible);\n    this.getTxCount().validate(compatible);\n    this.getPrevStateCheckpoint().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size() + Byte32.size();\n  }\n}\n\nexport function SerializeSubmitTransactions(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_witness_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.tx_count)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.prev_state_checkpoint)), 0 + Byte32.size() + Uint32.size());\n  return array.buffer;\n}\n\nexport class SubmitWithdrawals {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getWithdrawalWitnessRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SubmitWithdrawals.size());\n    this.getWithdrawalWitnessRoot().validate(compatible);\n    this.getWithdrawalCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeSubmitWithdrawals(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_witness_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.withdrawal_count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class RawL2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new SubmitWithdrawals(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new SubmitTransactions(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n  }\n\n  getNumber() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProducerId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getParentBlockHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeCellOwnerLockHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTimestamp() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPrevAccount() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPostAccount() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStateCheckpointList() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitWithdrawals() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new SubmitWithdrawals(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitTransactions() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SubmitTransactions(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.number));\n  buffers.push(SerializeUint32(value.block_producer_id));\n  buffers.push(SerializeByte32(value.parent_block_hash));\n  buffers.push(SerializeByte32(value.stake_cell_owner_lock_hash));\n  buffers.push(SerializeUint64(value.timestamp));\n  buffers.push(SerializeAccountMerkleState(value.prev_account));\n  buffers.push(SerializeAccountMerkleState(value.post_account));\n  buffers.push(SerializeByte32Vec(value.state_checkpoint_list));\n  buffers.push(SerializeSubmitWithdrawals(value.submit_withdrawals));\n  buffers.push(SerializeSubmitTransactions(value.submit_transactions));\n  return serializeTable(buffers);\n}\n\nexport class RawL2BlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new RawL2Block(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2BlockVec(value) {\n  return serializeTable(value.map((item) => SerializeRawL2Block(item)));\n}\n\nexport class L2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new L2TransactionVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new WithdrawalRequestVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawals() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new WithdrawalRequestVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeL2TransactionVec(value.transactions));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeWithdrawalRequestVec(value.withdrawals));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSudtScriptHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScript() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeByte32(value.sudt_script_hash));\n  buffers.push(SerializeScript(value.script));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new DepositRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new DepositRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequestVec(value) {\n  return serializeTable(value.map((item) => SerializeDepositRequest(item)));\n}\n\nexport class RawWithdrawalRequestV1 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNonce() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getChainId() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getCapacity() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  getAmount() {\n    return new Uint128(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSudtScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size(),\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getFee() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawWithdrawalRequestV1.size());\n    this.getNonce().validate(compatible);\n    this.getChainId().validate(compatible);\n    this.getCapacity().validate(compatible);\n    this.getAmount().validate(compatible);\n    this.getSudtScriptHash().validate(compatible);\n    this.getAccountScriptHash().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n    this.getFee().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size()\n    );\n  }\n}\n\nexport function SerializeRawWithdrawalRequestV1(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.nonce)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.chain_id)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.capacity)), 0 + Uint32.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size() + Uint64.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.sudt_script_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.account_script_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.fee)),\n    0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class WithdrawalRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new WithdrawalRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequestVec(value) {\n  return serializeTable(value.map((item) => SerializeWithdrawalRequest(item)));\n}\n\nexport class WithdrawalRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawWithdrawalRequestV1(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawWithdrawalRequestV1(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeRawWithdrawalRequestV1(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class WithdrawalRequestExtra {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new WithdrawalRequest(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRequest() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOwnerLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequestExtra(value) {\n  const buffers = [];\n  buffers.push(SerializeWithdrawalRequest(value.request));\n  buffers.push(SerializeScript(value.owner_lock));\n  return serializeTable(buffers);\n}\n\nexport class KVPair {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getK() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getV() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, KVPair.size());\n    this.getK().validate(compatible);\n    this.getV().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Byte32.size();\n  }\n}\n\nexport function SerializeKVPair(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.k)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.v)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class KVPairVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * KVPair.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new KVPair(this.view.buffer.slice(4 + i * KVPair.size(), 4 + (i + 1) * KVPair.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeKVPairVec(value) {\n  const array = new Uint8Array(4 + KVPair.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeKVPair(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * KVPair.size());\n  }\n  return array.buffer;\n}\n\nexport class BlockInfo {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockProducerId() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockInfo.size());\n    this.getBlockProducerId().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getTimestamp().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint64.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockInfo(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint64.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.block_producer_id)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint64.size());\n  return array.buffer;\n}\n\nexport class DepositLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getOwnerLockHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLayer2Lock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCancelTimeout() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.owner_lock_hash));\n  buffers.push(SerializeScript(value.layer2_lock));\n  buffers.push(SerializeUint64(value.cancel_timeout));\n  return serializeTable(buffers);\n}\n\nexport class CustodianLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new DepositLockArgs(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getDepositLockArgs() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DepositLockArgs(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockNumber() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCustodianLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeDepositLockArgs(value.deposit_lock_args));\n  buffers.push(SerializeByte32(value.deposit_block_hash));\n  buffers.push(SerializeUint64(value.deposit_block_number));\n  return serializeTable(buffers);\n}\n\nexport class UnlockCustodianViaRevertWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getDepositLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockCustodianViaRevertWitness.size());\n    this.getDepositLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockCustodianViaRevertWitness(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.deposit_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class WithdrawalLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getWithdrawalBlockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalBlockNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(0 + Byte32.size() + Uint64.size(), 0 + Byte32.size() + Uint64.size() + Byte32.size()),\n      { validate: false },\n    );\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Uint64.size() + Byte32.size(),\n        0 + Byte32.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, WithdrawalLockArgs.size());\n    this.getWithdrawalBlockHash().validate(compatible);\n    this.getWithdrawalBlockNumber().validate(compatible);\n    this.getAccountScriptHash().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size() + Byte32.size() + Byte32.size();\n  }\n}\n\nexport function SerializeWithdrawalLockArgs(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size() + Byte32.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_block_hash)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.withdrawal_block_number)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.account_script_hash)), 0 + Byte32.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0 + Byte32.size() + Uint64.size() + Byte32.size());\n  return array.buffer;\n}\n\nexport class UnlockWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"UnlockWithdrawalViaFinalize\";\n      case 1:\n        return \"UnlockWithdrawalViaRevert\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeUnlockWithdrawalWitness(value) {\n  switch (value.type) {\n    case \"UnlockWithdrawalViaFinalize\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaFinalize(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"UnlockWithdrawalViaRevert\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class UnlockWithdrawalViaFinalize {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaFinalize(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class UnlockWithdrawalViaRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getCustodianLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockWithdrawalViaRevert.size());\n    this.getCustodianLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaRevert(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.custodian_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class StakeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getStakeBlockNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, StakeLockArgs.size());\n    this.getOwnerLockHash().validate(compatible);\n    this.getStakeBlockNumber().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeStakeLockArgs(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.stake_block_number)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class MetaContractArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new CreateAccount(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"CreateAccount\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new CreateAccount(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeMetaContractArgs(value) {\n  switch (value.type) {\n    case \"CreateAccount\": {\n      const itemBuffer = SerializeCreateAccount(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class CreateAccount {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getScript() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCreateAccount(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.script));\n  buffers.push(SerializeUint64(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class SUDTArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new SUDTQuery(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new SUDTTransfer(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"SUDTQuery\";\n      case 1:\n        return \"SUDTTransfer\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new SUDTQuery(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new SUDTTransfer(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeSUDTArgs(value) {\n  switch (value.type) {\n    case \"SUDTQuery\": {\n      const itemBuffer = SerializeSUDTQuery(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"SUDTTransfer\": {\n      const itemBuffer = SerializeSUDTTransfer(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class SUDTQuery {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getShortScriptHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTQuery(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.short_script_hash));\n  return serializeTable(buffers);\n}\n\nexport class SUDTTransfer {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getTo() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTTransfer(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.to));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeUint64(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeTarget {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getTargetIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTargetType() {\n    return this.view.getUint8(0 + Byte32.size() + Uint32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, ChallengeTarget.size());\n    this.getBlockHash().validate(compatible);\n    this.getTargetIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size() + 1;\n  }\n}\n\nexport function SerializeChallengeTarget(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.block_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.target_index)), 0 + Byte32.size());\n  view.setUint8(0 + Byte32.size() + Uint32.size(), value.target_type);\n  return array.buffer;\n}\n\nexport class ChallengeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeTarget(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getTarget() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ChallengeTarget(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardsReceiverLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeTarget(value.target));\n  buffers.push(SerializeScript(value.rewards_receiver_lock));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeBytes(value.block_proof));\n  return serializeTable(buffers);\n}\n\nexport class ScriptVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScriptVec(value) {\n  return serializeTable(value.map((item) => SerializeScript(item)));\n}\n\nexport class BlockHashEntry {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockHashEntry.size());\n    this.getNumber().validate(compatible);\n    this.getHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + Byte32.size();\n  }\n}\n\nexport function SerializeBlockHashEntry(value) {\n  const array = new Uint8Array(0 + Uint64.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.hash)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class BlockHashEntryVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * BlockHashEntry.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new BlockHashEntry(\n      this.view.buffer.slice(4 + i * BlockHashEntry.size(), 4 + (i + 1) * BlockHashEntry.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBlockHashEntryVec(value) {\n  const array = new Uint8Array(4 + BlockHashEntry.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeBlockHashEntry(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * BlockHashEntry.size());\n  }\n  return array.buffer;\n}\n\nexport class CKBMerkleProof {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32Vec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getIndices() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLemmas() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCKBMerkleProof(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32Vec(value.indices));\n  buffers.push(SerializeByte32Vec(value.lemmas));\n  return serializeTable(buffers);\n}\n\nexport class CCTransactionWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new ScriptVec(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n    new BlockHashEntryVec(this.view.buffer.slice(offsets[10], offsets[11]), { validate: false }).validate();\n  }\n\n  getL2Tx() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRawL2Block() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashesProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAccountCount() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLoadData() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScripts() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getReturnDataHash() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashes() {\n    const start = 44;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BlockHashEntryVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCCTransactionWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeBytes(value.block_hashes_proof));\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytesVec(value.load_data));\n  buffers.push(SerializeScriptVec(value.scripts));\n  buffers.push(SerializeByte32(value.return_data_hash));\n  buffers.push(SerializeBlockHashEntryVec(value.block_hashes));\n  return serializeTable(buffers);\n}\n\nexport class CCTransactionSignatureWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new L2Transaction(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2Tx() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAccountCount() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSender() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getReceiver() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCCTransactionSignatureWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeScript(value.sender));\n  buffers.push(SerializeScript(value.receiver));\n  return serializeTable(buffers);\n}\n\nexport class CCWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new WithdrawalRequest(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawal() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSender() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOwnerLock() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCCWithdrawalWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeWithdrawalRequest(value.withdrawal));\n  buffers.push(SerializeScript(value.sender));\n  buffers.push(SerializeScript(value.owner_lock));\n  buffers.push(SerializeCKBMerkleProof(value.withdrawal_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupSubmitBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getBlock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockHashes() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupSubmitBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Block(value.block));\n  buffers.push(SerializeByte32Vec(value.reverted_block_hashes));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupEnterChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeWitness(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getWitness() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ChallengeWitness(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupEnterChallenge(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeWitness(value.witness));\n  return serializeTable(buffers);\n}\n\nexport class RollupCancelChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n}\n\nexport function SerializeRollupCancelChallenge(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class RollupRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2BlockVec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getRevertedBlocks() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2BlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNewTipBlock() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupRevert(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2BlockVec(value.reverted_blocks));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  buffers.push(SerializeRawL2Block(value.new_tip_block));\n  return serializeTable(buffers);\n}\n\nexport class RollupAction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 2:\n        new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 3:\n        new RollupRevert(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"RollupSubmitBlock\";\n      case 1:\n        return \"RollupEnterChallenge\";\n      case 2:\n        return \"RollupCancelChallenge\";\n      case 3:\n        return \"RollupRevert\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false });\n      case 2:\n        return new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false });\n      case 3:\n        return new RollupRevert(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeRollupAction(value) {\n  switch (value.type) {\n    case \"RollupSubmitBlock\": {\n      const itemBuffer = SerializeRollupSubmitBlock(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupEnterChallenge\": {\n      const itemBuffer = SerializeRollupEnterChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupCancelChallenge\": {\n      const itemBuffer = SerializeRollupCancelChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupRevert\": {\n      const itemBuffer = SerializeRollupRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 3, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class Byte20 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 20);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 20;\n  }\n}\n\nexport function SerializeByte20(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 20);\n  return buffer;\n}\n\nexport class ETHAddrRegArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new EthToGw(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new GwToEth(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 2:\n        new SetMapping(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 3:\n        new BatchSetMapping(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"EthToGw\";\n      case 1:\n        return \"GwToEth\";\n      case 2:\n        return \"SetMapping\";\n      case 3:\n        return \"BatchSetMapping\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new EthToGw(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new GwToEth(this.view.buffer.slice(4), { validate: false });\n      case 2:\n        return new SetMapping(this.view.buffer.slice(4), { validate: false });\n      case 3:\n        return new BatchSetMapping(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeETHAddrRegArgs(value) {\n  switch (value.type) {\n    case \"EthToGw\": {\n      const itemBuffer = SerializeEthToGw(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"GwToEth\": {\n      const itemBuffer = SerializeGwToEth(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"SetMapping\": {\n      const itemBuffer = SerializeSetMapping(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"BatchSetMapping\": {\n      const itemBuffer = SerializeBatchSetMapping(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 3, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class EthToGw {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getEthAddress() {\n    return new Byte20(this.view.buffer.slice(0, 0 + Byte20.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, EthToGw.size());\n    this.getEthAddress().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte20.size();\n  }\n}\n\nexport function SerializeEthToGw(value) {\n  const array = new Uint8Array(0 + Byte20.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte20(value.eth_address)), 0);\n  return array.buffer;\n}\n\nexport class GwToEth {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getGwScriptHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GwToEth.size());\n    this.getGwScriptHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeGwToEth(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.gw_script_hash)), 0);\n  return array.buffer;\n}\n\nexport class SetMapping {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getGwScriptHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getFee() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SetMapping.size());\n    this.getGwScriptHash().validate(compatible);\n    this.getFee().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeSetMapping(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.gw_script_hash)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.fee)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class BatchSetMapping {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32Vec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getGwScriptHashes() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBatchSetMapping(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32Vec(value.gw_script_hashes));\n  buffers.push(SerializeUint64(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class Uint16 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 2);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint16() {\n    return this.view.getUint16(0, false);\n  }\n\n  toLittleEndianUint16() {\n    return this.view.getUint16(0, true);\n  }\n\n  static size() {\n    return 2;\n  }\n}\n\nexport function SerializeUint16(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 2);\n  return buffer;\n}\n\nexport class Uint32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint32() {\n    return this.view.getUint32(0, false);\n  }\n\n  toLittleEndianUint32() {\n    return this.view.getUint32(0, true);\n  }\n\n  static size() {\n    return 4;\n  }\n}\n\nexport function SerializeUint32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 4);\n  return buffer;\n}\n\nexport class Uint64 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 8);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 8;\n  }\n}\n\nexport function SerializeUint64(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 8);\n  return buffer;\n}\n\nexport class Uint128 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 16);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 16;\n  }\n}\n\nexport function SerializeUint128(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 16);\n  return buffer;\n}\n\nexport class Byte32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeByte32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Uint256 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeUint256(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Bytes {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBytes(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nexport class BytesOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Bytes(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeBytesOpt(value) {\n  if (value) {\n    return SerializeBytes(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class BytesVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBytesVec(value) {\n  return serializeTable(value.map((item) => SerializeBytes(item)));\n}\n\nexport class Byte32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeByte32Vec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n  return array.buffer;\n}\n\nexport class ScriptOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Script(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeScriptOpt(value) {\n  if (value) {\n    return SerializeScript(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class ProposalShortId {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 10);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 10;\n  }\n}\n\nexport function SerializeProposalShortId(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 10);\n  return buffer;\n}\n\nexport class UncleBlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new UncleBlock(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlockVec(value) {\n  return serializeTable(value.map((item) => SerializeUncleBlock(item)));\n}\n\nexport class TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeTransaction(item)));\n}\n\nexport class ProposalShortIdVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new ProposalShortId(\n      this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeProposalShortIdVec(value) {\n  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeProposalShortId(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n  }\n  return array.buffer;\n}\n\nexport class CellDepVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellDep.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellDepVec(value) {\n  const array = new Uint8Array(4 + CellDep.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellDep(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n  }\n  return array.buffer;\n}\n\nexport class CellInputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellInput.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellInputVec(value) {\n  const array = new Uint8Array(4 + CellInput.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellInput(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n  }\n  return array.buffer;\n}\n\nexport class CellOutputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new CellOutput(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutputVec(value) {\n  return serializeTable(value.map((item) => SerializeCellOutput(item)));\n}\n\nexport class Script {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    if (offsets[2] - offsets[1] !== 1) {\n      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);\n    }\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCodeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHashType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getArgs() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScript(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.code_hash));\n  const hashTypeView = new DataView(new ArrayBuffer(1));\n  hashTypeView.setUint8(0, value.hash_type);\n  buffers.push(hashTypeView.buffer);\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class OutPoint {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, OutPoint.size());\n    this.getTxHash().validate(compatible);\n    this.getIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeOutPoint(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class CellInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSince() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getPreviousOutput() {\n    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellInput.size());\n    this.getSince().validate(compatible);\n    this.getPreviousOutput().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + OutPoint.size();\n  }\n}\n\nexport function SerializeCellInput(value) {\n  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class CellOutput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutput(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeScriptOpt(value.type_));\n  return serializeTable(buffers);\n}\n\nexport class CellDep {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOutPoint() {\n    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), { validate: false });\n  }\n\n  getDepType() {\n    return this.view.getUint8(0 + OutPoint.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellDep.size());\n    this.getOutPoint().validate(compatible);\n  }\n  static size() {\n    return 0 + OutPoint.size() + 1;\n  }\n}\n\nexport function SerializeCellDep(value) {\n  const array = new Uint8Array(0 + OutPoint.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n  view.setUint8(0 + OutPoint.size(), value.dep_type);\n  return array.buffer;\n}\n\nexport class RawTransaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getVersion() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCellDeps() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellDepVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHeaderDeps() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellInputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputs() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputsData() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.version));\n  buffers.push(SerializeCellDepVec(value.cell_deps));\n  buffers.push(SerializeByte32Vec(value.header_deps));\n  buffers.push(SerializeCellInputVec(value.inputs));\n  buffers.push(SerializeCellOutputVec(value.outputs));\n  buffers.push(SerializeBytesVec(value.outputs_data));\n  return serializeTable(buffers);\n}\n\nexport class Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawTransaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWitnesses() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawTransaction(value.raw));\n  buffers.push(SerializeBytesVec(value.witnesses));\n  return serializeTable(buffers);\n}\n\nexport class RawHeader {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getVersion() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getCompactTarget() {\n    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  getNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getEpoch() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getParentHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTransactionsRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getProposalsHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getExtraHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getDao() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawHeader.size());\n    this.getVersion().validate(compatible);\n    this.getCompactTarget().validate(compatible);\n    this.getTimestamp().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getEpoch().validate(compatible);\n    this.getParentHash().validate(compatible);\n    this.getTransactionsRoot().validate(compatible);\n    this.getProposalsHash().validate(compatible);\n    this.getExtraHash().validate(compatible);\n    this.getDao().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size()\n    );\n  }\n}\n\nexport function SerializeRawHeader(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeUint64(value.epoch)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.parent_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.transactions_root)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.proposals_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.extra_hash)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.dao)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class Header {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRaw() {\n    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), { validate: false });\n  }\n\n  getNonce() {\n    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Header.size());\n    this.getRaw().validate(compatible);\n    this.getNonce().validate(compatible);\n  }\n  static size() {\n    return 0 + RawHeader.size() + Uint128.size();\n  }\n}\n\nexport function SerializeHeader(value) {\n  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n  return array.buffer;\n}\n\nexport class UncleBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class BlockV1 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getExtension() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlockV1(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  buffers.push(SerializeBytes(value.extension));\n  return serializeTable(buffers);\n}\n\nexport class CellbaseWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getMessage() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellbaseWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeBytes(value.message));\n  return serializeTable(buffers);\n}\n\nexport class WitnessArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWitnessArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.lock));\n  buffers.push(SerializeBytesOpt(value.input_type));\n  buffers.push(SerializeBytesOpt(value.output_type));\n  return serializeTable(buffers);\n}\n","import { Hash, HexString, HexNumber, Script } from \"@ckb-lumos/base\";\n\nexport type Uint32 = number;\nexport type Uint64 = bigint;\nexport type Uint128 = bigint;\nexport type Uint256 = bigint;\n\nexport interface RunResult {\n  read_values: Map<Hash, Hash>;\n  write_values: Map<Hash, Hash>;\n  return_data: HexString;\n  account_count?: HexNumber;\n  new_scripts: Map<Hash, HexString>;\n  write_data: Map<Hash, HexString>;\n  read_data: Map<Hash, HexNumber>;\n}\nexport interface RawL2Transaction {\n  from_id: HexNumber;\n  to_id: HexNumber;\n  nonce: HexNumber;\n  args: HexString;\n}\nexport interface L2Transaction {\n  raw: RawL2Transaction;\n  signature: HexString;\n}\n\nexport interface CreateAccount {\n  script: Script;\n}\n\nexport interface Fee {\n  sudt_id: Uint32;\n  amount: Uint128;\n}\n\nexport interface RawWithdrawalRequest {\n  nonce: HexNumber;\n  // CKB amount\n  capacity: HexNumber;\n  // SUDT amount\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n  // layer2 account_script_hash\n  account_script_hash: Hash;\n  // buyer can pay sell_amount and sell_capacity to unlock\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n  fee: Fee;\n}\nexport interface WithdrawalRequest {\n  raw: RawWithdrawalRequest;\n  signature: HexString;\n}\n\nexport interface RawWithdrawalRequestV1 {\n  nonce: HexNumber;\n  chain_id: HexNumber;\n  // CKB amount\n  capacity: HexNumber;\n  // SUDT amount\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n  // layer2 account_script_hash\n  account_script_hash: Hash;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  fee: HexNumber;\n}\n\nexport interface WithdrawalRequestV1 {\n  raw: RawWithdrawalRequestV1;\n  signature: HexString;\n}\n\nexport interface WithdrawalRequestExtra {\n  request: WithdrawalRequestV1;\n  owner_lock: Script;\n}\n\nexport interface WithdrawalLockArgs {\n  // layer2 account script hash\n  account_script_hash: Hash;\n  // the original custodian lock hash\n  withdrawal_block_hash: Hash;\n  withdrawal_block_number: HexNumber;\n  // buyer can pay sell_amount token to unlock\n  sudt_script_hash: Hash;\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n}\n\nexport interface UnlockWithdrawalViaFinalize {\n  block_proof: HexString;\n}\n\n// export interface HeaderInfo {\n//     number: Uint64;\n//     block_hash: Hash;\n// }\n// FIXME: todo\n// export interface L2Block {}\nexport enum Status {\n  Running = \"running\",\n  Halting = \"halting\",\n}\n\nexport interface LastL2BlockCommittedInfo {\n  transaction_hash: Hash;\n}\n","import * as normalizer from \"./normalizer\";\nimport * as core from \"../schemas\";\nimport {\n  NormalizeL2Transaction,\n  NormalizeRawL2Transaction,\n  NormalizeCreateAccount,\n  NormalizeWithdrawalRequest,\n  NormalizeRawWithdrawalRequest,\n} from \"./normalizer\";\nimport {\n  L2Transaction,\n  RawL2Transaction,\n  RawWithdrawalRequest,\n  WithdrawalRequest,\n  WithdrawalRequestExtra,\n  RunResult,\n  Uint128,\n  Uint32,\n  Uint64,\n  Fee,\n  LastL2BlockCommittedInfo,\n} from \"./types\";\nimport { SerializeRawWithdrawalRequestV1, SerializeWithdrawalRequestExtra } from \"./schema_v1\";\nimport { RPC, Reader } from \"ckb-js-toolkit\";\nimport { Hash, HexString, Script, utils } from \"@ckb-lumos/base\";\nimport keccak256 from \"keccak256\";\nexport * from \"./types\";\n\nexport { core, normalizer, SerializeRawWithdrawalRequestV1 };\nexport type { WithdrawalRequestExtra };\n\nexport function numberToUInt32LE(value: number): HexString {\n  const buf = Buffer.alloc(4);\n  buf.writeUInt32LE(value);\n  return `0x${buf.toString(\"hex\")}`;\n}\n\nexport function UInt32LEToNumber(hex: HexString): number {\n  const buf = Buffer.from(hex.slice(2, 10), \"hex\");\n  return buf.readUInt32LE(0);\n}\n\nexport function u32ToHex(value: number): HexString {\n  return `0x${value.toString(16)}`;\n}\n\nexport function hexToU32(hex: HexString): number {\n  // return parseInt(hex.slice(2), \"hex\");\n  return +hex;\n}\n\nexport function toBuffer(ab: ArrayBuffer): Buffer {\n  const buf = Buffer.alloc(ab.byteLength);\n  const view = new Uint8Array(ab);\n  for (let i = 0; i < buf.length; ++i) {\n    buf[i] = view[i];\n  }\n  return buf;\n}\n\nexport function toArrayBuffer(buf: Buffer) {\n  const ab = new ArrayBuffer(buf.length);\n  const view = new Uint8Array(ab);\n  for (let i = 0; i < buf.length; ++i) {\n    view[i] = buf[i];\n  }\n  return ab;\n}\n\nexport class Godwoken {\n  private rpc: RPC;\n\n  constructor(url: string) {\n    this.rpc = new RPC(url);\n  }\n\n  /**\n   * chain_id: u64 = (compatible_chain_id << 32) | creator_id\n   *\n   * e.g. 0x315DA00000005 = 868,450,977,185,797\n   */\n  async getChainId(): Promise<string> {\n    const result = await this.rpc[\"eth_chainId\"]();\n    console.debug(\"chain_id:\", result);\n    return result;\n  }\n\n  private async rpcCall(method_name: string, ...args: any[]): Promise<any> {\n    const name = \"gw_\" + method_name;\n    const result = await this.rpc[name](...args);\n    return result;\n  }\n\n  async _send(l2tx: L2Transaction, method_name: string) {\n    const data = new Reader(core.SerializeL2Transaction(NormalizeL2Transaction(l2tx))).serializeJson();\n    return await this.rpcCall(method_name, data);\n  }\n\n  async executeL2Transaction(l2tx: L2Transaction): Promise<RunResult> {\n    return this._send(l2tx, \"execute_l2transaction\");\n  }\n\n  async submitL2Transaction(l2tx: L2Transaction): Promise<Hash> {\n    return this._send(l2tx, \"submit_l2transaction\");\n  }\n\n  async executeRawL2Transaction(rawL2Tx: RawL2Transaction): Promise<RunResult> {\n    const hex = new Reader(core.SerializeRawL2Transaction(NormalizeRawL2Transaction(rawL2Tx))).serializeJson();\n    return await this.rpcCall(\"execute_raw_l2transaction\", hex);\n  }\n\n  async submitWithdrawalRequest(request: WithdrawalRequest): Promise<void> {\n    const data = new Reader(core.SerializeWithdrawalRequest(NormalizeWithdrawalRequest(request))).serializeJson();\n    return await this.rpcCall(\"submit_withdrawal_request\", data);\n  }\n\n  async submitWithdrawalReqV1(reqExtra: WithdrawalRequestExtra): Promise<Hash> {\n    const data = new Reader(\n      SerializeWithdrawalRequestExtra(normalizer.NormalizeWithdrawalReqExtra(reqExtra)),\n    ).serializeJson();\n    return await this.rpcCall(\"submit_withdrawal_request\", data);\n  }\n\n  // TODO\n  // async function getWithdrawal(withdrawalHash: Hash) {\n  //   withdrawal_hash\n  // }\n\n  async getScriptHashByShortAddress(address: HexString): Promise<Hash> {\n    return await this.rpcCall(\"get_script_hash_by_short_address\", address);\n  }\n\n  // TODO: maybe swap params later?\n  async getBalance(sudt_id: Uint32, address: HexString): Promise<Uint128> {\n    const sudt_id_hex = `0x${(+sudt_id).toString(16)}`;\n    const balance = await this.rpcCall(\"get_balance\", address, sudt_id_hex);\n    return BigInt(balance);\n  }\n\n  async getBalanceById(sudt_id: Uint32, account_id: Uint32): Promise<Uint128> {\n    const scriptHash = await this.getScriptHash(account_id);\n    const address = scriptHash.slice(0, 42);\n    const balance = await this.getBalance(sudt_id, address);\n    return balance;\n  }\n\n  async getStorageAt(account_id: Uint32, key: Hash): Promise<Hash> {\n    const account_id_hex = `0x${account_id.toString(16)}`;\n    return await this.rpcCall(\"get_storage_at\", account_id_hex, key);\n  }\n\n  async getAccountIdByScriptHash(script_hash: Hash): Promise<Uint32 | undefined> {\n    const id = await this.rpcCall(\"get_account_id_by_script_hash\", script_hash);\n    return id ? +id : undefined;\n  }\n\n  async getNonce(account_id: Uint32): Promise<Uint32> {\n    const account_id_hex = `0x${account_id.toString(16)}`;\n    const nonce = await this.rpcCall(\"get_nonce\", account_id_hex);\n    return parseInt(nonce);\n  }\n\n  async getScript(script_hash: Hash): Promise<Script> {\n    return await this.rpcCall(\"get_script\", script_hash);\n  }\n\n  async getScriptHash(account_id: Uint32): Promise<Hash> {\n    const account_id_hex = `0x${account_id.toString(16)}`;\n    return await this.rpcCall(\"get_script_hash\", account_id_hex);\n  }\n\n  async getData(data_hash: Hash): Promise<HexString> {\n    return await this.rpcCall(\"get_data\", data_hash);\n  }\n\n  async hasDataHash(data_hash: Hash): Promise<boolean> {\n    return await this.rpcCall(\"get_data_hash\", data_hash);\n  }\n\n  async getTransactionReceipt(l2_tx_hash: Hash) {\n    return await this.rpcCall(\"get_transaction_receipt\", l2_tx_hash);\n  }\n\n  async getLastSubmittedInfo(): Promise<LastL2BlockCommittedInfo> {\n    return await this.rpcCall(\"get_last_submitted_info\");\n  }\n}\n\nexport class GodwokenUtils {\n  private rollup_type_hash: Hash;\n\n  constructor(rollup_type_hash: Hash) {\n    this.rollup_type_hash = rollup_type_hash;\n  }\n\n  generateTransactionMessageWithoutPrefixToSign(\n    raw_l2tx: RawL2Transaction,\n    sender_script_hash: Hash,\n    receiver_script_hash: Hash,\n  ): Hash {\n    const raw_tx_data = core.SerializeRawL2Transaction(NormalizeRawL2Transaction(raw_l2tx));\n    const rollup_type_hash = Buffer.from(this.rollup_type_hash.slice(2), \"hex\");\n    const senderScriptHash = Buffer.from(sender_script_hash.slice(2), \"hex\");\n    const receiverScriptHash = Buffer.from(receiver_script_hash.slice(2), \"hex\");\n    const data = toArrayBuffer(\n      Buffer.concat([rollup_type_hash, senderScriptHash, receiverScriptHash, toBuffer(raw_tx_data)]),\n    );\n    const message = utils.ckbHash(data).serializeJson();\n    return message;\n  }\n\n  generateTransactionMessageToSign(\n    raw_l2tx: RawL2Transaction,\n    sender_script_hash: Hash,\n    receiver_script_hash: Hash,\n  ): Hash {\n    const message = this.generateTransactionMessageWithoutPrefixToSign(\n      raw_l2tx,\n      sender_script_hash,\n      receiver_script_hash,\n    );\n    const prefix_buf = Buffer.from(`\\x19Ethereum Signed Message:\\n32`);\n    const buf = Buffer.concat([prefix_buf, Buffer.from(message.slice(2), \"hex\")]);\n    return `0x${keccak256(buf).toString(\"hex\")}`;\n  }\n\n  generateWithdrawalMessageWithoutPrefixToSign(raw_request: RawWithdrawalRequest): Hash {\n    const raw_request_data = core.SerializeRawWithdrawalRequest(NormalizeRawWithdrawalRequest(raw_request));\n    const rollup_type_hash = Buffer.from(this.rollup_type_hash.slice(2), \"hex\");\n    const data = toArrayBuffer(Buffer.concat([rollup_type_hash, toBuffer(raw_request_data)]));\n    const message = utils.ckbHash(data).serializeJson();\n    return message;\n  }\n\n  generateWithdrawalMessageToSign(raw_request: RawWithdrawalRequest): Hash {\n    const message = this.generateWithdrawalMessageWithoutPrefixToSign(raw_request);\n    const prefix_buf = Buffer.from(`\\x19Ethereum Signed Message:\\n32`);\n    const buf = Buffer.concat([prefix_buf, Buffer.from(message.slice(2), \"hex\")]);\n    return `0x${keccak256(buf).toString(\"hex\")}`;\n  }\n\n  static createAccountRawL2Transaction(\n    from_id: Uint32,\n    nonce: Uint32,\n    script: Script,\n    sudt_id: Uint32 = 1,\n    fee_amount: Uint128 = BigInt(0),\n  ): RawL2Transaction {\n    const create_account = {\n      script,\n      fee: {\n        sudt_id: \"0x\" + (+sudt_id).toString(16),\n        amount: \"0x\" + BigInt(fee_amount).toString(16),\n      },\n    };\n    const enum_tag = \"0x00000000\";\n    const create_account_part = new Reader(\n      core.SerializeCreateAccount(NormalizeCreateAccount(create_account)),\n    ).serializeJson();\n    const args = enum_tag + create_account_part.slice(2);\n    return {\n      from_id: u32ToHex(from_id),\n      to_id: u32ToHex(0),\n      nonce: u32ToHex(nonce),\n      args,\n    };\n  }\n\n  static createRawWithdrawalRequest(\n    nonce: Uint32,\n    capacity: Uint64,\n    amount: Uint128,\n    sudt_script_hash: Hash,\n    account_script_hash: Hash,\n    sell_amount: Uint128,\n    sell_capacity: Uint64,\n    owner_lock_hash: Hash,\n    payment_lock_hash: Hash,\n    fee: Fee,\n  ): RawWithdrawalRequest {\n    return {\n      nonce: \"0x\" + BigInt(nonce).toString(16),\n      capacity: \"0x\" + BigInt(capacity).toString(16),\n      amount: \"0x\" + BigInt(amount).toString(16),\n      sudt_script_hash: sudt_script_hash,\n      account_script_hash: account_script_hash,\n      sell_amount: \"0x\" + BigInt(sell_amount).toString(16),\n      sell_capacity: \"0x\" + BigInt(sell_capacity).toString(16),\n      owner_lock_hash: owner_lock_hash,\n      payment_lock_hash: payment_lock_hash,\n      fee,\n    };\n  }\n}\n","import { Hash, HexNumber, HexString, PackedSince, Script } from \"@ckb-lumos/base\";\nimport { normalizers, Reader } from \"ckb-js-toolkit\";\nimport { L2Transaction, WithdrawalRequest, WithdrawalRequestExtra, WithdrawalRequestV1 } from \"./types\";\n\n// Taken for now from https://github.com/xxuejie/ckb-js-toolkit/blob/68f5ff709f78eb188ee116b2887a362123b016cc/src/normalizers.js#L17-L69,\n// later we can think about exposing those functions directly.\nfunction normalizeHexNumber(length: number) {\n  return function (debugPath: string, value: any) {\n    if (!(value instanceof ArrayBuffer)) {\n      let intValue = BigInt(value).toString(16);\n      if (intValue.length % 2 !== 0) {\n        intValue = \"0\" + intValue;\n      }\n      if (intValue.length / 2 > length) {\n        throw new Error(`${debugPath} is ${intValue.length / 2} bytes long, expected length is ${length}!`);\n      }\n      const view = new DataView(new ArrayBuffer(length));\n      for (let i = 0; i < intValue.length / 2; i++) {\n        const start = intValue.length - (i + 1) * 2;\n        view.setUint8(i, parseInt(intValue.substr(start, 2), 16));\n      }\n      value = view.buffer;\n    }\n    if (value.byteLength < length) {\n      const array = new Uint8Array(length);\n      array.set(new Uint8Array(value), 0);\n      value = array.buffer;\n    }\n    return value;\n  };\n}\n\nfunction normalizeRawData(length: number) {\n  return function (debugPath: string, value: any) {\n    value = new Reader(value).toArrayBuffer();\n    if (length > 0 && value.byteLength !== length) {\n      throw new Error(`${debugPath} has invalid length ${value.byteLength}, required: ${length}`);\n    }\n    return value;\n  };\n}\n\nfunction normalizeObject(debugPath: string, obj: any, keys: object) {\n  const result: any = {};\n\n  for (const [key, f] of Object.entries(keys)) {\n    const value = obj[key];\n    if (value === undefined || value === null) {\n      throw new Error(`${debugPath} is missing ${key}!`);\n    }\n    result[key] = f(`${debugPath}.${key}`, value);\n  }\n  return result;\n}\n\nfunction toNormalize(normalize: Function) {\n  return function (debugPath: string, value: any) {\n    return normalize(value, {\n      debugPath,\n    });\n  };\n}\n\nexport interface DepositRequest {\n  capacity: HexNumber;\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n  script: Script;\n}\n\nexport function NormalizeDepositRequest(request: object, { debugPath = \"deposit_request\" } = {}) {\n  return normalizeObject(debugPath, request, {\n    capacity: normalizeHexNumber(8),\n    amount: normalizeHexNumber(16),\n    sudt_script_hash: normalizeRawData(32),\n    script: toNormalize(normalizers.NormalizeScript),\n  });\n}\n\nexport interface DepositLockArgs {\n  owner_lock_hash: Hash;\n  layer2_lock: Script;\n  cancel_timeout: PackedSince;\n}\n\nexport function NormalizeDepositLockArgs(args: object, { debugPath = \"deposit_lock_args\" } = {}) {\n  return normalizeObject(debugPath, args, {\n    owner_lock_hash: normalizeRawData(32),\n    layer2_lock: toNormalize(normalizers.NormalizeScript),\n    cancel_timeout: normalizeHexNumber(8),\n  });\n}\n\nexport interface HeaderInfo {\n  number: HexNumber;\n  block_hash: Hash;\n}\n\nexport function NormalizeHeaderInfo(headerInfo: object, { debugPath = \"header_info\" } = {}) {\n  return normalizeObject(debugPath, headerInfo, {\n    number: normalizeHexNumber(8),\n    block_hash: normalizeRawData(32),\n  });\n}\n\nexport interface CustodianLockArgs {\n  deposit_block_hash: Hash;\n  deposit_block_number: HexNumber;\n  deposit_lock_args: DepositLockArgs;\n}\n\nexport function NormalizeCustodianLockArgs(args: object, { debugPath = \"custondian_lock_args\" } = {}) {\n  return normalizeObject(debugPath, args, {\n    deposit_block_hash: normalizeRawData(32),\n    deposit_block_number: normalizeHexNumber(8),\n    deposit_lock_args: toNormalize(NormalizeDepositLockArgs),\n  });\n}\n\nexport function NormalizeRawL2Transaction(rawL2Transaction: object, { debugPath = \"raw_l2_transaction\" } = {}) {\n  return normalizeObject(debugPath, rawL2Transaction, {\n    from_id: normalizeHexNumber(4),\n    to_id: normalizeHexNumber(4),\n    nonce: normalizeHexNumber(4),\n    args: normalizeRawData(-1),\n  });\n}\n\nexport function NormalizeL2Transaction(l2Transaction: L2Transaction, { debugPath = \"l2_transaction\" } = {}) {\n  return normalizeObject(debugPath, l2Transaction, {\n    raw: toNormalize(NormalizeRawL2Transaction),\n    signature: normalizeRawData(-1),\n  });\n}\n\nexport function NormalizeRawWithdrawalRequest(raw_request: object, { debugPath = \"raw_withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, raw_request, {\n    nonce: normalizeHexNumber(4),\n    capacity: normalizeHexNumber(8),\n    amount: normalizeHexNumber(16),\n    sudt_script_hash: normalizeRawData(32),\n    account_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    owner_lock_hash: normalizeRawData(32),\n    payment_lock_hash: normalizeRawData(32),\n    fee: toNormalize(NormalizeFee),\n  });\n}\n\nexport function NormalizeRawWithdrawalRequestV1(raw_request_v1: object, { debugPath = \"raw_withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, raw_request_v1, {\n    nonce: normalizeHexNumber(4),\n    chain_id: normalizeHexNumber(8),\n    // CKB amount\n    capacity: normalizeHexNumber(8),\n    // SUDT amount\n    amount: normalizeHexNumber(16),\n    sudt_script_hash: normalizeRawData(32),\n    // layer2 account_script_hash\n    account_script_hash: normalizeRawData(32),\n    // layer1 lock to withdraw after challenge period\n    owner_lock_hash: normalizeRawData(32),\n    // withdrawal fee, paid to block producer\n    fee: normalizeHexNumber(8),\n  });\n}\n\nexport function NormalizeWithdrawalRequestV1(\n  request_v1: WithdrawalRequestV1,\n  { debugPath = \"withdrawal_request\" } = {},\n) {\n  return normalizeObject(debugPath, request_v1, {\n    raw: toNormalize(NormalizeRawWithdrawalRequestV1),\n    signature: normalizeRawData(65),\n  });\n}\n\nexport function NormalizeWithdrawalReqExtra(\n  withdrawalReqExtra: WithdrawalRequestExtra,\n  { debugPath = \"withdrawal_request\" } = {},\n) {\n  return normalizeObject(debugPath, withdrawalReqExtra, {\n    request: toNormalize(NormalizeWithdrawalRequestV1),\n    owner_lock: toNormalize(normalizers.NormalizeScript),\n  });\n}\n\nexport function NormalizeWithdrawalRequest(request: WithdrawalRequest, { debugPath = \"withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, request, {\n    raw: toNormalize(NormalizeRawWithdrawalRequest),\n    signature: normalizeRawData(65),\n  });\n}\n\nexport interface UnoinType {\n  type: string;\n  value: any;\n}\n\nexport function NormalizeFee(fee: object, { debugPath = \"fee\" } = {}) {\n  return normalizeObject(debugPath, fee, {\n    sudt_id: normalizeHexNumber(4),\n    amount: normalizeHexNumber(16),\n  });\n}\n\nexport function NormalizeCreateAccount(createAccount: object, { debugPath = \"create_account\" } = {}) {\n  return normalizeObject(debugPath, createAccount, {\n    script: toNormalize(normalizers.NormalizeScript),\n    fee: toNormalize(NormalizeFee),\n  });\n}\n\nexport interface SUDTQuery {\n  short_address: HexString;\n}\n\nexport function NormalizeSUDTQuery(sudt_query: object, { debugPath = \"sudt_query\" } = {}) {\n  return normalizeObject(debugPath, sudt_query, {\n    short_address: normalizeRawData(20),\n  });\n}\n\nexport interface SUDTTransfer {\n  to: HexString;\n  amount: HexNumber;\n  fee: HexNumber;\n}\n\nexport function NormalizeSUDTTransfer(sudt_transfer: object, { debugPath = \"sudt_transfer\" } = {}) {\n  return normalizeObject(debugPath, sudt_transfer, {\n    to: normalizeRawData(20),\n    amount: normalizeHexNumber(16),\n    fee: normalizeHexNumber(16),\n  });\n}\n\nexport function NormalizeWithdrawalLockArgs(withdrawal_lock_args: object, { debugPath = \"withdrawal_lock_args\" } = {}) {\n  return normalizeObject(debugPath, withdrawal_lock_args, {\n    // the original deposit info\n    // used for helping programs generate reverted custodian cell\n    // deposit_block_hash: normalizeRawData(32),\n    // deposit_block_number: normalizeHexNumber(8),\n    account_script_hash: normalizeRawData(32),\n    // the original custodian lock hash\n    withdrawal_block_hash: normalizeRawData(32),\n    withdrawal_block_number: normalizeHexNumber(8),\n    // buyer can pay sell_amount token to unlock\n    sudt_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    // layer1 lock to withdraw after challenge period\n    owner_lock_hash: normalizeRawData(32),\n    // layer1 lock to receive the payment, must exists on the chain\n    payment_lock_hash: normalizeRawData(32),\n  });\n}\n\nexport function NormalizeUnlockWithdrawalViaFinalize(\n  unlock_withdrawal_finalize: object,\n  { debugPath = \"unlock_withdrawal_finalize\" } = {},\n) {\n  return normalizeObject(debugPath, unlock_withdrawal_finalize, {});\n}\n","export const SCRIPTS = {\n  eth_account_lock: {\n    script_type_hash: \"0xed470b3ce58c73a9673cbb28cf34a44d0b85ed1b5bef0eea4b3c475344379b39\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xf19a616f3f556d9a8d2455b8744cc29bcfccbf90f4bc877a91d4b40fba13ac67\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  deposit_lock: {\n    script_type_hash: \"0x33ac8fb80e43697a8b886883cc650136fa6e8e9c261eb335b6fc1f8d54b74870\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x529f6c9413e5e386454131294c6122736b6a681f0d9cfce8683dfc4701885a68\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  polyjuice_generator: {\n    script_type_hash: \"0x4ce86361c74ca046a775b860cd1faa62aca4d4d6c2178137ab8ad899a11fffee\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xaea5ecadbd91dbd5133f78b54bd749eec34f79bfaaba8690d3cdeb5377392d11\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  l2_sudt_validator: {\n    script_type_hash: \"0x76479d9e2773fe0bae011345d085b59b6e7c4d80f392799a7d7041305ec61c73\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x29b7809236c53e0245cc45d93349687810e0d1c57ebe82334f84aaaf64d6fb44\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  meta_contract_validator: {\n    script_type_hash: \"0xafaa3646deaa86d1a4734b9a9a778468ad5c4fb5fc22873310bd8a41ae7b5421\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xbcd23414f5e8efd419b1cedd107a6f985c78e110f9a9237f65176675fad7aba9\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  custodian_lock: {\n    script_type_hash: \"0x5f86d23b30daec1fcbcde129eceda31f6f813b2b517804cf4aed08b442e7d606\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x3c774b747039c5d15fcbe4f455ddf14c298e92b81a5d71ec93c7c6b14ae558e6\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  l2_sudt_generator: {\n    script_type_hash: \"0xcbd0184a794a47ac5abc53434bdf11dfc615bb68f38a9169204cc4bb234350ad\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x02fdaa1137f624b9782abe7020f9b147a65034da0fddeab6e1ffb913ec165bb0\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  state_validator_lock: {\n    script_type_hash: \"0x84bdbca813620c03f7cf5af8f23559f09ab22619cb4de0aa1e0c72fc3074ecf9\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x582827f0c6bee23ab4679aee1e3bfea56effc02d9e501e70b51e685cb7ad0cfc\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  challenge_lock: {\n    script_type_hash: \"0x839585217150517810da3f55930fc9ead100e007d1bb393ed9bb872b54ed4080\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x991ca391cc092873ebf45b72378e959d78ef8f07bbe4f2096d0939072086d277\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  meta_contract_generator: {\n    script_type_hash: \"0x74af9b7b1b2e797db3b308599926360b83211a75991f1991ffff3817d12c699f\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x056b466a51e791f7b4bf8bac64826dd2844500f06a9f25a4ce1372b52aea8e71\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  always_success: {\n    script_type_hash: \"0x38bea2c593d5426b839b721d2b7a5e6953d9dbc8d738220f3d332cd26393597f\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xf3ff1c8c590ad95fbdf65c1fd70f5be2edde510766dd20cd9c2c043a4d38b121\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  state_validator: {\n    script_type_hash: \"0x5826d84d9345d6688602762773662aec64d765b4cbc01284b4de1aa361dfc300\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xbee9869a0839fb9cd17fadba6a3b3313779d8d340eb04fa4fbd0cfe7b8c5cc12\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  polyjuice_validator: {\n    script_type_hash: \"0x10a3fb3e485491c71c097b971078600ef5f7ef492c2c5bf9411dfe7538211f74\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x06ce06917e134939e8f1e5ac34cdeccd6b8b3048a5e895d89ec0c7e5fd63b174\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  poa_state: {\n    script_type_hash: \"0xcdc3c7b3178eebd8dcd035d1dae452dbed1d9d22a480977bbc59c786f9baa130\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xe8f46f0c968d25f883785bc5a218f61d9df728de79b1f6a120533b2a3c1ebe09\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  stake_lock: {\n    script_type_hash: \"0xef984822bac9ddaa865c1bca61beda671ec3b86dc83fe8f909954da730e82901\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x4442e58cd2c4f43b6cf537590c96ce5b97204227690e6e7d5816cd283026cd8e\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  withdrawal_lock: {\n    script_type_hash: \"0xa410542a29f3bbd3ee0a176f0283b5db3fb6c86d3aef406f4d4917ff9609d832\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xa4e05a31cbc153c4a667183e5dee23fa542e4fc19d63a8c70f6327fad3d1de28\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  tron_account_lock: {\n    script_type_hash: \"0x22268916b3aab4db9abd206eac646ad14fb2b5611dc5af4ba8fa883a109c7dcd\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x686ad028595d906cbeac1cbe93ca86d8c73c54902b9ce201aef579ffa3f9c435\",\n        index: \"0x1\",\n      },\n      dep_type: \"code\",\n    },\n  },\n};\n\nexport const ROLLUP_CONFIG = {\n  rollup_type_hash: \"0xac6737b05b357756fd7c17bb583672967a186515d9815af0f3b221943c13d167\",\n  rollup_type_script: {\n    code_hash: \"0x5826d84d9345d6688602762773662aec64d765b4cbc01284b4de1aa361dfc300\",\n    hash_type: \"type\",\n    args: \"0x53d7905bfe0aeb1aba147cb12d3b45c6974ade43e1f21fa350c5498624fac362\",\n  },\n  genesis: {\n    timestamp: 1647264360462,\n    meta_contract_validator_type_hash: \"0xafaa3646deaa86d1a4734b9a9a778468ad5c4fb5fc22873310bd8a41ae7b5421\",\n    rollup_type_hash: \"0xac6737b05b357756fd7c17bb583672967a186515d9815af0f3b221943c13d167\",\n    rollup_config: {\n      l1_sudt_script_type_hash: \"0x080f242d92ab7c7c5cda8f17a6eeb8592206429e451fbb66bae16231a4845e67\",\n      custodian_script_type_hash: \"0x5f86d23b30daec1fcbcde129eceda31f6f813b2b517804cf4aed08b442e7d606\",\n      deposit_script_type_hash: \"0x33ac8fb80e43697a8b886883cc650136fa6e8e9c261eb335b6fc1f8d54b74870\",\n      withdrawal_script_type_hash: \"0xa410542a29f3bbd3ee0a176f0283b5db3fb6c86d3aef406f4d4917ff9609d832\",\n      challenge_script_type_hash: \"0x839585217150517810da3f55930fc9ead100e007d1bb393ed9bb872b54ed4080\",\n      stake_script_type_hash: \"0xef984822bac9ddaa865c1bca61beda671ec3b86dc83fe8f909954da730e82901\",\n      l2_sudt_validator_script_type_hash: \"0x76479d9e2773fe0bae011345d085b59b6e7c4d80f392799a7d7041305ec61c73\",\n      burn_lock_hash: \"0x77c93b0632b5b6c3ef922c5b7cea208fb0a7c427a13d50e13d3fefad17e0c590\",\n      required_staking_capacity: \"0x2540be400\",\n      challenge_maturity_blocks: \"0x64\",\n      finality_blocks: \"0x64\",\n      reward_burn_rate: \"0x32\",\n      allowed_eoa_type_hashes: [\n        \"0xed470b3ce58c73a9673cbb28cf34a44d0b85ed1b5bef0eea4b3c475344379b39\",\n        \"0x22268916b3aab4db9abd206eac646ad14fb2b5611dc5af4ba8fa883a109c7dcd\",\n      ],\n      allowed_contract_type_hashes: [\n        \"0xafaa3646deaa86d1a4734b9a9a778468ad5c4fb5fc22873310bd8a41ae7b5421\",\n        \"0x76479d9e2773fe0bae011345d085b59b6e7c4d80f392799a7d7041305ec61c73\",\n        \"0x10a3fb3e485491c71c097b971078600ef5f7ef492c2c5bf9411dfe7538211f74\",\n      ],\n    },\n    secp_data_dep: {\n      dep_type: \"code\",\n      out_point: {\n        tx_hash: \"0x6dd0b20f37a03939f40f26a6a41a9ad3baa9abdc37086e74879c52dd35c8664c\",\n        index: \"0x3\",\n      },\n    },\n  },\n  rpc_client: {\n    indexer_url: \"http://indexer:8116\",\n    ckb_url: \"http://ckb:8114\",\n  },\n};\n","import * as LocalLayer2Config from \"./localLayer2Config\";\nconst SCRIPTS_V0 = {\n  deposit_lock: {\n    script_type_hash: \"0x5a2506bb68d81a11dcadad4cb7eae62a17c43c619fe47ac8037bc8ce2dd90360\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x97614145cdec9ba924001c11cd49f1c424927437b40ed3ca3b82fff358f2e3de\",\n        index: \"0x0\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  withdrawal_lock: {\n    script_type_hash: \"0x170ef156e9f6132dbca6069dfd3e436f7d91c29d3ac7332c4b33e633b6a299b5\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xb4b07dcd1571ac18683b515ada40e13b99bd0622197b6817047adc9f407f4828\",\n        index: \"0x0\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  eth_account_lock: {\n    script_type_hash: \"0xdeec13a7b8e100579541384ccaf4b5223733e4a5483c3aec95ddc4c1d5ea5b22\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0x2f9f8ec8a1556238aeeefed29e990d53ea75060ef04249371fd8b5246fffb8ea\",\n        index: \"0x0\",\n      },\n      dep_type: \"code\",\n    },\n  },\n};\nconst ROLLUP_CONFIG_V0 = {\n  rollup_type_hash: \"0x4cc2e6526204ae6a2e8fcf12f7ad472f41a1606d5b9624beebd215d780809f6a\",\n  rollup_type_script: {\n    code_hash: \"0x5c365147bb6c40e817a2a53e0dec3661f7390cc77f0c02db138303177b12e9fb\",\n    hash_type: \"type\",\n    args: \"0x213743d13048e9f36728c547ab736023a7426e15a3d7d1c82f43ec3b5f266df2\",\n  },\n};\nconst SCRIPTS_V1 = {\n  deposit_lock: {\n    script_type_hash: \"0xcc2b4e14d7dfeb1e72f7708ac2d7f636ae222b003bac6bccfcf8f4dfebd9c714\",\n  },\n  withdrawal_lock: {\n    script_type_hash: \"0x318e8882bec0339fa20584f4791152e71d5b71c5dbd8bf988fd511373e142222\",\n    cell_dep: {\n      out_point: {\n        tx_hash: \"0xb4b07dcd1571ac18683b515ada40e13b99bd0622197b6817047adc9f407f4828\",\n        index: \"0x0\",\n      },\n      dep_type: \"code\",\n    },\n  },\n  eth_account_lock: {\n    script_type_hash: \"0x10571f91073fdc3cdef4ddad96b4204dd30d6355f3dda9a6d7fc0fa0326408da\",\n  },\n  omni_lock: {\n    code_hash: \"0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e\",\n    hash_type: \"type\",\n    tx_hash: \"0x9154df4f7336402114d04495175b37390ce86a4906d2d4001cf02c3e6d97f39c\",\n    index: \"0x0\",\n    dep_type: \"code\",\n  },\n  secp256k1_blake160: {\n    code_hash: \"0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8\",\n    hash_type: \"type\",\n    tx_hash: \"0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37\",\n    index: \"0x0\",\n    dep_type: \"dep_group\",\n    short_id: 0,\n  },\n  sudt: {\n    code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n    hash_type: \"type\",\n    tx_hash: \"0xe12877ebd2c3c364dc46c5c992bcfaf4fee33fa13eebdf82c591fc9825aab769\",\n    index: \"0x0\",\n    dep_type: \"code\",\n  },\n};\nconst ROLLUP_CONFIG_V1 = {\n  rollup_type_hash: \"0x4940246f168f4106429dc641add3381a44b5eef61e7754142f594e986671a575\",\n  rollup_type_script: {\n    code_hash: \"0x0d3bfeaa292a59fcb58ed026e8f14e2167bd27f1765aa4b2af7d842b6123c6a9\",\n    hash_type: \"type\",\n    args: \"0x8137c84a9089f92fee684ac840532ee1133b012a9d42b6b76b74fbdde6999230\",\n  },\n};\n\nexport type Layer2Config = {\n  SCRIPTS: {\n    deposit_lock: {\n      script_type_hash: string;\n    };\n    withdrawal_lock: {\n      script_type_hash: string;\n      cell_dep: {\n        out_point: {\n          tx_hash: string;\n          index: string;\n        };\n        dep_type: string;\n      };\n    };\n    eth_account_lock: {\n      script_type_hash: string;\n    };\n  };\n  ROLLUP_CONFIG: {\n    rollup_type_hash: string;\n    rollup_type_script: {\n      code_hash: string;\n      hash_type: string;\n      args: string;\n    };\n  };\n};\n\nexport type Layer2Env = \"local\" | \"testnet_v1\" | \"testnet_v0\" | \"mainnet\";\n\nexport const getLayer2Config = (env: Layer2Env = \"testnet_v1\"): Layer2Config => {\n  console.log(`getLayer2Config env: ${env}`);\n\n  if (env === \"testnet_v0\") {\n    return {\n      SCRIPTS: SCRIPTS_V0,\n      ROLLUP_CONFIG: ROLLUP_CONFIG_V0,\n    };\n  } else if (env === \"testnet_v1\") {\n    return {\n      SCRIPTS: SCRIPTS_V1,\n      ROLLUP_CONFIG: ROLLUP_CONFIG_V1,\n    };\n  } else if (env === \"local\") {\n    return {\n      SCRIPTS: LocalLayer2Config.SCRIPTS,\n      ROLLUP_CONFIG: LocalLayer2Config.ROLLUP_CONFIG,\n    };\n  } else if (env === \"mainnet\") {\n    return {\n      SCRIPTS: SCRIPTS_V1,\n      ROLLUP_CONFIG: ROLLUP_CONFIG_V1,\n    };\n  }\n  throw new Error(\"invalid env\");\n};\n","export const PROVIDER_CONFIG = {\n  LINA: {\n    //TODO: fake urls\n    CKB_INDEXER_URL: \"https://testnet.ckb.dev/indexer\",\n    CKB_RPC_URL: \"https://testnet.ckb.dev\",\n    GW_POLYJUICE_RPC_URL: \"https://godwoken-testnet-web3-rpc.ckbapp.dev\",\n  },\n  AGGRON: {\n    CKB_INDEXER_URL: \"https://testnet.ckb.dev/indexer\",\n    CKB_RPC_URL: \"https://testnet.ckb.dev\",\n    GW_POLYJUICE_RPC_URL: \"https://godwoken-testnet-web3-rpc.ckbapp.dev\",\n  },\n  GODWOKEN_V1: {\n    CKB_INDEXER_URL: \"https://testnet.ckb.dev/indexer\",\n    CKB_RPC_URL: \"https://testnet.ckb.dev\",\n    GW_POLYJUICE_RPC_URL: \"https://godwoken-testnet-web3-v1-rpc.ckbapp.dev\",\n  },\n};\n","import { Hash, HexNumber, HexString, PackedSince, Script } from \"@ckb-lumos/lumos\";\nimport { normalizers, Reader } from \"ckb-js-toolkit\";\n\n// Taken for now from https://github.com/xxuejie/ckb-js-toolkit/blob/68f5ff709f78eb188ee116b2887a362123b016cc/src/normalizers.js#L17-L69,\n// later we can think about exposing those functions directly.\nfunction normalizeHexNumber(length: number) {\n  return function (debugPath: string, value: any) {\n    if (!(value instanceof ArrayBuffer)) {\n      let intValue = BigInt(value).toString(16);\n      if (intValue.length % 2 !== 0) {\n        intValue = \"0\" + intValue;\n      }\n      if (intValue.length / 2 > length) {\n        throw new Error(`${debugPath} is ${intValue.length / 2} bytes long, expected length is ${length}!`);\n      }\n      const view = new DataView(new ArrayBuffer(length));\n      for (let i = 0; i < intValue.length / 2; i++) {\n        const start = intValue.length - (i + 1) * 2;\n        view.setUint8(i, parseInt(intValue.substr(start, 2), 16));\n      }\n      value = view.buffer;\n    }\n    if (value.byteLength < length) {\n      const array = new Uint8Array(length);\n      array.set(new Uint8Array(value), 0);\n      value = array.buffer;\n    }\n    return value;\n  };\n}\n\nfunction normalizeRawData(length: number) {\n  return function (debugPath: string, value: any) {\n    value = new Reader(value).toArrayBuffer();\n    if (length > 0 && value.byteLength !== length) {\n      throw new Error(`${debugPath} has invalid length ${value.byteLength}, required: ${length}`);\n    }\n    return value;\n  };\n}\n\nfunction normalizeObject(debugPath: string, obj: any, keys: object) {\n  const result: any = {};\n\n  for (const [key, f] of Object.entries(keys)) {\n    const value = obj[key];\n    if (value === undefined || value === null) {\n      throw new Error(`${debugPath} is missing ${key}!`);\n    }\n    result[key] = f(`${debugPath}.${key}`, value);\n  }\n  return result;\n}\n\nfunction toNormalize(normalize: Function) {\n  return function (debugPath: string, value: any) {\n    return normalize(value, {\n      debugPath,\n    });\n  };\n}\n\nexport interface DepositLockArgs {\n  owner_lock_hash: Hash;\n  layer2_lock: Script;\n  cancel_timeout: PackedSince;\n}\n\nexport function NormalizeDepositLockArgs(args: object, { debugPath = \"deposit_lock_args\" } = {}) {\n  return normalizeObject(debugPath, args, {\n    owner_lock_hash: normalizeRawData(32),\n    layer2_lock: toNormalize(normalizers.NormalizeScript),\n    cancel_timeout: normalizeHexNumber(8),\n  });\n}\n\n/**\n * sudt_id: uint32\n * amount: uint128\n */\nexport interface Fee {\n  sudt_id: HexNumber;\n  amount: HexNumber;\n}\n\nexport function NormalizeFee(fee: object, { debugPath = \"fee\" } = {}) {\n  return normalizeObject(debugPath, fee, {\n    sudt_id: normalizeHexNumber(4),\n    amount: normalizeHexNumber(16),\n  });\n}\n\nexport interface RawWithdrawalRequest {\n  nonce: HexNumber;\n  // CKB amount\n  capacity: HexNumber;\n  // SUDT amount\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n  // layer2 account_script_hash\n  account_script_hash: Hash;\n  // buyer can pay sell_amount and sell_capacity to unlock\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n  fee: Fee;\n}\nexport interface WithdrawalRequest {\n  raw: RawWithdrawalRequest;\n  signature: HexString;\n}\n\nexport function NormalizeRawWithdrawalRequest(raw_request: object, { debugPath = \"raw_withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, raw_request, {\n    nonce: normalizeHexNumber(4),\n    capacity: normalizeHexNumber(8),\n    amount: normalizeHexNumber(16),\n    sudt_script_hash: normalizeRawData(32),\n    account_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    owner_lock_hash: normalizeRawData(32),\n    payment_lock_hash: normalizeRawData(32),\n    fee: toNormalize(NormalizeFee),\n  });\n}\n\nexport function NormalizeWithdrawalRequest(request: WithdrawalRequest, { debugPath = \"withdrawal_request\" } = {}) {\n  return normalizeObject(debugPath, request, {\n    raw: toNormalize(NormalizeRawWithdrawalRequest),\n    signature: normalizeRawData(65),\n  });\n}\n\nexport interface WithdrawalLockArgs {\n  // layer2 account script hash\n  account_script_hash: Hash;\n  withdrawal_block_hash: Hash;\n  withdrawal_block_number: HexNumber;\n  // buyer can pay sell_amount token to unlock\n  sudt_script_hash: Hash;\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n}\n\nexport function NormalizeWithdrawalLockArgs(\n  withdrawal_lock_args: WithdrawalLockArgs,\n  { debugPath = \"withdrawal_lock_args\" } = {},\n) {\n  return normalizeObject(debugPath, withdrawal_lock_args, {\n    account_script_hash: normalizeRawData(32),\n    withdrawal_block_hash: normalizeRawData(32),\n    withdrawal_block_number: normalizeHexNumber(8),\n    sudt_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    owner_lock_hash: normalizeRawData(32),\n    payment_lock_hash: normalizeRawData(32),\n  });\n}\n\nexport function NormalizeUnlockWithdrawalViaFinalize(\n  unlock_withdrawal_finalize: object,\n  { debugPath = \"unlock_withdrawal_finalize\" } = {},\n) {\n  return normalizeObject(debugPath, unlock_withdrawal_finalize, {});\n}\n\nexport interface RawL2Transaction {\n  from_id: HexNumber;\n  to_id: HexNumber;\n  nonce: HexNumber;\n  args: HexString;\n}\n\nexport function NormalizeRawL2Transaction(\n  rawL2Transaction: RawL2Transaction,\n  { debugPath = \"raw_l2_transaction\" } = {},\n) {\n  return normalizeObject(debugPath, rawL2Transaction, {\n    from_id: normalizeHexNumber(4),\n    to_id: normalizeHexNumber(4),\n    nonce: normalizeHexNumber(4),\n    args: normalizeRawData(-1),\n  });\n}\n\nexport interface L2Transaction {\n  raw: RawL2Transaction;\n  signature: HexString;\n}\n\nexport function NormalizeL2Transaction(l2Transaction: L2Transaction, { debugPath = \"l2_transaction\" } = {}) {\n  return normalizeObject(debugPath, l2Transaction, {\n    raw: toNormalize(NormalizeRawL2Transaction),\n    signature: normalizeRawData(-1),\n  });\n}\n","/* eslint-disable */\nfunction dataLengthError(actual, required) {\n  throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n}\n\nfunction assertDataLength(actual, required) {\n  if (actual !== required) {\n    dataLengthError(actual, required);\n  }\n}\n\nfunction assertArrayBuffer(reader) {\n  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n    reader = reader.toArrayBuffer();\n  }\n  if (!(reader instanceof ArrayBuffer)) {\n    throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n  }\n  return reader;\n}\n\nfunction verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n  if (view.byteLength < 4) {\n    dataLengthError(view.byteLength, \">4\");\n  }\n  const requiredByteLength = view.getUint32(0, true);\n  assertDataLength(view.byteLength, requiredByteLength);\n  if (requiredByteLength === 4) {\n    return [requiredByteLength];\n  }\n  if (requiredByteLength < 8) {\n    dataLengthError(view.byteLength, \">8\");\n  }\n  const firstOffset = view.getUint32(4, true);\n  if (firstOffset % 4 !== 0 || firstOffset < 8) {\n    throw new Error(`Invalid first offset: ${firstOffset}`);\n  }\n  const itemCount = firstOffset / 4 - 1;\n  if (itemCount < expectedFieldCount) {\n    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  } else if (!compatible && itemCount > expectedFieldCount) {\n    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  }\n  if (requiredByteLength < firstOffset) {\n    throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n  }\n  const offsets = [];\n  for (let i = 0; i < itemCount; i++) {\n    const start = 4 + i * 4;\n    offsets.push(view.getUint32(start, true));\n  }\n  offsets.push(requiredByteLength);\n  for (let i = 0; i < offsets.length - 1; i++) {\n    if (offsets[i] > offsets[i + 1]) {\n      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n    }\n  }\n  return offsets;\n}\n\nfunction serializeTable(buffers) {\n  const itemCount = buffers.length;\n  let totalSize = 4 * (itemCount + 1);\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    offsets.push(totalSize);\n    totalSize += buffers[i].byteLength;\n  }\n\n  const buffer = new ArrayBuffer(totalSize);\n  const array = new Uint8Array(buffer);\n  const view = new DataView(buffer);\n\n  view.setUint32(0, totalSize, true);\n  for (let i = 0; i < itemCount; i++) {\n    view.setUint32(4 + i * 4, offsets[i], true);\n    array.set(new Uint8Array(buffers[i]), offsets[i]);\n  }\n  return buffer;\n}\n\nexport class Uint32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Uint32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Uint32(this.view.buffer.slice(4 + i * Uint32.size(), 4 + (i + 1) * Uint32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeUint32Vec(value) {\n  const array = new Uint8Array(4 + Uint32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeUint32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Uint32.size());\n  }\n  return array.buffer;\n}\n\nexport class BlockMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class AccountMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, AccountMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeAccountMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class GlobalStateV0 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(\n      this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n      { validate: false },\n    );\n  }\n\n  getBlock() {\n    return new BlockMerkleState(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getStatus() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size(),\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalStateV0.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      1\n    );\n  }\n}\n\nexport function SerializeGlobalStateV0(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      1,\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.reverted_block_root)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.tip_block_hash)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n    value.status,\n  );\n  return array.buffer;\n}\n\nexport class GlobalState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(\n      this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n      { validate: false },\n    );\n  }\n\n  getBlock() {\n    return new BlockMerkleState(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTipBlockTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getStatus() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size(),\n    );\n  }\n\n  getVersion() {\n    return this.view.getUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        1,\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalState.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getTipBlockTimestamp().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1 +\n      1\n    );\n  }\n}\n\nexport function SerializeGlobalState(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1 +\n      1,\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.reverted_block_root)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.tip_block_hash)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.tip_block_timestamp)),\n    0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size(),\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size(),\n    value.status,\n  );\n  view.setUint8(\n    0 +\n      Byte32.size() +\n      AccountMerkleState.size() +\n      BlockMerkleState.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      1,\n    value.version,\n  );\n  return array.buffer;\n}\n\nexport class RollupConfig {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[10], offsets[11]), { validate: false }).validate();\n    if (offsets[12] - offsets[11] !== 1) {\n      throw new Error(`Invalid offset for reward_burn_rate: ${offsets[11]} - ${offsets[12]}`);\n    }\n    new Byte32Vec(this.view.buffer.slice(offsets[12], offsets[13]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[13], offsets[14]), { validate: false }).validate();\n  }\n\n  getL1SudtScriptTypeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCustodianScriptTypeHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositScriptTypeHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalScriptTypeHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeScriptTypeHash() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeScriptTypeHash() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2SudtValidatorScriptTypeHash() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBurnLockHash() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRequiredStakingCapacity() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeMaturityBlocks() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFinalityBlocks() {\n    const start = 44;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardBurnRate() {\n    const start = 48;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getAllowedEoaTypeHashes() {\n    const start = 52;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAllowedContractTypeHashes() {\n    const start = 56;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupConfig(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.l1_sudt_script_type_hash));\n  buffers.push(SerializeByte32(value.custodian_script_type_hash));\n  buffers.push(SerializeByte32(value.deposit_script_type_hash));\n  buffers.push(SerializeByte32(value.withdrawal_script_type_hash));\n  buffers.push(SerializeByte32(value.challenge_script_type_hash));\n  buffers.push(SerializeByte32(value.stake_script_type_hash));\n  buffers.push(SerializeByte32(value.l2_sudt_validator_script_type_hash));\n  buffers.push(SerializeByte32(value.burn_lock_hash));\n  buffers.push(SerializeUint64(value.required_staking_capacity));\n  buffers.push(SerializeUint64(value.challenge_maturity_blocks));\n  buffers.push(SerializeUint64(value.finality_blocks));\n  const rewardBurnRateView = new DataView(new ArrayBuffer(1));\n  rewardBurnRateView.setUint8(0, value.reward_burn_rate);\n  buffers.push(rewardBurnRateView.buffer);\n  buffers.push(SerializeByte32Vec(value.allowed_eoa_type_hashes));\n  buffers.push(SerializeByte32Vec(value.allowed_contract_type_hashes));\n  return serializeTable(buffers);\n}\n\nexport class RawL2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getFromId() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getToId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNonce() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getArgs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.from_id));\n  buffers.push(SerializeUint32(value.to_id));\n  buffers.push(SerializeUint32(value.nonce));\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class L2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Transaction(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class L2TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new L2Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2TransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeL2Transaction(item)));\n}\n\nexport class SubmitTransactions {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getTxWitnessRoot() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxCount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPrevStateCheckpoint() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSubmitTransactions(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.tx_witness_root));\n  buffers.push(SerializeUint32(value.tx_count));\n  buffers.push(SerializeByte32(value.prev_state_checkpoint));\n  return serializeTable(buffers);\n}\n\nexport class SubmitWithdrawals {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getWithdrawalWitnessRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SubmitWithdrawals.size());\n    this.getWithdrawalWitnessRoot().validate(compatible);\n    this.getWithdrawalCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeSubmitWithdrawals(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_witness_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.withdrawal_count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class RawL2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new SubmitWithdrawals(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new SubmitTransactions(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n  }\n\n  getNumber() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProducerId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getParentBlockHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeCellOwnerLockHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTimestamp() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPrevAccount() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPostAccount() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStateCheckpointList() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitWithdrawals() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new SubmitWithdrawals(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitTransactions() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SubmitTransactions(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.number));\n  buffers.push(SerializeUint32(value.block_producer_id));\n  buffers.push(SerializeByte32(value.parent_block_hash));\n  buffers.push(SerializeByte32(value.stake_cell_owner_lock_hash));\n  buffers.push(SerializeUint64(value.timestamp));\n  buffers.push(SerializeAccountMerkleState(value.prev_account));\n  buffers.push(SerializeAccountMerkleState(value.post_account));\n  buffers.push(SerializeByte32Vec(value.state_checkpoint_list));\n  buffers.push(SerializeSubmitWithdrawals(value.submit_withdrawals));\n  buffers.push(SerializeSubmitTransactions(value.submit_transactions));\n  return serializeTable(buffers);\n}\n\nexport class RawL2BlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new RawL2Block(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2BlockVec(value) {\n  return serializeTable(value.map((item) => SerializeRawL2Block(item)));\n}\n\nexport class L2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new L2TransactionVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new WithdrawalRequestVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawals() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new WithdrawalRequestVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeL2TransactionVec(value.transactions));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeWithdrawalRequestVec(value.withdrawals));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSudtScriptHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScript() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeByte32(value.sudt_script_hash));\n  buffers.push(SerializeScript(value.script));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new DepositRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new DepositRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequestVec(value) {\n  return serializeTable(value.map((item) => SerializeDepositRequest(item)));\n}\n\nexport class RawWithdrawalRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNonce() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getCapacity() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getAmount() {\n    return new Uint128(\n      this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size()),\n      { validate: false },\n    );\n  }\n\n  getSudtScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size(),\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellAmount() {\n    return new Uint128(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellCapacity() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getPaymentLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getFee() {\n    return new Fee(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint64.size() +\n          Uint128.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Fee.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawWithdrawalRequest.size());\n    this.getNonce().validate(compatible);\n    this.getCapacity().validate(compatible);\n    this.getAmount().validate(compatible);\n    this.getSudtScriptHash().validate(compatible);\n    this.getAccountScriptHash().validate(compatible);\n    this.getSellAmount().validate(compatible);\n    this.getSellCapacity().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n    this.getPaymentLockHash().validate(compatible);\n    this.getFee().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Fee.size()\n    );\n  }\n}\n\nexport function SerializeRawWithdrawalRequest(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Fee.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.nonce)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.capacity)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeByte32(value.sudt_script_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.account_script_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint128(value.sell_amount)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.sell_capacity)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n    0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.payment_lock_hash)),\n    0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeFee(value.fee)),\n    0 +\n      Uint32.size() +\n      Uint64.size() +\n      Uint128.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class WithdrawalRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new WithdrawalRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequestVec(value) {\n  return serializeTable(value.map((item) => SerializeWithdrawalRequest(item)));\n}\n\nexport class WithdrawalRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawWithdrawalRequest(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawWithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeRawWithdrawalRequest(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class KVPair {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getK() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getV() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeKVPair(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.k));\n  buffers.push(SerializeByte32(value.v));\n  return serializeTable(buffers);\n}\n\nexport class KVPairVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new KVPair(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new KVPair(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeKVPairVec(value) {\n  return serializeTable(value.map((item) => SerializeKVPair(item)));\n}\n\nexport class BlockInfo {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockProducerId() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockInfo.size());\n    this.getBlockProducerId().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getTimestamp().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint64.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockInfo(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint64.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.block_producer_id)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint64.size());\n  return array.buffer;\n}\n\nexport class DepositLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getOwnerLockHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLayer2Lock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCancelTimeout() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.owner_lock_hash));\n  buffers.push(SerializeScript(value.layer2_lock));\n  buffers.push(SerializeUint64(value.cancel_timeout));\n  return serializeTable(buffers);\n}\n\nexport class CustodianLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new DepositLockArgs(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getDepositLockArgs() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DepositLockArgs(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockNumber() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCustodianLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeDepositLockArgs(value.deposit_lock_args));\n  buffers.push(SerializeByte32(value.deposit_block_hash));\n  buffers.push(SerializeUint64(value.deposit_block_number));\n  return serializeTable(buffers);\n}\n\nexport class UnlockCustodianViaRevertWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getDepositLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockCustodianViaRevertWitness.size());\n    this.getDepositLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockCustodianViaRevertWitness(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.deposit_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class WithdrawalLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalBlockHash() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getWithdrawalBlockNumber() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Byte32.size() + Byte32.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  getSudtScriptHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size(),\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellAmount() {\n    return new Uint128(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getSellCapacity() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n        0 +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getPaymentLockHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size(),\n        0 +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Uint128.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, WithdrawalLockArgs.size());\n    this.getAccountScriptHash().validate(compatible);\n    this.getWithdrawalBlockHash().validate(compatible);\n    this.getWithdrawalBlockNumber().validate(compatible);\n    this.getSudtScriptHash().validate(compatible);\n    this.getSellAmount().validate(compatible);\n    this.getSellCapacity().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n    this.getPaymentLockHash().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size()\n    );\n  }\n}\n\nexport function SerializeWithdrawalLockArgs(value) {\n  const array = new Uint8Array(\n    0 +\n      Byte32.size() +\n      Byte32.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Uint128.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.account_script_hash)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_block_hash)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeUint64(value.withdrawal_block_number)), 0 + Byte32.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.sudt_script_hash)), 0 + Byte32.size() + Byte32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeUint128(value.sell_amount)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeUint64(value.sell_capacity)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.payment_lock_hash)),\n    0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class UnlockWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 2:\n        new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"UnlockWithdrawalViaFinalize\";\n      case 1:\n        return \"UnlockWithdrawalViaRevert\";\n      case 2:\n        return \"UnlockWithdrawalViaTrade\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false });\n      case 2:\n        return new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeUnlockWithdrawalWitness(value) {\n  switch (value.type) {\n    case \"UnlockWithdrawalViaFinalize\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaFinalize(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"UnlockWithdrawalViaRevert\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"UnlockWithdrawalViaTrade\": {\n      const itemBuffer = SerializeUnlockWithdrawalViaTrade(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class UnlockWithdrawalViaFinalize {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaFinalize(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class UnlockWithdrawalViaRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getCustodianLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockWithdrawalViaRevert.size());\n    this.getCustodianLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaRevert(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.custodian_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class UnlockWithdrawalViaTrade {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getOwnerLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaTrade(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.owner_lock));\n  return serializeTable(buffers);\n}\n\nexport class StakeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getStakeBlockNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, StakeLockArgs.size());\n    this.getOwnerLockHash().validate(compatible);\n    this.getStakeBlockNumber().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeStakeLockArgs(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.stake_block_number)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class MetaContractArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new CreateAccount(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"CreateAccount\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new CreateAccount(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeMetaContractArgs(value) {\n  switch (value.type) {\n    case \"CreateAccount\": {\n      const itemBuffer = SerializeCreateAccount(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class Fee {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSudtId() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getAmount() {\n    return new Uint128(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint128.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Fee.size());\n    this.getSudtId().validate(compatible);\n    this.getAmount().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint128.size();\n  }\n}\n\nexport function SerializeFee(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.sudt_id)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size());\n  return array.buffer;\n}\n\nexport class CreateAccount {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Fee(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getScript() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Fee(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCreateAccount(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.script));\n  buffers.push(SerializeFee(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class SUDTArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new SUDTQuery(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new SUDTTransfer(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"SUDTQuery\";\n      case 1:\n        return \"SUDTTransfer\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new SUDTQuery(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new SUDTTransfer(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeSUDTArgs(value) {\n  switch (value.type) {\n    case \"SUDTQuery\": {\n      const itemBuffer = SerializeSUDTQuery(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"SUDTTransfer\": {\n      const itemBuffer = SerializeSUDTTransfer(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class SUDTQuery {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getShortAddress() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTQuery(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.short_address));\n  return serializeTable(buffers);\n}\n\nexport class SUDTTransfer {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getTo() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTTransfer(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.to));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeUint128(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeTarget {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getTargetIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTargetType() {\n    return this.view.getUint8(0 + Byte32.size() + Uint32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, ChallengeTarget.size());\n    this.getBlockHash().validate(compatible);\n    this.getTargetIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size() + 1;\n  }\n}\n\nexport function SerializeChallengeTarget(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.block_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.target_index)), 0 + Byte32.size());\n  view.setUint8(0 + Byte32.size() + Uint32.size(), value.target_type);\n  return array.buffer;\n}\n\nexport class ChallengeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeTarget(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getTarget() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ChallengeTarget(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardsReceiverLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeTarget(value.target));\n  buffers.push(SerializeScript(value.rewards_receiver_lock));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeBytes(value.block_proof));\n  return serializeTable(buffers);\n}\n\nexport class ScriptVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScriptVec(value) {\n  return serializeTable(value.map((item) => SerializeScript(item)));\n}\n\nexport class BlockHashEntry {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockHashEntry.size());\n    this.getNumber().validate(compatible);\n    this.getHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + Byte32.size();\n  }\n}\n\nexport function SerializeBlockHashEntry(value) {\n  const array = new Uint8Array(0 + Uint64.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.hash)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class BlockHashEntryVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * BlockHashEntry.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new BlockHashEntry(\n      this.view.buffer.slice(4 + i * BlockHashEntry.size(), 4 + (i + 1) * BlockHashEntry.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBlockHashEntryVec(value) {\n  const array = new Uint8Array(4 + BlockHashEntry.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeBlockHashEntry(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * BlockHashEntry.size());\n  }\n  return array.buffer;\n}\n\nexport class VerifyTransactionContext {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ScriptVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new BlockHashEntryVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getAccountCount() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLoadData() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScripts() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getReturnDataHash() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashes() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BlockHashEntryVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionContext(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytesVec(value.load_data));\n  buffers.push(SerializeScriptVec(value.scripts));\n  buffers.push(SerializeByte32(value.return_data_hash));\n  buffers.push(SerializeBlockHashEntryVec(value.block_hashes));\n  return serializeTable(buffers);\n}\n\nexport class CKBMerkleProof {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32Vec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getIndices() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLemmas() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCKBMerkleProof(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32Vec(value.indices));\n  buffers.push(SerializeByte32Vec(value.lemmas));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new VerifyTransactionContext(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getL2Tx() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRawL2Block() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashesProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getContext() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new VerifyTransactionContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeBytes(value.block_hashes_proof));\n  buffers.push(SerializeVerifyTransactionContext(value.context));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionSignatureContext {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new ScriptVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getAccountCount() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScripts() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionSignatureContext(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeScriptVec(value.scripts));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionSignatureWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new L2Transaction(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new VerifyTransactionSignatureContext(this.view.buffer.slice(offsets[4], offsets[5]), {\n      validate: false,\n    }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2Tx() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getContext() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new VerifyTransactionSignatureContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionSignatureWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeVerifyTransactionSignatureContext(value.context));\n  return serializeTable(buffers);\n}\n\nexport class VerifyWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new WithdrawalRequest(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalRequest() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyWithdrawalWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeWithdrawalRequest(value.withdrawal_request));\n  buffers.push(SerializeCKBMerkleProof(value.withdrawal_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupSubmitBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getBlock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockHashes() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupSubmitBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Block(value.block));\n  buffers.push(SerializeByte32Vec(value.reverted_block_hashes));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupEnterChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeWitness(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getWitness() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ChallengeWitness(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupEnterChallenge(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeWitness(value.witness));\n  return serializeTable(buffers);\n}\n\nexport class RollupCancelChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n}\n\nexport function SerializeRollupCancelChallenge(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class RollupRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2BlockVec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getRevertedBlocks() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2BlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNewTipBlock() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupRevert(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2BlockVec(value.reverted_blocks));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  buffers.push(SerializeRawL2Block(value.new_tip_block));\n  return serializeTable(buffers);\n}\n\nexport class RollupAction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 1:\n        new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 2:\n        new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      case 3:\n        new RollupRevert(this.view.buffer.slice(4), { validate: false }).validate();\n        break;\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return \"RollupSubmitBlock\";\n      case 1:\n        return \"RollupEnterChallenge\";\n      case 2:\n        return \"RollupCancelChallenge\";\n      case 3:\n        return \"RollupRevert\";\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n      case 0:\n        return new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false });\n      case 1:\n        return new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false });\n      case 2:\n        return new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false });\n      case 3:\n        return new RollupRevert(this.view.buffer.slice(4), { validate: false });\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeRollupAction(value) {\n  switch (value.type) {\n    case \"RollupSubmitBlock\": {\n      const itemBuffer = SerializeRollupSubmitBlock(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupEnterChallenge\": {\n      const itemBuffer = SerializeRollupEnterChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupCancelChallenge\": {\n      const itemBuffer = SerializeRollupCancelChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    case \"RollupRevert\": {\n      const itemBuffer = SerializeRollupRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 3, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nexport class Uint16 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 2);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint16() {\n    return this.view.getUint16(0, false);\n  }\n\n  toLittleEndianUint16() {\n    return this.view.getUint16(0, true);\n  }\n\n  static size() {\n    return 2;\n  }\n}\n\nexport function SerializeUint16(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 2);\n  return buffer;\n}\n\nexport class Uint32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint32() {\n    return this.view.getUint32(0, false);\n  }\n\n  toLittleEndianUint32() {\n    return this.view.getUint32(0, true);\n  }\n\n  static size() {\n    return 4;\n  }\n}\n\nexport function SerializeUint32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 4);\n  return buffer;\n}\n\nexport class Uint64 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 8);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianBigUint64() {\n    return this.view.getBigUint64(0, false);\n  }\n\n  toLittleEndianBigUint64() {\n    return this.view.getBigUint64(0, true);\n  }\n\n  static size() {\n    return 8;\n  }\n}\n\nexport function SerializeUint64(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 8);\n  return buffer;\n}\n\nexport class Uint128 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 16);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 16;\n  }\n}\n\nexport function SerializeUint128(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 16);\n  return buffer;\n}\n\nexport class Byte32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeByte32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Uint256 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeUint256(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Bytes {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBytes(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nexport class BytesOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Bytes(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeBytesOpt(value) {\n  if (value) {\n    return SerializeBytes(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class BytesVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBytesVec(value) {\n  return serializeTable(value.map((item) => SerializeBytes(item)));\n}\n\nexport class Byte32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeByte32Vec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n  return array.buffer;\n}\n\nexport class ScriptOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Script(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeScriptOpt(value) {\n  if (value) {\n    return SerializeScript(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class ProposalShortId {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 10);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 10;\n  }\n}\n\nexport function SerializeProposalShortId(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 10);\n  return buffer;\n}\n\nexport class UncleBlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new UncleBlock(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlockVec(value) {\n  return serializeTable(value.map((item) => SerializeUncleBlock(item)));\n}\n\nexport class TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeTransaction(item)));\n}\n\nexport class ProposalShortIdVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new ProposalShortId(\n      this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()),\n      { validate: false },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeProposalShortIdVec(value) {\n  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeProposalShortId(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n  }\n  return array.buffer;\n}\n\nexport class CellDepVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellDep.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellDepVec(value) {\n  const array = new Uint8Array(4 + CellDep.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellDep(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n  }\n  return array.buffer;\n}\n\nexport class CellInputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellInput.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellInputVec(value) {\n  const array = new Uint8Array(4 + CellInput.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellInput(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n  }\n  return array.buffer;\n}\n\nexport class CellOutputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new CellOutput(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutputVec(value) {\n  return serializeTable(value.map((item) => SerializeCellOutput(item)));\n}\n\nexport class Script {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    if (offsets[2] - offsets[1] !== 1) {\n      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);\n    }\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCodeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHashType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getArgs() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScript(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.code_hash));\n  const hashTypeView = new DataView(new ArrayBuffer(1));\n  hashTypeView.setUint8(0, value.hash_type);\n  buffers.push(hashTypeView.buffer);\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class OutPoint {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, OutPoint.size());\n    this.getTxHash().validate(compatible);\n    this.getIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeOutPoint(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class CellInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSince() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getPreviousOutput() {\n    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellInput.size());\n    this.getSince().validate(compatible);\n    this.getPreviousOutput().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + OutPoint.size();\n  }\n}\n\nexport function SerializeCellInput(value) {\n  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class CellOutput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutput(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeScriptOpt(value.type_));\n  return serializeTable(buffers);\n}\n\nexport class CellDep {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOutPoint() {\n    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), { validate: false });\n  }\n\n  getDepType() {\n    return this.view.getUint8(0 + OutPoint.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellDep.size());\n    this.getOutPoint().validate(compatible);\n  }\n  static size() {\n    return 0 + OutPoint.size() + 1;\n  }\n}\n\nexport function SerializeCellDep(value) {\n  const array = new Uint8Array(0 + OutPoint.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n  view.setUint8(0 + OutPoint.size(), value.dep_type);\n  return array.buffer;\n}\n\nexport class RawTransaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getVersion() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCellDeps() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellDepVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHeaderDeps() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellInputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputs() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputsData() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.version));\n  buffers.push(SerializeCellDepVec(value.cell_deps));\n  buffers.push(SerializeByte32Vec(value.header_deps));\n  buffers.push(SerializeCellInputVec(value.inputs));\n  buffers.push(SerializeCellOutputVec(value.outputs));\n  buffers.push(SerializeBytesVec(value.outputs_data));\n  return serializeTable(buffers);\n}\n\nexport class Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawTransaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWitnesses() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawTransaction(value.raw));\n  buffers.push(SerializeBytesVec(value.witnesses));\n  return serializeTable(buffers);\n}\n\nexport class RawHeader {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getVersion() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getCompactTarget() {\n    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()),\n      { validate: false },\n    );\n  }\n\n  getNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getEpoch() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getParentHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getTransactionsRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getProposalsHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getExtraHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  getDao() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      { validate: false },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawHeader.size());\n    this.getVersion().validate(compatible);\n    this.getCompactTarget().validate(compatible);\n    this.getTimestamp().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getEpoch().validate(compatible);\n    this.getParentHash().validate(compatible);\n    this.getTransactionsRoot().validate(compatible);\n    this.getProposalsHash().validate(compatible);\n    this.getExtraHash().validate(compatible);\n    this.getDao().validate(compatible);\n  }\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size()\n    );\n  }\n}\n\nexport function SerializeRawHeader(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeUint64(value.epoch)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.parent_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.transactions_root)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.proposals_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.extra_hash)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.dao)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  return array.buffer;\n}\n\nexport class Header {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRaw() {\n    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), { validate: false });\n  }\n\n  getNonce() {\n    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Header.size());\n    this.getRaw().validate(compatible);\n    this.getNonce().validate(compatible);\n  }\n  static size() {\n    return 0 + RawHeader.size() + Uint128.size();\n  }\n}\n\nexport function SerializeHeader(value) {\n  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n  return array.buffer;\n}\n\nexport class UncleBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class BlockV1 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getExtension() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlockV1(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  buffers.push(SerializeBytes(value.extension));\n  return serializeTable(buffers);\n}\n\nexport class CellbaseWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getMessage() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellbaseWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeBytes(value.message));\n  return serializeTable(buffers);\n}\n\nexport class WitnessArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWitnessArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.lock));\n  buffers.push(SerializeBytesOpt(value.input_type));\n  buffers.push(SerializeBytesOpt(value.output_type));\n  return serializeTable(buffers);\n}\n","import { RPC, Reader } from \"ckb-js-toolkit\";\nimport { Hash, HexNumber, HexString } from \"@ckb-lumos/lumos\";\nimport { NormalizeWithdrawalRequest, WithdrawalRequest } from \"./normalizer\";\nimport { SerializeWithdrawalRequest } from \"../schemas/index.esm\";\n\ninterface LastL2BlockCommittedInfo {\n  transaction_hash: Hash;\n}\n/**\n * Godwoken RPC client\n */\nexport class GodwokenClient {\n  private rpc: RPC;\n\n  constructor(url: string) {\n    this.rpc = new RPC(url);\n  }\n\n  private async rpcCall(method_name: string, ...args: any[]): Promise<any> {\n    const name = \"gw_\" + method_name;\n    const result = await this.rpc[name](...args);\n    return result;\n  }\n\n  /**\n   * Serialize withdrawal request and submit to godwoken\n   *\n   * @param request\n   * @returns\n   */\n  async submitWithdrawalRequest(request: WithdrawalRequest): Promise<void> {\n    const data = new Reader(SerializeWithdrawalRequest(NormalizeWithdrawalRequest(request))).serializeJson();\n    return await this.rpcCall(\"submit_withdrawal_request\", data);\n  }\n\n  /**\n   *\n   * @param scriptHash layer2 lock script hash\n   * @returns uint32\n   */\n  async getAccountIdByScriptHash(scriptHash: Hash): Promise<HexNumber | undefined> {\n    const id = await this.rpcCall(\"get_account_id_by_script_hash\", scriptHash);\n    return id;\n  }\n\n  /**\n   *\n   * @param shortAddress scriptHash160 (scriptHash first 20 bytes)\n   * @returns uint32\n   */\n  async getScriptHashByShortAddress(shortAddress: HexString): Promise<Hash | undefined> {\n    const scriptHash = await this.rpcCall(\"get_script_hash_by_short_address\", shortAddress);\n    return scriptHash;\n  }\n  /**\n   *\n   * @param txHash Hash\n   * @returns uint32\n   */\n  async getWithdrawal(txHash: Hash): Promise<Hash | undefined> {\n    const withdrawal = await this.rpcCall(\"get_withdrawal\", txHash);\n    return withdrawal;\n  }\n  /**\n   *\n   * @param accountId uint32 in hex number\n   * @returns uint32 in hex number\n   */\n  async getNonce(accountId: HexNumber): Promise<HexNumber> {\n    const nonce = await this.rpcCall(\"get_nonce\", accountId);\n    return nonce;\n  }\n\n  async getLastSubmittedInfo(): Promise<LastL2BlockCommittedInfo> {\n    return await this.rpcCall(\"get_last_submitted_info\");\n  }\n  /**\n   *\n   * @param accountId uint32 in hex number\n   * @returns\n   */\n  async getScriptHash(accountId: HexNumber): Promise<Hash> {\n    return await this.rpcCall(\"get_script_hash\", accountId);\n  }\n}\n","/* eslint-disable */\n// Object.defineProperty(\n//   value: true\n// });\n\nfunction dataLengthError(actual, required) {\n  throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n}\n\nfunction assertDataLength(actual, required) {\n  if (actual !== required) {\n    dataLengthError(actual, required);\n  }\n}\n\nfunction assertArrayBuffer(reader) {\n  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n    reader = reader.toArrayBuffer();\n  }\n\n  if (!(reader instanceof ArrayBuffer)) {\n    throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n  }\n\n  return reader;\n}\n\nfunction verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n  if (view.byteLength < 4) {\n    dataLengthError(view.byteLength, \">4\");\n  }\n\n  const requiredByteLength = view.getUint32(0, true);\n  assertDataLength(view.byteLength, requiredByteLength);\n\n  if (requiredByteLength === 4) {\n    return [requiredByteLength];\n  }\n\n  if (requiredByteLength < 8) {\n    dataLengthError(view.byteLength, \">8\");\n  }\n\n  const firstOffset = view.getUint32(4, true);\n\n  if (firstOffset % 4 !== 0 || firstOffset < 8) {\n    throw new Error(`Invalid first offset: ${firstOffset}`);\n  }\n\n  const itemCount = firstOffset / 4 - 1;\n\n  if (itemCount < expectedFieldCount) {\n    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  } else if (!compatible && itemCount > expectedFieldCount) {\n    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  }\n\n  if (requiredByteLength < firstOffset) {\n    throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n  }\n\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    const start = 4 + i * 4;\n    offsets.push(view.getUint32(start, true));\n  }\n\n  offsets.push(requiredByteLength);\n\n  for (let i = 0; i < offsets.length - 1; i++) {\n    if (offsets[i] > offsets[i + 1]) {\n      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n    }\n  }\n\n  return offsets;\n}\n\nfunction serializeTable(buffers) {\n  const itemCount = buffers.length;\n  let totalSize = 4 * (itemCount + 1);\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    offsets.push(totalSize);\n    totalSize += buffers[i].byteLength;\n  }\n\n  const buffer = new ArrayBuffer(totalSize);\n  const array = new Uint8Array(buffer);\n  const view = new DataView(buffer);\n  view.setUint32(0, totalSize, true);\n\n  for (let i = 0; i < itemCount; i++) {\n    view.setUint32(4 + i * 4, offsets[i], true);\n    array.set(new Uint8Array(buffers[i]), offsets[i]);\n  }\n\n  return buffer;\n}\n\nclass Identity {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 21);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 21;\n  }\n}\n\nfunction SerializeIdentity(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 21);\n  return buffer;\n}\n\nclass RcIdentity {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Identity(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new SmtProofEntryVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getIdentity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Identity(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProofs() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProofEntryVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeRcIdentity(value) {\n  const buffers = [];\n  buffers.push(SerializeIdentity(value.identity));\n  buffers.push(SerializeSmtProofEntryVec(value.proofs));\n  return serializeTable(buffers);\n}\n\nclass RcIdentityOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new RcIdentity(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeRcIdentityOpt(value) {\n  if (value) {\n    return SerializeRcIdentity(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass RcLockWitnessLock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new RcIdentityOpt(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getSignature() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getRcIdentity() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RcIdentityOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getPreimage() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nexport function SerializeRcLockWitnessLock(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.signature));\n  buffers.push(SerializeRcIdentityOpt(value.rc_identity));\n  buffers.push(SerializeBytesOpt(value.preimage));\n  return serializeTable(buffers);\n}\n\nclass ScriptVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeScriptVec(value) {\n  return serializeTable(value.map((item) => SerializeScript(item)));\n}\n\nclass ScriptVecOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new ScriptVec(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeScriptVecOpt(value) {\n  if (value) {\n    return SerializeScriptVec(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass XudtWitnessInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ScriptVecOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getRawExtensionData() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ScriptVecOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getExtensionData() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeXudtWitnessInput(value) {\n  const buffers = [];\n  buffers.push(SerializeScriptVecOpt(value.raw_extension_data));\n  buffers.push(SerializeBytesVec(value.extension_data));\n  return serializeTable(buffers);\n}\n\nclass RCRule {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSmtRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getFlags() {\n    return this.view.getUint8(0 + Byte32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RCRule.size());\n    this.getSmtRoot().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + 1;\n  }\n}\n\nfunction SerializeRCRule(value) {\n  const array = new Uint8Array(0 + Byte32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.smt_root)), 0);\n  view.setUint8(0 + Byte32.size(), value.flags);\n  return array.buffer;\n}\n\nclass RCCellVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeRCCellVec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n\n  return array.buffer;\n}\n\nclass RCData {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        new RCRule(this.view.buffer.slice(4), {\n          validate: false,\n        }).validate();\n        break;\n\n      case 1:\n        new RCCellVec(this.view.buffer.slice(4), {\n          validate: false,\n        }).validate();\n        break;\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        return \"RCRule\";\n\n      case 1:\n        return \"RCCellVec\";\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        return new RCRule(this.view.buffer.slice(4), {\n          validate: false,\n        });\n\n      case 1:\n        return new RCCellVec(this.view.buffer.slice(4), {\n          validate: false,\n        });\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nfunction SerializeRCData(value) {\n  switch (value.type) {\n    case \"RCRule\": {\n      const itemBuffer = SerializeRCRule(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n\n    case \"RCCellVec\": {\n      const itemBuffer = SerializeRCCellVec(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nclass SmtProof {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeSmtProof(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nclass SmtProofEntry {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    if (offsets[1] - offsets[0] !== 1) {\n      throw new Error(`Invalid offset for mask: ${offsets[0]} - ${offsets[1]}`);\n    }\n\n    new SmtProof(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getMask() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProof(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeSmtProofEntry(value) {\n  const buffers = [];\n  const maskView = new DataView(new ArrayBuffer(1));\n  maskView.setUint8(0, value.mask);\n  buffers.push(maskView.buffer);\n  buffers.push(SerializeSmtProof(value.proof));\n  return serializeTable(buffers);\n}\n\nclass SmtProofEntryVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new SmtProofEntry(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new SmtProofEntry(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeSmtProofEntryVec(value) {\n  return serializeTable(value.map((item) => SerializeSmtProofEntry(item)));\n}\n\nclass SmtUpdateItem {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getKey() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getPackedValues() {\n    return this.view.getUint8(0 + Byte32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SmtUpdateItem.size());\n    this.getKey().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + 1;\n  }\n}\n\nfunction SerializeSmtUpdateItem(value) {\n  const array = new Uint8Array(0 + Byte32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.key)), 0);\n  view.setUint8(0 + Byte32.size(), value.packed_values);\n  return array.buffer;\n}\n\nclass SmtUpdateItemVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * SmtUpdateItem.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new SmtUpdateItem(this.view.buffer.slice(4 + i * SmtUpdateItem.size(), 4 + (i + 1) * SmtUpdateItem.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeSmtUpdateItemVec(value) {\n  const array = new Uint8Array(4 + SmtUpdateItem.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeSmtUpdateItem(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * SmtUpdateItem.size());\n  }\n\n  return array.buffer;\n}\n\nclass SmtUpdateAction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new SmtUpdateItemVec(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new SmtProof(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getUpdates() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new SmtUpdateItemVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProof(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeSmtUpdateAction(value) {\n  const buffers = [];\n  buffers.push(SerializeSmtUpdateItemVec(value.updates));\n  buffers.push(SerializeSmtProof(value.proof));\n  return serializeTable(buffers);\n}\n\nclass XudtData {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getData() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeXudtData(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.lock));\n  buffers.push(SerializeBytesVec(value.data));\n  return serializeTable(buffers);\n}\n\nclass Uint32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint32() {\n    return this.view.getUint32(0, false);\n  }\n\n  toLittleEndianUint32() {\n    return this.view.getUint32(0, true);\n  }\n\n  static size() {\n    return 4;\n  }\n}\n\nfunction SerializeUint32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 4);\n  return buffer;\n}\n\nclass Uint64 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 8);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 8;\n  }\n}\n\nfunction SerializeUint64(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 8);\n  return buffer;\n}\n\nclass Uint128 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 16);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 16;\n  }\n}\n\nfunction SerializeUint128(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 16);\n  return buffer;\n}\n\nclass Byte32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nfunction SerializeByte32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nclass Uint256 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nfunction SerializeUint256(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nclass Bytes {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeBytes(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nclass BytesOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Bytes(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeBytesOpt(value) {\n  if (value) {\n    return SerializeBytes(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass BytesVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeBytesVec(value) {\n  return serializeTable(value.map((item) => SerializeBytes(item)));\n}\n\nclass Byte32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeByte32Vec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n\n  return array.buffer;\n}\n\nclass ScriptOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Script(this.view.buffer, {\n      validate: false,\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nfunction SerializeScriptOpt(value) {\n  if (value) {\n    return SerializeScript(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass ProposalShortId {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 10);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 10;\n  }\n}\n\nfunction SerializeProposalShortId(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 10);\n  return buffer;\n}\n\nclass UncleBlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new UncleBlock(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeUncleBlockVec(value) {\n  return serializeTable(value.map((item) => SerializeUncleBlock(item)));\n}\n\nclass TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Transaction(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeTransactionVec(value) {\n  return serializeTable(value.map((item) => SerializeTransaction(item)));\n}\n\nclass ProposalShortIdVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new ProposalShortId(\n      this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeProposalShortIdVec(value) {\n  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeProposalShortId(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellDepVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * CellDep.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeCellDepVec(value) {\n  const array = new Uint8Array(4 + CellDep.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellDep(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellInputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * CellInput.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {\n      validate: false,\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nfunction SerializeCellInputVec(value) {\n  const array = new Uint8Array(4 + CellInput.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellInput(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellOutputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false,\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new CellOutput(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeCellOutputVec(value) {\n  return serializeTable(value.map((item) => SerializeCellOutput(item)));\n}\n\nclass Script {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n\n    if (offsets[2] - offsets[1] !== 1) {\n      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);\n    }\n\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getCodeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getHashType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getArgs() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeScript(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.code_hash));\n  const hashTypeView = new DataView(new ArrayBuffer(1));\n  hashTypeView.setUint8(0, value.hash_type);\n  buffers.push(hashTypeView.buffer);\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nclass OutPoint {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false,\n    });\n  }\n\n  getIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, OutPoint.size());\n    this.getTxHash().validate(compatible);\n    this.getIndex().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nfunction SerializeOutPoint(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nclass CellInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSince() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), {\n      validate: false,\n    });\n  }\n\n  getPreviousOutput() {\n    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellInput.size());\n    this.getSince().validate(compatible);\n    this.getPreviousOutput().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Uint64.size() + OutPoint.size();\n  }\n}\n\nfunction SerializeCellInput(value) {\n  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nclass CellOutput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeCellOutput(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeScriptOpt(value.type_));\n  return serializeTable(buffers);\n}\n\nclass CellDep {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOutPoint() {\n    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), {\n      validate: false,\n    });\n  }\n\n  getDepType() {\n    return this.view.getUint8(0 + OutPoint.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellDep.size());\n    this.getOutPoint().validate(compatible);\n  }\n\n  static size() {\n    return 0 + OutPoint.size() + 1;\n  }\n}\n\nfunction SerializeCellDep(value) {\n  const array = new Uint8Array(0 + OutPoint.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n  view.setUint8(0 + OutPoint.size(), value.dep_type);\n  return array.buffer;\n}\n\nclass RawTransaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), {\n      validate: false,\n    }).validate();\n    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), {\n      validate: false,\n    }).validate();\n  }\n\n  getVersion() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getCellDeps() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellDepVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getHeaderDeps() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getInputs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellInputVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getOutputs() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getOutputsData() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeRawTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.version));\n  buffers.push(SerializeCellDepVec(value.cell_deps));\n  buffers.push(SerializeByte32Vec(value.header_deps));\n  buffers.push(SerializeCellInputVec(value.inputs));\n  buffers.push(SerializeCellOutputVec(value.outputs));\n  buffers.push(SerializeBytesVec(value.outputs_data));\n  return serializeTable(buffers);\n}\n\nclass Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawTransaction(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getWitnesses() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawTransaction(value.raw));\n  buffers.push(SerializeBytesVec(value.witnesses));\n  return serializeTable(buffers);\n}\n\nclass RawHeader {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getVersion() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getCompactTarget() {\n    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {\n      validate: false,\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(\n      this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getNumber() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getEpoch() {\n    return new Uint64(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getParentHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getTransactionsRoot() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getProposalsHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getUnclesHash() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  getDao() {\n    return new Byte32(\n      this.view.buffer.slice(\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n        0 +\n          Uint32.size() +\n          Uint32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Uint64.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Byte32.size(),\n      ),\n      {\n        validate: false,\n      },\n    );\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawHeader.size());\n    this.getVersion().validate(compatible);\n    this.getCompactTarget().validate(compatible);\n    this.getTimestamp().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getEpoch().validate(compatible);\n    this.getParentHash().validate(compatible);\n    this.getTransactionsRoot().validate(compatible);\n    this.getProposalsHash().validate(compatible);\n    this.getUnclesHash().validate(compatible);\n    this.getDao().validate(compatible);\n  }\n\n  static size() {\n    return (\n      0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size()\n    );\n  }\n}\n\nfunction SerializeRawHeader(value) {\n  const array = new Uint8Array(\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n  array.set(\n    new Uint8Array(SerializeUint64(value.epoch)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.parent_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.transactions_root)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.proposals_hash)),\n    0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.uncles_hash)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  array.set(\n    new Uint8Array(SerializeByte32(value.dao)),\n    0 +\n      Uint32.size() +\n      Uint32.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Uint64.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size() +\n      Byte32.size(),\n  );\n  return array.buffer;\n}\n\nclass Header {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRaw() {\n    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), {\n      validate: false,\n    });\n  }\n\n  getNonce() {\n    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {\n      validate: false,\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Header.size());\n    this.getRaw().validate(compatible);\n    this.getNonce().validate(compatible);\n  }\n\n  static size() {\n    return 0 + RawHeader.size() + Uint128.size();\n  }\n}\n\nfunction SerializeHeader(value) {\n  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n  return array.buffer;\n}\n\nclass UncleBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProposals() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeUncleBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nclass Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), {\n      validate: false,\n    }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nclass CellbaseWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getMessage() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeCellbaseWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeBytes(value.message));\n  return serializeTable(buffers);\n}\n\nclass WitnessArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false,\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false,\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false,\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getInputType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n\n  getOutputType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false,\n    });\n  }\n}\n\nfunction SerializeWitnessArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.lock));\n  buffers.push(SerializeBytesOpt(value.input_type));\n  buffers.push(SerializeBytesOpt(value.output_type));\n  return serializeTable(buffers);\n}\n","import { CellDep, DepType } from \"@ckb-lumos/lumos\";\n\nexport const LAYER1_CONFIG = {\n  omni_lock: {\n    code_hash: \"0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e\",\n    hash_type: \"type\",\n    tx_hash: \"0x9154df4f7336402114d04495175b37390ce86a4906d2d4001cf02c3e6d97f39c\",\n    index: \"0x0\",\n    dep_type: \"code\",\n  },\n  secp256k1_blake160: {\n    code_hash: \"0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8\",\n    hash_type: \"type\",\n    tx_hash: \"0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37\",\n    index: \"0x0\",\n    dep_type: \"dep_group\",\n    short_id: 0,\n  },\n  sudt: {\n    code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n    hash_type: \"type\",\n    tx_hash: \"0xe12877ebd2c3c364dc46c5c992bcfaf4fee33fa13eebdf82c591fc9825aab769\",\n    index: \"0x0\",\n    dep_type: \"code\",\n  },\n};\n\nexport const OMNI_LOCK_CELL_DEP: CellDep = {\n  out_point: {\n    tx_hash: LAYER1_CONFIG.omni_lock.tx_hash,\n    index: LAYER1_CONFIG.omni_lock.index,\n  },\n  dep_type: LAYER1_CONFIG.omni_lock.dep_type as DepType,\n};\n\nexport const SECP256K1_BLACK160_CELL_DEP: CellDep = {\n  out_point: {\n    tx_hash: LAYER1_CONFIG.secp256k1_blake160.tx_hash,\n    index: LAYER1_CONFIG.secp256k1_blake160.index,\n  },\n  dep_type: LAYER1_CONFIG.secp256k1_blake160.dep_type as DepType,\n};\n\nexport const SUDT_CELL_DEP: CellDep = {\n  out_point: {\n    tx_hash: LAYER1_CONFIG.sudt.tx_hash,\n    index: LAYER1_CONFIG.sudt.index,\n  },\n  dep_type: LAYER1_CONFIG.sudt.dep_type as DepType,\n};\n","import { getLayer2Config } from \"./constants/index\";\nimport {\n  Address,\n  Indexer,\n  RPC,\n  config,\n  helpers,\n  Transaction,\n  HexString,\n  utils,\n  core,\n  toolkit,\n  Hash,\n  Cell,\n  HashType,\n  Script,\n  CellDep,\n} from \"@ckb-lumos/lumos\";\nimport { core as godwokenCore } from \"@polyjuice-provider/godwoken\";\nimport { PROVIDER_CONFIG } from \"./constants/providerConfig\";\nimport { PolyjuiceHttpProvider } from \"@polyjuice-provider/web3\";\nimport { SUDT_ERC20_PROXY_ABI } from \"./constants/sudtErc20ProxyAbi\";\nimport { AbiItems, PolyjuiceConfig } from \"@polyjuice-provider/base\";\nimport { GodwokenClient } from \"./godwoken/godwoken\";\nimport Web3 from \"web3\";\nimport { LightGodwokenProvider, LightGodwokenProviderConfig } from \"./lightGodwokenType\";\nimport { WithdrawalRequest } from \"./godwoken/normalizer\";\nimport { SerializeRcLockWitnessLock } from \"./omni-lock/index\";\nimport { TransactionWithStatus } from \"@ckb-lumos/base\";\nimport { LAYER1_CONFIG } from \"./constants/layer1ConfigUtils\";\n\nconst { SCRIPTS, ROLLUP_CONFIG } = getLayer2Config();\n\nexport const POLYJUICE_CONFIG = {\n  web3Url: PROVIDER_CONFIG.GODWOKEN_V1.GW_POLYJUICE_RPC_URL,\n  abiItems: SUDT_ERC20_PROXY_ABI as AbiItems,\n};\n\nexport const polyjuiceProvider = new PolyjuiceHttpProvider(\n  POLYJUICE_CONFIG.web3Url,\n  POLYJUICE_CONFIG as PolyjuiceConfig,\n);\n\nexport default class DefaultLightGodwokenProvider implements LightGodwokenProvider {\n  l2Address: Address = \"\";\n  l1Address: Address = \"\";\n  ckbIndexer;\n  rpc;\n  ethereum;\n  web3;\n  godwokenClient;\n  config;\n\n  constructor(ethAddress: Address, ethereum: any, env: LightGodwokenProviderConfig) {\n    let configObj = PROVIDER_CONFIG.GODWOKEN_V1;\n    if (env === \"v0\") {\n      config.initializeConfig(config.predefined.AGGRON4);\n      configObj = PROVIDER_CONFIG.AGGRON;\n    } else if (env === \"v1\") {\n      config.initializeConfig(config.predefined.AGGRON4);\n      configObj = PROVIDER_CONFIG.GODWOKEN_V1;\n    } else if (env === \"mainnet\") {\n      config.initializeConfig(config.predefined.LINA);\n      configObj = PROVIDER_CONFIG.LINA;\n    } else {\n      throw new Error(\"env not defined, please use AGGRON or LINA.\");\n    }\n    console.log(\"configObj\", configObj);\n\n    this.config = configObj;\n    this.ckbIndexer = new Indexer(configObj.CKB_INDEXER_URL, configObj.CKB_RPC_URL);\n    this.rpc = new RPC(configObj.CKB_RPC_URL);\n    this.godwokenClient = new GodwokenClient(configObj.GW_POLYJUICE_RPC_URL);\n\n    this.ethereum = ethereum;\n    this.l2Address = ethAddress;\n    this.l1Address = this.generateL1Address(this.l2Address);\n    ethereum.on(\"accountsChanged\", (accounts: any) => {\n      console.log(\"eth accounts changed\", accounts);\n      this.l2Address = accounts[0];\n      this.l1Address = this.generateL1Address(this.l2Address);\n    });\n\n    this.web3 = new Web3(polyjuiceProvider);\n  }\n\n  async sendWithdrawTransaction(withdrawalRequest: WithdrawalRequest): Promise<string> {\n    const result = await this.godwokenClient.submitWithdrawalRequest(withdrawalRequest);\n    return result as unknown as string;\n  }\n\n  getL2Address(): string {\n    return this.l2Address;\n  }\n  getL1Address(): string {\n    return this.l1Address;\n  }\n\n  static async CreateProvider(ethereum: any, version: LightGodwokenProviderConfig): Promise<LightGodwokenProvider> {\n    if (!ethereum || !ethereum.isMetaMask) {\n      throw new Error(\"please provide metamask ethereum object\");\n    }\n    return ethereum\n      .request({ method: \"eth_requestAccounts\" })\n      .then((accounts: any) => {\n        console.log(\"eth_requestAccounts\", accounts);\n        return new DefaultLightGodwokenProvider(accounts[0], ethereum, version);\n      })\n      .catch((error: any) => {\n        if (error.code === 4001) {\n          // EIP-1193 userRejectedRequest error\n          console.log(\"Please connect to MetaMask.\");\n        } else {\n          console.error(error);\n        }\n      });\n  }\n\n  generateL1Address(l2Address: Address): Address {\n    const omniLock: Script = {\n      code_hash: LAYER1_CONFIG.omni_lock.code_hash,\n      hash_type: LAYER1_CONFIG.omni_lock.hash_type as HashType,\n      // omni flag       pubkey hash   omni lock flags\n      // chain identity   eth addr      function flag()\n      // 00: Nervos                   00: owner\n      // 01: Ethereum                 01: administrator\n      //                            \n      args: `0x01${l2Address.substring(2)}00`,\n    };\n    return helpers.generateAddress(omniLock);\n  }\n\n  // // TODO the unknown is godwoken submit_withdrawal_tx\n  // sendWithdrawTransaction: (tx: unknown) => Promise<Hash>;\n\n  // // now only supported omni lock, the other lock type will be supported later\n  async sendL1Transaction(tx: Transaction): Promise<Hash> {\n    return await this.rpc.send_transaction(tx, \"passthrough\");\n  }\n\n  async signL1Transaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Transaction> {\n    const message = this.generateMessage(txSkeleton);\n    let signedMessage = await this.ethereum.request({\n      method: \"personal_sign\",\n      params: [this.ethereum.selectedAddress, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    const signedWitness = new toolkit.Reader(\n      core.SerializeWitnessArgs({\n        lock: SerializeRcLockWitnessLock({\n          signature: new toolkit.Reader(signedMessage),\n        }),\n      }),\n    ).serializeJson();\n    txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) => witnesses.push(`${signedWitness}`));\n    const signedTx = helpers.createTransactionFromSkeleton(txSkeleton);\n    return signedTx;\n  }\n\n  generateMessage(tx: helpers.TransactionSkeletonType): HexString {\n    const hasher = new utils.CKBHasher();\n    const rawTxHash = utils.ckbHash(\n      core.SerializeRawTransaction(\n        toolkit.normalizers.NormalizeRawTransaction(helpers.createTransactionFromSkeleton(tx)),\n      ),\n    );\n    const serializedWitness = core.SerializeWitnessArgs({\n      lock: new toolkit.Reader(\n        \"0x\" +\n          \"00\".repeat(\n            SerializeRcLockWitnessLock({\n              signature: new toolkit.Reader(\"0x\" + \"00\".repeat(65)),\n            }).byteLength,\n          ),\n      ),\n    });\n    hasher.update(rawTxHash);\n    this.hashWitness(hasher, serializedWitness);\n    return hasher.digestHex();\n  }\n\n  hashWitness(hasher: utils.CKBHasher, witness: ArrayBuffer): void {\n    const lengthBuffer = new ArrayBuffer(8);\n    const view = new DataView(lengthBuffer);\n    view.setBigUint64(0, BigInt(new toolkit.Reader(witness).length()), true);\n    hasher.update(lengthBuffer);\n    hasher.update(witness);\n  }\n\n  async getPendingTransaction(txHash: Hash): Promise<TransactionWithStatus | null> {\n    let tx: TransactionWithStatus | null = null;\n\n    // retry 10 times, and sleep 1s\n    for (let i = 0; i < 10; i++) {\n      tx = await this.rpc.get_transaction(txHash);\n      if (tx != null) {\n        return tx;\n      }\n      await this.asyncSleep(1000);\n    }\n    return null;\n  }\n\n  async getRollupCellDep(): Promise<CellDep> {\n    const result = await this.godwokenClient.getLastSubmittedInfo();\n    const txHash = result.transaction_hash;\n    const tx = await this.getPendingTransaction(txHash);\n\n    if (tx == null) {\n      throw new Error(\"Last submitted tx not found!\");\n    }\n\n    let rollupIndex = tx.transaction.outputs.findIndex((o: any) => {\n      return o.type && utils.computeScriptHash(o.type) === ROLLUP_CONFIG.rollup_type_hash;\n    });\n    return {\n      out_point: {\n        tx_hash: txHash,\n        index: `0x${rollupIndex.toString(16)}`,\n      },\n      dep_type: \"code\",\n    };\n  }\n\n  async getRollupCell(): Promise<Cell | undefined> {\n    const queryOptions = {\n      type: {\n        code_hash: ROLLUP_CONFIG.rollup_type_script.code_hash as Hash,\n        hash_type: ROLLUP_CONFIG.rollup_type_script.hash_type as HashType,\n        args: ROLLUP_CONFIG.rollup_type_script.args as HexString,\n      },\n    };\n    const collector = this.ckbIndexer.collector(queryOptions);\n    let rollupCell;\n    for await (const cell of collector.collect()) {\n      if (cell === null) {\n        return undefined;\n      } else {\n        rollupCell = cell;\n        break;\n      }\n    }\n    return rollupCell;\n  }\n\n  getLayer2LockScript(): Script {\n    const layer2Lock: Script = {\n      code_hash: SCRIPTS.eth_account_lock.script_type_hash as string,\n      hash_type: \"type\",\n      args: ROLLUP_CONFIG.rollup_type_hash + this.l2Address.slice(2).toLowerCase(),\n    };\n    return layer2Lock;\n  }\n\n  getLayer2LockScriptHash(): Hash {\n    const accountScriptHash = utils.computeScriptHash(this.getLayer2LockScript());\n    console.log(\"accountScriptHash\", accountScriptHash);\n    return accountScriptHash;\n  }\n\n  getLayer1LockScriptHash(): Hash {\n    const ownerCKBLock = helpers.parseAddress(this.l1Address);\n    const ownerLock: Script = {\n      code_hash: ownerCKBLock.code_hash,\n      args: ownerCKBLock.args,\n      hash_type: ownerCKBLock.hash_type as HashType,\n    };\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n    console.log(\"ownerLockHash\", ownerLockHash);\n    return ownerLockHash;\n  }\n\n  async getLastFinalizedBlockNumber(): Promise<number> {\n    const rollupCell = await this.getRollupCell();\n    if (!rollupCell === undefined) {\n      return 0;\n    }\n    const globalState = new godwokenCore.GlobalState(new toolkit.Reader(rollupCell!.data));\n    const lastFinalizedBlockNumber = Number(globalState.getLastFinalizedBlockNumber().toLittleEndianBigUint64());\n    console.log(\"last finalized block number: \", lastFinalizedBlockNumber);\n    return lastFinalizedBlockNumber;\n  }\n\n  async asyncSleep(ms = 0) {\n    return new Promise((r) => setTimeout(r, ms));\n  }\n}\n","export const SUDT_ERC20_PROXY_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"string\",\n        name: \"name_\",\n        type: \"string\",\n      },\n      {\n        internalType: \"string\",\n        name: \"symbol_\",\n        type: \"string\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"totalSupply_\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"sudtId_\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint8\",\n        name: \"decimals_\",\n        type: \"uint8\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Approval\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Transfer\",\n    type: \"event\",\n  },\n  {\n    inputs: [],\n    name: \"sudtId\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [\n      {\n        internalType: \"uint8\",\n        name: \"\",\n        type: \"uint8\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"recipient\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"transfer\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n    ],\n    name: \"allowance\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"approve\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"recipient\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"transferFrom\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"addedValue\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"increaseAllowance\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"subtractedValue\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"decreaseAllowance\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n","import { Cell, Hash, helpers, HexNumber, HexString, Script, toolkit, utils } from \"@ckb-lumos/lumos\";\nimport * as secp256k1 from \"secp256k1\";\nimport { getLayer2Config } from \"./constants/index\";\nimport { OMNI_LOCK_CELL_DEP, SECP256K1_BLACK160_CELL_DEP, SUDT_CELL_DEP } from \"./constants/layer1ConfigUtils\";\nimport {\n  NormalizeDepositLockArgs,\n  NormalizeRawWithdrawalRequest,\n  NormalizeWithdrawalLockArgs,\n  RawWithdrawalRequest,\n  WithdrawalLockArgs,\n} from \"./godwoken/normalizer\";\nimport LightGodwokenProvider, { POLYJUICE_CONFIG } from \"./lightGodwokenProvider\";\nimport {\n  DepositPayload,\n  GetErc20Balances,\n  GetErc20BalancesResult,\n  GetL1CkbBalancePayload,\n  GetL2CkbBalancePayload,\n  GetSudtBalances,\n  GetSudtBalancesResult,\n  GodwokenVersion,\n  LightGodwokenBase,\n  ProxyERC20,\n  SUDT,\n  WithdrawalEventEmitter,\n  WithdrawalEventEmitterPayload,\n  WithdrawResult,\n} from \"./lightGodwokenType\";\nimport {\n  SerializeDepositLockArgs,\n  SerializeRawWithdrawalRequest,\n  SerializeWithdrawalLockArgs,\n} from \"./schemas/index.esm\";\n\nconst { SCRIPTS, ROLLUP_CONFIG } = getLayer2Config();\n\nexport default abstract class DefaultLightGodwoken implements LightGodwokenBase {\n  provider: LightGodwokenProvider;\n\n  constructor(provider: LightGodwokenProvider) {\n    this.provider = provider;\n  }\n\n  abstract getBuiltinErc20List(): ProxyERC20[];\n\n  abstract getBuiltinSUDTList(): SUDT[];\n\n  abstract listWithdraw(): Promise<WithdrawResult[]>;\n\n  abstract getVersion(): GodwokenVersion;\n\n  abstract withdrawWithEvent(payload: WithdrawalEventEmitterPayload): WithdrawalEventEmitter;\n\n  async deposit(payload: DepositPayload): Promise<string> {\n    const neededCapacity = BigInt(payload.capacity);\n    const neededSudtAmount = payload.amount ? BigInt(payload.amount) : BigInt(0);\n    let collectedCapatity = BigInt(0);\n    let collectedSudtAmount = BigInt(0);\n    const collectedCells: Cell[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: helpers.parseAddress(this.provider.l1Address) });\n    for await (const cell of collector.collect()) {\n      console.log(cell);\n      if (\n        !cell.cell_output.type &&\n        (!cell.data || cell.data === \"0x\" || cell.data === \"0x0\") &&\n        collectedCapatity < neededCapacity\n      ) {\n        collectedCapatity += BigInt(cell.cell_output.capacity);\n        collectedCells.push(cell);\n        if (collectedCapatity >= neededCapacity && collectedSudtAmount >= neededSudtAmount) break;\n      } else if (\n        payload.sudtType &&\n        payload.sudtType.args === cell.cell_output.type?.args &&\n        collectedSudtAmount < neededSudtAmount\n      ) {\n        collectedCapatity += BigInt(cell.cell_output.capacity);\n        collectedSudtAmount += BigInt(utils.readBigUInt128LECompatible(cell.data).toBigInt());\n        collectedCells.push(cell);\n        if (collectedCapatity >= neededCapacity && collectedSudtAmount >= neededSudtAmount) break;\n      }\n    }\n    if (collectedCapatity < neededCapacity) {\n      throw new Error(`Not enough CKB, expected: ${neededCapacity}, actual: ${collectedCapatity} `);\n    }\n    if (collectedSudtAmount < neededSudtAmount) {\n      throw new Error(`Not enough SUDT, expected: ${neededSudtAmount}, actual: ${collectedSudtAmount} `);\n    }\n\n    const outputCell = this.generateDepositOutputCell(collectedCells, payload);\n    let txSkeleton = helpers.TransactionSkeleton({ cellProvider: this.provider.ckbIndexer });\n\n    txSkeleton = txSkeleton\n      .update(\"inputs\", (inputs) => {\n        return inputs.push(...collectedCells);\n      })\n      .update(\"outputs\", (outputs) => {\n        return outputs.push(...outputCell);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(OMNI_LOCK_CELL_DEP);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(SECP256K1_BLACK160_CELL_DEP);\n      });\n\n    if (payload.sudtType) {\n      txSkeleton = txSkeleton.update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(SUDT_CELL_DEP);\n      });\n    }\n\n    const signedTx = await this.provider.signL1Transaction(txSkeleton);\n    const txHash = await this.provider.sendL1Transaction(signedTx);\n    return txHash;\n  }\n\n  generateDepositOutputCell(collectedCells: Cell[], payload: DepositPayload): Cell[] {\n    const ownerLock: Script = helpers.parseAddress(this.provider.l1Address);\n    const ownerLockHash: Hash = utils.computeScriptHash(ownerLock);\n    const layer2Lock: Script = this.provider.getLayer2LockScript();\n\n    const depositLockArgs = {\n      owner_lock_hash: ownerLockHash,\n      layer2_lock: layer2Lock,\n      cancel_timeout: \"0xc0000000000004b0\",\n    };\n    const depositLockArgsHexString: HexString = new toolkit.Reader(\n      SerializeDepositLockArgs(NormalizeDepositLockArgs(depositLockArgs)),\n    ).serializeJson();\n    const depositLock: Script = {\n      code_hash: SCRIPTS.deposit_lock.script_type_hash,\n      hash_type: \"type\",\n      args: ROLLUP_CONFIG.rollup_type_hash + depositLockArgsHexString.slice(2),\n    };\n    const sumCapacity = collectedCells.reduce((acc, cell) => acc + BigInt(cell.cell_output.capacity), BigInt(0));\n    const sumSustAmount = collectedCells.reduce((acc, cell) => {\n      if (cell.cell_output.type) {\n        return acc + BigInt(utils.readBigUInt128LE(cell.data));\n      } else {\n        return acc;\n      }\n    }, BigInt(0));\n    const outputCell: Cell = {\n      cell_output: {\n        capacity: \"0x\" + BigInt(payload.capacity).toString(16),\n        lock: depositLock,\n      },\n      data: \"0x\",\n    };\n\n    // pay 0.0001 ckb for tx fee\n    const exchangeCapacity = BigInt(sumCapacity - BigInt(payload.capacity) - BigInt(100000));\n    const exchangeCell: Cell = {\n      cell_output: {\n        capacity: \"0x\" + exchangeCapacity.toString(16),\n        lock: helpers.parseAddress(this.provider.l1Address),\n      },\n      data: \"0x\",\n    };\n\n    if (payload.sudtType && payload.amount && payload.amount !== \"0x\" && payload.amount !== \"0x0\") {\n      outputCell.cell_output.type = payload.sudtType;\n      outputCell.data = utils.toBigUInt128LE(BigInt(payload.amount));\n\n      const sudtData = utils.toBigUInt128LE(sumSustAmount - BigInt(payload.amount));\n      const exchangeSudtCell: Cell = {\n        cell_output: {\n          capacity: \"0x0\",\n          lock: helpers.parseAddress(this.provider.l1Address),\n          type: payload.sudtType,\n        },\n        data: sudtData,\n      };\n      const sudtCapacity: bigint = helpers.minimalCellCapacity(exchangeSudtCell);\n\n      exchangeSudtCell.cell_output.capacity = \"0x\" + sudtCapacity.toString(16);\n\n      // minus sudt capacity from exchange cell\n      exchangeCell.cell_output.capacity = `0x${(exchangeCapacity - sudtCapacity).toString(16)}`;\n      return [outputCell, exchangeCell, exchangeSudtCell];\n    }\n\n    return [outputCell, exchangeCell];\n  }\n\n  /**\n   * get producing 1 block time\n   */\n  getBlockProduceTime(): number {\n    return 45 * 1000;\n  }\n\n  async getWithdrawal(txHash: Hash): Promise<unknown> {\n    const result = await this.provider.godwokenClient.getWithdrawal(txHash);\n    console.log(\"getWithdrawal result:\", result);\n    return result;\n  }\n\n  async signMessageMetamaskPersonalSign(message: Hash): Promise<HexString> {\n    let signedMessage = await this.provider.ethereum.request({\n      method: \"personal_sign\",\n      params: [this.provider.l2Address, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    return signedMessage;\n  }\n\n  async signMessageMetamaskEthSign(message: Hash): Promise<HexString> {\n    let signedMessage = await this.provider.ethereum.request({\n      method: \"eth_sign\",\n      params: [this.provider.l2Address, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    return signedMessage;\n  }\n\n  signMessage(message: Hash, privateKey: HexString): HexString {\n    const signObject = secp256k1.ecdsaSign(\n      new Uint8Array(new toolkit.Reader(message).toArrayBuffer()),\n      new Uint8Array(new toolkit.Reader(privateKey).toArrayBuffer()),\n    );\n    const signatureBuffer = new ArrayBuffer(65);\n    const signatureArray = new Uint8Array(signatureBuffer);\n    signatureArray.set(signObject.signature, 0);\n    let v = signObject.recid;\n    if (v >= 27) {\n      v -= 27;\n    }\n    signatureArray.set([v], 64);\n\n    const signature = new toolkit.Reader(signatureBuffer).serializeJson();\n    return signature;\n  }\n\n  generateWithdrawalMessageToSign(rawWithdrawalRequest: RawWithdrawalRequest, rollupTypeHash: Hash): Hash {\n    const serializedRawWithdrawalRequest: HexString = new toolkit.Reader(\n      SerializeRawWithdrawalRequest(NormalizeRawWithdrawalRequest(rawWithdrawalRequest)),\n    ).serializeJson();\n    const data = new toolkit.Reader(rollupTypeHash + serializedRawWithdrawalRequest.slice(2)).toArrayBuffer();\n    const message = utils.ckbHash(data).serializeJson();\n    return message;\n  }\n\n  minimalWithdrawalCapacity(isSudt: boolean): HexNumber {\n    // fixed size, the specific value is not important.\n    const dummyHash: Hash = \"0x\" + \"00\".repeat(32);\n    const dummyHexNumber: HexNumber = \"0x0\";\n    const dummyRollupTypeHash: Hash = dummyHash;\n    const dummyWithdrawalLockArgs: WithdrawalLockArgs = {\n      account_script_hash: dummyHash,\n      withdrawal_block_hash: dummyHash,\n      withdrawal_block_number: dummyHexNumber,\n      sudt_script_hash: dummyHash,\n      sell_amount: dummyHexNumber,\n      sell_capacity: dummyHexNumber,\n      owner_lock_hash: dummyHash,\n      payment_lock_hash: dummyHash,\n    };\n    const serialized: HexString = new toolkit.Reader(\n      SerializeWithdrawalLockArgs(NormalizeWithdrawalLockArgs(dummyWithdrawalLockArgs)),\n    ).serializeJson();\n    const args = dummyRollupTypeHash + serialized.slice(2);\n    const lock: Script = {\n      code_hash: dummyHash,\n      hash_type: \"data\",\n      args,\n    };\n    let type: Script | undefined = undefined;\n    let data = \"0x\";\n    if (isSudt) {\n      type = {\n        code_hash: dummyHash,\n        hash_type: \"data\",\n        args: dummyHash,\n      };\n      data = \"0x\" + \"00\".repeat(16);\n    }\n    const cell: Cell = {\n      cell_output: {\n        lock,\n        type,\n        capacity: dummyHexNumber,\n      },\n      data,\n    };\n    const capacity: bigint = helpers.minimalCellCapacity(cell);\n    return \"0x\" + capacity.toString(16);\n  }\n\n  async getL2CkbBalance(payload?: GetL2CkbBalancePayload): Promise<HexNumber> {\n    const balance = await this.provider.web3.eth.getBalance(payload?.l2Address || this.provider.l2Address);\n    return \"0x\" + Number(balance).toString(16);\n  }\n\n  async getL1CkbBalance(payload?: GetL1CkbBalancePayload): Promise<HexNumber> {\n    const collector = this.provider.ckbIndexer.collector({\n      lock: helpers.parseAddress(this.provider.l1Address),\n      type: \"empty\",\n      outputDataLenRange: [\"0x0\", \"0x1\"],\n    });\n    let collectedSum = BigInt(0);\n    for await (const cell of collector.collect()) {\n      collectedSum += BigInt(cell.cell_output.capacity);\n    }\n    return \"0x\" + collectedSum.toString(16);\n  }\n\n  async getErc20Balances(payload: GetErc20Balances): Promise<GetErc20BalancesResult> {\n    const result: GetErc20BalancesResult = { balances: [] };\n    let promises = [];\n    for (let index = 0; index < payload.addresses.length; index++) {\n      const address = payload.addresses[index];\n      const usdcContract = new this.provider.web3.eth.Contract(POLYJUICE_CONFIG.abiItems, address);\n      const usdcBalancePromise = usdcContract.methods.balanceOf(this.provider.l2Address).call();\n      promises.push(usdcBalancePromise);\n    }\n    await Promise.all(promises).then((values) => {\n      values.forEach((value) => {\n        result.balances.push(\"0x\" + Number(value).toString(16));\n      });\n    });\n    return result;\n  }\n\n  async getSudtBalances(payload: GetSudtBalances): Promise<GetSudtBalancesResult> {\n    const result: GetSudtBalancesResult = { balances: [] };\n    for (let index = 0; index < payload.types.length; index++) {\n      const type = payload.types[index];\n      const collector = this.provider.ckbIndexer.collector({\n        lock: helpers.parseAddress(this.provider.l1Address),\n        type,\n      });\n      let collectedSum = BigInt(0);\n      for await (const cell of collector.collect()) {\n        collectedSum += BigInt(utils.readBigUInt128LECompatible(cell.data).toBigInt());\n        collectedSum += BigInt(0);\n      }\n      result.balances.push(\"0x\" + collectedSum.toString(16));\n    }\n    return result;\n  }\n\n  async injectCapacity(\n    tx: helpers.TransactionSkeletonType,\n    fromScript: Script,\n    capacity: bigint,\n  ): Promise<helpers.TransactionSkeletonType> {\n    // additional 0.001 ckb for tx fee\n    // the tx fee could calculated by tx size\n    // this is just a simple example\n    const neededCapacity = capacity + BigInt(100000);\n    let collectedSum = BigInt(0);\n    const collectedCells: Cell[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: fromScript, type: \"empty\" });\n    for await (const cell of collector.collect()) {\n      if (!cell.data || cell.data === \"0x\" || cell.data === \"0x0\" || cell.data === \"0x00\") {\n        collectedSum += BigInt(cell.cell_output.capacity);\n        collectedCells.push(cell);\n        if (collectedSum >= neededCapacity) break;\n      }\n    }\n    if (collectedSum < neededCapacity) {\n      throw new Error(`Not enough CKB, expected: ${neededCapacity}, actual: ${collectedSum} `);\n    }\n    const changeOutput: Cell = {\n      cell_output: {\n        capacity: \"0x\" + BigInt(collectedSum - neededCapacity).toString(16),\n        lock: fromScript,\n      },\n      data: \"0x\",\n    };\n    tx = tx.update(\"inputs\", (inputs) => inputs.push(...collectedCells));\n    tx = tx.update(\"outputs\", (outputs) => outputs.push(changeOutput));\n    return tx;\n  }\n}\n","export const TOKEN_LIST = [\n  {\n    symbol: \"USDC\",\n    name: \"USD Coin\",\n    decimals: 18,\n    tokenURI: \"https://cryptologos.cc/logos/usd-coin-usdc-logo.svg?v=002\",\n    sudt_script_hash: \"\",\n    address: \"0xca6FcAAA5129aD9e5219397527A17c26E5AD6a6a\",\n    issuerLockHash: \"0x58bef38794236b315b7c23fd8132d7f42676228d659b291936e8c6c7ba9f064e\",\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x58bef38794236b315b7c23fd8132d7f42676228d659b291936e8c6c7ba9f064e\",\n    },\n  },\n  {\n    symbol: \"ETH\",\n    name: \"Ethereum\",\n    decimals: 18,\n    tokenURI: \"https://cryptologos.cc/logos/ethereum-eth-logo.svg?v=002\",\n    sudt_script_hash: \"\",\n    address: \"0xB1235Dd5bd72d9Ef2F0E311fC5ce7df0583B6458\",\n    issuerLockHash: \"0x1b072aa0ded384067106ea0c43c85bd71bafa5afdb432123511da46b390a4e33\",\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x1b072aa0ded384067106ea0c43c85bd71bafa5afdb432123511da46b390a4e33\",\n    },\n  },\n  {\n    symbol: \"TAI\",\n    name: \"NexisDAO TAI\",\n    decimals: 18,\n    tokenURI:\n      \"data:image/png;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAQDAwQDAwQEAwQFBAQFBgoHBgYGBg0JCggKDw0QEA8NDw4RExgUERIXEg4PFRwVFxkZGxsbEBQdHx0aHxgaGxr/2wBDAQQFBQYFBgwHBwwaEQ8RGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhr/wAARCAAoACgDASIAAhEBAxEB/8QAGgAAAgMBAQAAAAAAAAAAAAAAAAgEBQYBCf/EADQQAAEDAwEEBwUJAAAAAAAAAAIAAQQDBRIGBxETURUhIjJCUmIWgYKisggUFyczNEFTZ//EABkBAAMBAQEAAAAAAAAAAAAAAAMFBgIEB//EACQRAAEEAgEDBQEAAAAAAAAAAAMAAQIEERIFEyHCFCIxMoKS/9oADAMBAAIRAxEAPwB85kwIdPI/c3NZyVc68ot+TgHJmVHtFmhV0xqApFSbTj04FdiKA2+QI8Msipevy+pKXC1zGgEIWXbHe7Mfhj6js9Qh+IxHFcsti7aSUtctkKTSH1Ti5Fv35OpsW5Vo795zDk6V32y2hjZBuhbRtAdBvW4PS2RfqY5YY445Y9rHJZGbrmNNMgvG2O93gvFH09ZzEfhPHH5ks9ObbaJP52l4oIpyD7op8YcsJdNiB+v+W5IWE2cy6Q6a08cc5px6lvoMJT/3BNgOL1fX5vUhbrXR2IPv8x7KpCRyQy6muzsT71An2O2XQSa5W+JMEv76An9SvLjGePJPyH1soqS2iyCSUVNtX6ctZJBgCgWzKJGKmBRvxSKjwsezjwy7KeqBYbZaxFrbbokPHu8CgIfSkJpVvy3hv/rZN8hL0HQebsSjGP68UyCHVdHvDihS7bQevIHyB1uhJqXHWLgurB8MmjCwr6ZDCVTcT9z8ln5FurR37ubc2QhW/KVBGC5JN3ZYmOMnylqD7L9YbBQs3T4vSpaz9pOL927WPDIeFj5t/iTLx7dWkP3cG5uhCj6zPylhh2HyzIg4sr6NFCIGFP3vzQhC9JEKAIMMbYZkRf/Z\",\n    sudt_script_hash: \"\",\n    address: \"0x8290f27935A2D353adc834c9F3c5F6ef19635C2D\",\n    issuerLockHash: \"0x13d640a864c7e84d60afd8ca9c6689d345a18f63e2e426c9623a2811776cf211\",\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x13d640a864c7e84d60afd8ca9c6689d345a18f63e2e426c9623a2811776cf211\",\n    },\n  },\n];\n","import {\n  Cell,\n  CellDep,\n  core,\n  DepType,\n  Hash,\n  HashType,\n  helpers,\n  HexNumber,\n  HexString,\n  Script,\n  toolkit,\n  utils,\n  WitnessArgs,\n} from \"@ckb-lumos/lumos\";\nimport EventEmitter from \"events\";\nimport { core as godwokenCore } from \"@polyjuice-provider/godwoken\";\nimport { OMNI_LOCK_CELL_DEP, SECP256K1_BLACK160_CELL_DEP, SUDT_CELL_DEP } from \"./constants/layer1ConfigUtils\";\nimport { RawWithdrawalRequest, WithdrawalRequest } from \"./godwoken/normalizer\";\nimport DefaultLightGodwoken from \"./lightGodwoken\";\nimport {\n  UnlockPayload,\n  WithdrawalEventEmitter,\n  WithdrawalEventEmitterPayload,\n  GodwokenVersion,\n  LightGodwokenV0,\n  WithdrawResult,\n  ProxyERC20,\n  SUDT,\n} from \"./lightGodwokenType\";\nimport { getLayer2Config } from \"./constants/index\";\nimport { SerializeUnlockWithdrawalViaFinalize } from \"./schemas/index.esm\";\nimport { TOKEN_LIST } from \"./constants/tokens\";\nconst { SCRIPTS, ROLLUP_CONFIG } = getLayer2Config();\n\nexport default class DefaultLightGodwokenV0 extends DefaultLightGodwoken implements LightGodwokenV0 {\n  getVersion(): GodwokenVersion {\n    return \"v0\";\n  }\n\n  getBuiltinErc20List(): ProxyERC20[] {\n    const map: ProxyERC20[] = [];\n    TOKEN_LIST.forEach((token) => {\n      const tokenL1Script: Script = {\n        code_hash: token.l1Lock.code_hash,\n        args: token.l1Lock.args,\n        hash_type: token.l1Lock.hash_type as HashType,\n      };\n      const tokenScriptHash = utils.computeScriptHash(tokenL1Script);\n      map.push({\n        name: token.name,\n        symbol: token.symbol,\n        decimals: token.decimals,\n        address: token.address,\n        tokenURI: token.tokenURI,\n        sudt_script_hash: tokenScriptHash,\n      });\n    });\n    return map;\n  }\n\n  getBuiltinSUDTList(): SUDT[] {\n    const map: SUDT[] = [];\n    TOKEN_LIST.forEach((token) => {\n      const tokenL1Script: Script = {\n        code_hash: token.l1Lock.code_hash,\n        args: token.l1Lock.args,\n        hash_type: token.l1Lock.hash_type as HashType,\n      };\n      map.push({\n        type: tokenL1Script,\n        name: token.name,\n        symbol: token.symbol,\n        decimals: token.decimals,\n        tokenURI: token.tokenURI,\n      });\n    });\n    return map;\n  }\n\n  async listWithdraw(): Promise<WithdrawResult[]> {\n    const searchParams = this.getWithdrawalCellSearchParams(this.provider.l2Address);\n    console.log(\"searchParams is:\", searchParams);\n    const collectedCells: WithdrawResult[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: searchParams.script });\n    const lastFinalizedBlockNumber = await this.provider.getLastFinalizedBlockNumber();\n\n    const ownerCKBLock = helpers.parseAddress(this.provider.l1Address);\n    const ownerLock: Script = {\n      code_hash: ownerCKBLock.code_hash,\n      args: ownerCKBLock.args,\n      hash_type: ownerCKBLock.hash_type as HashType,\n    };\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n    console.log(\"ownerLockHash is:\", ownerLockHash);\n\n    for await (const cell of collector.collect()) {\n      const rawLockArgs = cell.cell_output.lock.args;\n      const lockArgs = new godwokenCore.WithdrawalLockArgs(new toolkit.Reader(`0x${rawLockArgs.slice(66)}`));\n\n      if (lockArgs == null) {\n        continue;\n      }\n\n      const withdrawBlock = Number(lockArgs.getWithdrawalBlockNumber().toLittleEndianBigUint64());\n      const containsOwnerLock = cell.cell_output.lock.args.includes(ownerLockHash.substring(2));\n\n      let sudtTypeHash = \"0x\" + \"00\".repeat(32);\n      let erc20: ProxyERC20 | undefined = undefined;\n      let amount: HexNumber = \"0x0\";\n\n      if (cell.cell_output.type) {\n        const sudtType: Script = {\n          code_hash: cell.cell_output.type.code_hash,\n          args: cell.cell_output.type.args,\n          hash_type: cell.cell_output.type.hash_type as HashType,\n        };\n        sudtTypeHash = utils.computeScriptHash(sudtType);\n        const builtinErc20List = this.getBuiltinErc20List();\n        erc20 = builtinErc20List.find((e) => e.sudt_script_hash === sudtTypeHash);\n        amount = `0x${utils.readBigUInt128LE(cell.data).toString(16)}`;\n      }\n\n      if (containsOwnerLock) {\n        collectedCells.push({\n          cell,\n          withdrawalBlockNumber: withdrawBlock,\n          remainingBlockNumber: Math.max(0, withdrawBlock - lastFinalizedBlockNumber),\n          capacity: cell.cell_output.capacity,\n          amount,\n          sudt_script_hash: sudtTypeHash,\n          erc20,\n        });\n      }\n    }\n    const sortedWithdrawals = collectedCells.sort((a, b) => {\n      return a.withdrawalBlockNumber - b.withdrawalBlockNumber;\n    });\n    console.log(\"found withdraw cells:\", sortedWithdrawals);\n    return sortedWithdrawals;\n  }\n\n  getWithdrawalCellSearchParams(ethAddress: string) {\n    if (ethAddress.length !== 42 || !ethAddress.startsWith(\"0x\")) {\n      throw new Error(\"eth address format error!\");\n    }\n    const accountScriptHash = this.provider.getLayer2LockScriptHash();\n\n    return {\n      script: {\n        code_hash: SCRIPTS.withdrawal_lock.script_type_hash,\n        hash_type: \"type\" as HashType,\n        args: `${ROLLUP_CONFIG.rollup_type_hash}${accountScriptHash.slice(2)}`,\n      },\n      script_type: \"lock\",\n    };\n  }\n\n  withdrawWithEvent(payload: WithdrawalEventEmitterPayload): WithdrawalEventEmitter {\n    const eventEmitter = new EventEmitter();\n    this.withdraw(eventEmitter, payload);\n    return eventEmitter;\n  }\n\n  async withdraw(eventEmitter: EventEmitter, payload: WithdrawalEventEmitterPayload): Promise<void> {\n    eventEmitter.emit(\"sending\");\n    const rollupTypeHash = ROLLUP_CONFIG.rollup_type_hash;\n    const ethAccountTypeHash = SCRIPTS.eth_account_lock.script_type_hash;\n    console.log(\" helpers.parseAddress(payload.withdrawal_address || this.provider.l1Address)\", payload, this.provider);\n\n    const ownerLock = helpers.parseAddress(payload.withdrawal_address || this.provider.l1Address);\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n    const ethAddress = this.provider.l2Address;\n    const l2AccountScript: Script = {\n      code_hash: ethAccountTypeHash,\n      hash_type: \"type\",\n      args: rollupTypeHash + ethAddress.slice(2),\n    };\n    const accountScriptHash = utils.computeScriptHash(l2AccountScript);\n    console.log(\"account script hash:\", accountScriptHash);\n    const fromId = await this.provider.godwokenClient.getAccountIdByScriptHash(accountScriptHash);\n    if (!fromId) {\n      throw new Error(\"account not found\");\n    }\n    const isSudt = payload.sudt_script_hash !== \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n    const minCapacity = this.minimalWithdrawalCapacity(isSudt);\n    if (BigInt(payload.capacity) < BigInt(minCapacity)) {\n      throw new Error(\n        `Withdrawal required ${BigInt(minCapacity)} shannons at least, provided ${BigInt(payload.capacity)}.`,\n      );\n    }\n    const nonce: HexNumber = await this.provider.godwokenClient.getNonce(fromId);\n    console.log(\"nonce:\", nonce);\n    const sellCapacity: HexNumber = \"0x0\";\n    const sellAmount: HexNumber = \"0x0\";\n    const paymentLockHash: HexNumber = \"0x\" + \"00\".repeat(32);\n    const feeSudtId: HexNumber = \"0x1\";\n    const feeAmount: HexNumber = \"0x0\";\n    const rawWithdrawalRequest: RawWithdrawalRequest = {\n      nonce: \"0x\" + BigInt(nonce).toString(16),\n      capacity: \"0x\" + BigInt(payload.capacity).toString(16),\n      amount: \"0x\" + BigInt(payload.amount).toString(16),\n      sudt_script_hash: payload.sudt_script_hash,\n      account_script_hash: accountScriptHash,\n      sell_amount: sellAmount,\n      sell_capacity: sellCapacity,\n      owner_lock_hash: ownerLockHash,\n      payment_lock_hash: paymentLockHash,\n      fee: {\n        sudt_id: feeSudtId,\n        amount: feeAmount,\n      },\n    };\n    console.log(\"rawWithdrawalRequest:\", rawWithdrawalRequest);\n    const message = this.generateWithdrawalMessageToSign(rawWithdrawalRequest, rollupTypeHash);\n    console.log(\"message:\", message);\n    const signatureMetamaskPersonalSign: HexString = await this.signMessageMetamaskPersonalSign(message);\n    console.log(\"signatureMetamaskPersonalSign:\", signatureMetamaskPersonalSign);\n    const withdrawalRequest: WithdrawalRequest = {\n      raw: rawWithdrawalRequest,\n      signature: signatureMetamaskPersonalSign,\n    };\n    console.log(\"withdrawalRequest:\", withdrawalRequest);\n    // using RPC `submitWithdrawalRequest` to submit withdrawal request to godwoken\n    let result: unknown;\n    try {\n      result = await this.provider.godwokenClient.submitWithdrawalRequest(withdrawalRequest);\n    } catch (e) {\n      eventEmitter.emit(\"error\", e);\n      return;\n    }\n    eventEmitter.emit(\"sent\", result);\n    console.log(\"withdrawal request result:\", result);\n    const maxLoop = 100;\n    let loop = 0;\n    const nIntervId = setInterval(async () => {\n      loop++;\n      const withdrawal: any = await this.getWithdrawal(result as unknown as Hash);\n      if (withdrawal && withdrawal.status === \"pending\") {\n        console.log(\"withdrawal pending:\", withdrawal);\n        eventEmitter.emit(\"pending\", result);\n      }\n      if (withdrawal && withdrawal.status === \"committed\") {\n        console.log(\"withdrawal committed:\", withdrawal);\n        eventEmitter.emit(\"success\", result);\n        clearInterval(nIntervId);\n      }\n      if (withdrawal === null && loop > maxLoop) {\n        eventEmitter.emit(\"fail\", result);\n        clearInterval(nIntervId);\n      }\n    }, 10000);\n  }\n\n  async unlock(payload: UnlockPayload): Promise<Hash> {\n    const l1Address = this.provider.l1Address;\n    const l1Lock = helpers.parseAddress(l1Address);\n    const outputCells: Cell[] = [];\n    if (payload.cell.cell_output.type) {\n      const dummySudtCell = {\n        cell_output: {\n          capacity: \"0x0\",\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      };\n      const sudtCapacity: bigint = helpers.minimalCellCapacity(dummySudtCell);\n      const capacityLeft = BigInt(payload.cell.cell_output.capacity) - sudtCapacity;\n\n      outputCells.push({\n        cell_output: {\n          capacity: `0x${capacityLeft.toString(16)}`,\n          lock: l1Lock,\n        },\n        data: \"0x\",\n      });\n      outputCells.push({\n        cell_output: {\n          capacity: `0x${sudtCapacity.toString(16)}`,\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      });\n    } else {\n      outputCells.push({\n        cell_output: {\n          capacity: payload.cell.cell_output.capacity,\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      });\n    }\n    const data =\n      \"0x00000000\" +\n      new toolkit.Reader(SerializeUnlockWithdrawalViaFinalize(toolkit.normalizers.NormalizeWitnessArgs({})))\n        .serializeJson()\n        .slice(2);\n    const newWitnessArgs: WitnessArgs = {\n      lock: data,\n    };\n    const withdrawalWitness = new toolkit.Reader(\n      core.SerializeWitnessArgs(toolkit.normalizers.NormalizeWitnessArgs(newWitnessArgs)),\n    ).serializeJson();\n\n    let txSkeleton = helpers.TransactionSkeleton({ cellProvider: this.provider.ckbIndexer });\n    const withdrawalLockDep: CellDep = {\n      out_point: {\n        tx_hash: SCRIPTS.withdrawal_lock.cell_dep.out_point.tx_hash,\n        index: SCRIPTS.withdrawal_lock.cell_dep.out_point.index,\n      },\n      dep_type: SCRIPTS.withdrawal_lock.cell_dep.dep_type as DepType,\n    };\n    const rollupCellDep: CellDep = await this.provider.getRollupCellDep();\n    txSkeleton = txSkeleton\n      .update(\"inputs\", (inputs) => {\n        return inputs.push(payload.cell);\n      })\n      .update(\"outputs\", (outputs) => {\n        return outputs.push(...outputCells);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(withdrawalLockDep);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(rollupCellDep);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(OMNI_LOCK_CELL_DEP);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(SECP256K1_BLACK160_CELL_DEP);\n      })\n      .update(\"witnesses\", (witnesses) => {\n        return witnesses.push(withdrawalWitness);\n      });\n\n    if (payload.cell.cell_output.type) {\n      txSkeleton = txSkeleton.update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(SUDT_CELL_DEP);\n      });\n    }\n\n    txSkeleton = await this.injectCapacity(txSkeleton, l1Lock, BigInt(0));\n\n    const signedTx = await this.provider.signL1Transaction(txSkeleton);\n    const txHash = await this.provider.sendL1Transaction(signedTx);\n    return txHash;\n  }\n}\n","import { Address, Cell, Hash, HexNumber, Transaction, helpers, Script } from \"@ckb-lumos/lumos\";\nimport { WithdrawalRequest } from \"./godwoken/normalizer\";\n\nexport interface GetL2CkbBalancePayload {\n  l2Address?: string;\n}\n\nexport interface GetL1CkbBalancePayload {\n  l1Address?: string;\n}\ninterface Token {\n  name: string;\n  symbol: string;\n  decimals: number;\n  tokenURI: string;\n}\n\ninterface ERC20 extends Token {\n  address: string;\n}\nexport interface ProxyERC20 extends ERC20 {\n  sudt_script_hash: Hash;\n}\nexport interface SUDT extends Token {\n  type: Script;\n}\n\nexport interface GetErc20BalancesResult {\n  balances: HexNumber[];\n}\n\nexport interface GetSudtBalancesResult {\n  balances: HexNumber[];\n}\n\nexport interface GetErc20Balances {\n  addresses: string[];\n}\n\nexport interface GetSudtBalances {\n  types: Script[];\n}\n\nexport interface GodwokenNetworkConfig {\n  testnetV1: \"https://godwoken-testnet-web3-v1-rpc.ckbapp.dev\";\n}\n\ninterface WithdrawListener {\n  (event: \"sending\", listener: () => void): void;\n  (event: \"sent\", listener: (txHash: Hash) => void): void;\n  (event: \"pending\", listener: (txHash: Hash) => void): void;\n  (event: \"success\", listener: (txHash: Hash) => void): void;\n  (event: \"error\", listener: (e: Error) => void): void;\n}\n\nexport interface WithdrawalEventEmitter {\n  on: WithdrawListener;\n}\n\nexport interface WithdrawalEventEmitterPayload {\n  // CKB capacity\n  capacity: HexNumber;\n  // L1 mapped sUDT amount\n  amount: HexNumber;\n  /**\n   * {@link L1MappedErc20}\n   */\n  sudt_script_hash: Hash;\n\n  /**\n   * withdraw to L1 address\n   */\n  withdrawal_address?: Address;\n}\n\nexport interface WithdrawResult {\n  cell: Cell;\n\n  withdrawalBlockNumber: number;\n\n  // relative to withdrawalBlockNumber\n  remainingBlockNumber: number;\n\n  capacity: HexNumber;\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n\n  erc20?: ProxyERC20;\n}\n\nexport interface UnlockPayload {\n  cell: Cell;\n}\n\nexport interface DepositPayload {\n  capacity: HexNumber;\n  amount?: HexNumber;\n  sudtType?: Script;\n}\n\ntype Promisable<T> = Promise<T> | T;\n\nexport const CKB_SUDT_ID = 1;\n\nexport interface LightGodwokenProvider {\n  getL2Address(): Promisable<string>;\n\n  getL1Address(): Promisable<string>;\n\n  // TODO the unknown is godwoken submit_withdrawal_tx\n  sendWithdrawTransaction: (withdrawalRequest: WithdrawalRequest) => Promise<Hash>;\n\n  signL1Transaction: (tx: helpers.TransactionSkeletonType) => Promise<Transaction>;\n\n  // now only supported omni lock, the other lock type will be supported later\n  sendL1Transaction: (tx: Transaction) => Promise<Hash>;\n}\n\nexport type GodwokenVersion = \"v0\" | \"v1\";\nexport type LightGodwokenProviderConfig = \"v0\" | \"v1\" | \"mainnet\";\n\nexport interface LightGodwokenBase {\n  provider: LightGodwokenProvider;\n\n  getVersion: () => GodwokenVersion;\n\n  /**\n   * get producing 1 block time\n   */\n  getBlockProduceTime: () => Promise<number> | number;\n\n  listWithdraw: () => Promise<WithdrawResult[]>;\n\n  deposit: (payload: DepositPayload) => Promise<Hash>;\n\n  withdrawWithEvent: (payload: WithdrawalEventEmitterPayload) => WithdrawalEventEmitter;\n\n  getL2CkbBalance: (payload?: GetL2CkbBalancePayload) => Promise<HexNumber>;\n\n  getL1CkbBalance: (payload?: GetL1CkbBalancePayload) => Promise<HexNumber>;\n\n  getBuiltinErc20List: () => ProxyERC20[];\n\n  getBuiltinSUDTList: () => SUDT[];\n\n  getErc20Balances: (payload: GetErc20Balances) => Promise<GetErc20BalancesResult>;\n\n  getSudtBalances: (payload: GetSudtBalances) => Promise<GetSudtBalancesResult>;\n}\n\nexport interface LightGodwokenV0 extends LightGodwokenBase {\n  unlock: (payload: UnlockPayload) => Promise<Hash>;\n}\nexport type LightGodwokenV1 = LightGodwokenBase;\n","import { helpers, Script, utils, BI, HashType, HexNumber, Hash } from \"@ckb-lumos/lumos\";\nimport {\n  Godwoken as GodwokenV1,\n  RawWithdrawalRequestV1,\n  WithdrawalRequestExtra,\n  WithdrawalRequestV1,\n} from \"./godwoken-v1/src/index\";\nimport EventEmitter from \"events\";\nimport { getLayer2Config } from \"./constants/index\";\nimport {\n  WithdrawalEventEmitter,\n  WithdrawalEventEmitterPayload,\n  CKB_SUDT_ID,\n  GodwokenVersion,\n  LightGodwokenV1,\n  ProxyERC20,\n  WithdrawResult,\n  SUDT,\n} from \"./lightGodwokenType\";\nimport DefaultLightGodwoken from \"./lightGodwoken\";\nconst { SCRIPTS, ROLLUP_CONFIG } = getLayer2Config();\n\nexport default class DefaultLightGodwokenV1 extends DefaultLightGodwoken implements LightGodwokenV1 {\n  getVersion(): GodwokenVersion {\n    return \"v1\";\n  }\n  getBuiltinSUDTList(): SUDT[] {\n    return [];\n  }\n  getBuiltinErc20List(): ProxyERC20[] {\n    return [];\n  }\n  async listWithdraw(): Promise<WithdrawResult[]> {\n    const searchParams = this.getWithdrawalCellSearchParams(this.provider.l2Address);\n    console.log(\"searchParams is:\", searchParams);\n    const collectedCells: WithdrawResult[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: searchParams.script });\n    const lastFinalizedBlockNumber = await this.provider.getLastFinalizedBlockNumber();\n\n    const ownerLockHash = this.provider.getLayer1LockScriptHash();\n\n    for await (const cell of collector.collect()) {\n      console.log(\"iteration --> cell is:\", cell);\n\n      // // a rollup_type_hash exists before this args, to make args friendly to prefix search\n      // struct WithdrawalLockArgs {\n      //   withdrawal_block_hash: Byte32,\n      //   withdrawal_block_number: Uint64,\n      //   account_script_hash: Byte32,\n      //   // layer1 lock to withdraw after challenge period\n      //   owner_lock_hash: Byte32,\n      // }\n\n      // according to the args shape:\n      // withdrawal_block_number byte location is 64~72\n      // owner_lock_hash byte location is 104~136\n      const rawLockArgs = cell.cell_output.lock.args;\n      if (rawLockArgs === null || rawLockArgs === undefined) {\n        console.warn(\"cell args is not valid\", cell);\n        continue;\n      }\n      const lockArgsOwnerScriptHash = rawLockArgs.slice(210, 274);\n      console.log(\"lockArgsOwnerScriptHash is:\", lockArgsOwnerScriptHash);\n\n      const withdrawBlock = utils.readBigUInt64LECompatible(`0x${rawLockArgs.slice(130, 146)}`);\n      console.log(\"withdrawBlock is:\", withdrawBlock.toNumber());\n\n      let sudtTypeHash = \"0x\" + \"00\".repeat(32);\n      let erc20: ProxyERC20 | undefined = undefined;\n      let amount: HexNumber = \"0x0\";\n\n      if (cell.cell_output.type) {\n        const sudtType: Script = {\n          code_hash: cell.cell_output.type.code_hash,\n          args: cell.cell_output.type.args,\n          hash_type: cell.cell_output.type.hash_type as HashType,\n        };\n        sudtTypeHash = utils.computeScriptHash(sudtType);\n        const builtinErc20List = this.getBuiltinErc20List();\n        erc20 = builtinErc20List.find((e) => e.sudt_script_hash === sudtTypeHash);\n        amount = `0x${utils.readBigUInt128LE(cell.data).toString(16)}`;\n      }\n\n      if (lockArgsOwnerScriptHash === ownerLockHash.slice(2)) {\n        collectedCells.push({\n          cell,\n          withdrawalBlockNumber: withdrawBlock.toNumber(),\n          remainingBlockNumber: Math.max(0, withdrawBlock.toNumber() - lastFinalizedBlockNumber),\n          capacity: cell.cell_output.capacity,\n          amount,\n          sudt_script_hash: sudtTypeHash,\n          erc20,\n        });\n      }\n    }\n    const sortedWithdrawals = collectedCells.sort((a, b) => {\n      return a.withdrawalBlockNumber - b.withdrawalBlockNumber;\n    });\n    console.log(\"found withdraw cells:\", sortedWithdrawals);\n    return sortedWithdrawals;\n  }\n\n  getWithdrawalCellSearchParams(ethAddress: string) {\n    if (ethAddress.length !== 42 || !ethAddress.startsWith(\"0x\")) {\n      throw new Error(\"eth address format error!\");\n    }\n    return {\n      script: {\n        code_hash: SCRIPTS.withdrawal_lock.script_type_hash,\n        hash_type: \"type\" as HashType,\n        args: \"0x\",\n      },\n      script_type: \"lock\",\n    };\n  }\n\n  withdrawWithEvent(payload: WithdrawalEventEmitterPayload): WithdrawalEventEmitter {\n    const eventEmitter = new EventEmitter();\n    this.withdraw(eventEmitter, payload);\n    return eventEmitter;\n  }\n\n  async withdraw(eventEmitter: EventEmitter, payload: WithdrawalEventEmitterPayload): Promise<void> {\n    eventEmitter.emit(\"sending\");\n    const godwokenWeb3 = new GodwokenV1(this.provider.config.GW_POLYJUICE_RPC_URL);\n    const chainId = await godwokenWeb3.getChainId();\n    const ownerCkbAddress = payload.withdrawal_address || this.provider.l1Address;\n    const ownerLock = helpers.parseAddress(ownerCkbAddress);\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n    const ethAddress = this.provider.l2Address;\n    const l2AccountScript: Script = {\n      code_hash: SCRIPTS.eth_account_lock.script_type_hash,\n      hash_type: \"type\",\n      args: ROLLUP_CONFIG.rollup_type_hash + ethAddress.slice(2),\n    };\n    const layer2AccountScriptHash = utils.computeScriptHash(l2AccountScript);\n\n    const address = layer2AccountScriptHash.slice(0, 42);\n    const balance = await godwokenWeb3.getBalance(CKB_SUDT_ID, address);\n    if (BI.from(balance).lt(BI.from(payload.capacity))) {\n      throw new Error(`Insufficient balance(${balance}) on Godwoken`);\n    }\n    const fromId = await godwokenWeb3.getAccountIdByScriptHash(layer2AccountScriptHash);\n    const nonce: number = await godwokenWeb3.getNonce(fromId!);\n\n    const rawWithdrawalRequest: RawWithdrawalRequestV1 = {\n      chain_id: chainId,\n      nonce: BI.from(nonce).toHexString(),\n      capacity: payload.capacity,\n      amount: payload.amount,\n      sudt_script_hash: payload.sudt_script_hash,\n      account_script_hash: layer2AccountScriptHash,\n      owner_lock_hash: ownerLockHash,\n      fee: \"0x0\",\n    };\n    const typedMsg = {\n      domain: {\n        name: \"Godwoken\",\n        version: \"1\",\n        chainId: Number(chainId),\n      },\n      message: {\n        accountScriptHash: layer2AccountScriptHash,\n        nonce,\n        chainId: Number(chainId),\n        fee: 0,\n        layer1OwnerLock: {\n          codeHash: ownerLock.code_hash,\n          hashType: ownerLock.hash_type,\n          args: ownerLock.args,\n        },\n        withdraw: {\n          ckbCapacity: BI.from(payload.capacity).toNumber(),\n          UDTAmount: BI.from(payload.amount).toNumber(),\n          UDTScriptHash: payload.sudt_script_hash,\n        },\n      },\n      primaryType: \"Withdrawal\" as const,\n      types: {\n        EIP712Domain: [\n          { name: \"name\", type: \"string\" },\n          { name: \"version\", type: \"string\" },\n          { name: \"chainId\", type: \"uint256\" },\n        ],\n        Withdrawal: [\n          { name: \"accountScriptHash\", type: \"bytes32\" },\n          { name: \"nonce\", type: \"uint256\" },\n          { name: \"chainId\", type: \"uint256\" },\n          { name: \"fee\", type: \"uint256\" },\n          { name: \"layer1OwnerLock\", type: \"Script\" },\n          { name: \"withdraw\", type: \"WithdrawalAsset\" },\n        ],\n        Script: [\n          { name: \"codeHash\", type: \"bytes32\" },\n          { name: \"hashType\", type: \"string\" },\n          { name: \"args\", type: \"bytes\" },\n        ],\n        WithdrawalAsset: [\n          { name: \"ckbCapacity\", type: \"uint256\" },\n          { name: \"UDTAmount\", type: \"uint256\" },\n          { name: \"UDTScriptHash\", type: \"bytes32\" },\n        ],\n      },\n    };\n    console.log(\"typedMsg:\", typedMsg);\n\n    let signedMessage = await this.provider.ethereum.request({\n      method: \"eth_signTypedData_v4\",\n      params: [this.provider.l2Address, JSON.stringify(typedMsg)],\n    });\n\n    // construct WithdrawalRequestExx tra\n    const withdrawalReq: WithdrawalRequestV1 = {\n      raw: rawWithdrawalRequest,\n      signature: signedMessage,\n    };\n    const withdrawalReqExtra: WithdrawalRequestExtra = {\n      request: withdrawalReq,\n      owner_lock: ownerLock,\n    };\n    console.log(\"WithdrawalRequestExtra:\", withdrawalReqExtra);\n\n    // submit WithdrawalRequestExtra\n    const result = await godwokenWeb3.submitWithdrawalReqV1(withdrawalReqExtra);\n    console.log(\"result:\", result);\n\n    if (result !== null) {\n      const errorMessage = (result as any).message;\n      if (errorMessage !== undefined && errorMessage !== null) {\n        eventEmitter.emit(\"error\", errorMessage);\n      }\n    }\n    eventEmitter.emit(\"sent\", result);\n    console.log(\"withdrawal request result:\", result);\n    const maxLoop = 100;\n    let loop = 0;\n    const nIntervId = setInterval(async () => {\n      loop++;\n      const withdrawal: any = await this.getWithdrawal(result as Hash);\n      if (withdrawal && withdrawal.status === \"pending\") {\n        console.log(\"withdrawal pending:\", withdrawal);\n        eventEmitter.emit(\"pending\", result);\n      }\n      if (withdrawal && withdrawal.status === \"committed\") {\n        console.log(\"withdrawal committed:\", withdrawal);\n        eventEmitter.emit(\"success\", result);\n        clearInterval(nIntervId);\n      }\n      if (withdrawal === null && loop > maxLoop) {\n        eventEmitter.emit(\"fail\", result);\n        clearInterval(nIntervId);\n      }\n    }, 10000);\n  }\n}\n","import detectEthereumProvider from \"@metamask/detect-provider\";\nimport React, { createContext, useEffect, useState } from \"react\";\nimport { LightGodwoken } from \"../light-godwoken\";\nimport { LightGodwoken as DefaultLightGodwoken } from \"../light-godwoken/index\";\nimport DefaultLightGodwokenProvider from \"../light-godwoken/lightGodwokenProvider\";\n\nexport const LightGodwokenContext = createContext<LightGodwoken | null>(null);\n\nconst addNetwork = (ethereum: any) => {\n  const params = [\n    {\n      chainId: \"0x315db00000006\",\n      chainName: \"GodwokenV1\",\n      nativeCurrency: {\n        name: \"pETH\",\n        symbol: \"pETH\",\n        decimals: 18,\n      },\n      rpcUrls: [\"https://godwoken-testnet-web3-v1-rpc.ckbapp.dev\"],\n      blockExplorerUrls: [\"https://v1.aggron.gwscan.com/\"],\n    },\n  ];\n\n  ethereum\n    .request({ method: \"wallet_addEthereumChain\", params })\n    .then(() => console.log(\"Success\"))\n    .catch((error: Error) => console.log(\"Error\", error.message));\n};\n\nexport const Provider: React.FC = (props) => {\n  const [lightGodwoken, setLightGodwoken] = useState<LightGodwoken>();\n\n  useEffect(() => {\n    detectEthereumProvider().then((ethereum: any) => {\n      addNetwork(ethereum);\n\n      ethereum.request({ method: \"eth_accounts\" }).then((accounts: string[]) => {\n        if (!accounts || !accounts[0]) return;\n\n        const instance = new DefaultLightGodwoken(new DefaultLightGodwokenProvider(accounts[0], ethereum, \"v1\"));\n        setLightGodwoken(instance);\n      });\n\n      ethereum.on(\"accountsChanged\", (accounts: string[] | undefined) => {\n        if (!accounts || !accounts[0]) return setLightGodwoken(undefined);\n\n        const provider = new DefaultLightGodwoken(\n          new DefaultLightGodwokenProvider(ethereum.selectedAddress, ethereum, \"v1\"),\n        );\n        setLightGodwoken(provider);\n      });\n    });\n  }, []);\n\n  return <LightGodwokenContext.Provider value={lightGodwoken || null}>{props.children}</LightGodwokenContext.Provider>;\n};\n","import { useContext } from \"react\";\nimport { LightGodwokenContext } from \"../contexts/LightGodwokenContext\";\nimport { LightGodwoken } from \"../light-godwoken\";\n\nexport const useLightGodwoken = (): LightGodwoken | null => {\n  const lightGodwoken = useContext(LightGodwokenContext);\n\n  return lightGodwoken;\n};\n","export const getDisplayAmount = (balance: BigInt, decimals = 8) => {\n  const valueStr = balance.toString();\n  if (decimals === 0) {\n    return valueStr;\n  }\n\n  const intPart = valueStr.slice(0, -decimals) || \"0\";\n  const unit = intPart === \"0\" ? 1e8 : 1e4;\n  let decPart = valueStr\n    .slice(-decimals)\n    .padStart(decimals, \"0\")\n    .slice(0, intPart === \"0\" ? 9 : 5);\n  decPart = (Math.round(Number(`0.${decPart}`) * unit) / unit)\n    .toFixed(intPart === \"0\" ? 8 : 4)\n    .replace(/(\\d)0+$/, \"$1\")\n    .slice(2);\n\n  return `${intPart}${decPart === \"0\" ? \"\" : `.${decPart}`}`;\n};\n\nexport const getFullDisplayAmount = (value: BigInt, decimals = 8, options: { maxDecimalPlace?: number } = {}) => {\n  const { maxDecimalPlace = 4 } = options;\n\n  const valueStr = value.toString();\n  if (decimals === 0) {\n    return valueStr;\n  }\n\n  const intPart = valueStr.slice(0, -decimals) || \"0\";\n  const decPart = valueStr\n    .slice(-decimals)\n    .padStart(decimals, \"0\")\n    .replace(/(\\d)0+$/, \"$1\")\n    .slice(0, maxDecimalPlace);\n\n  return `${intPart}${decPart === \"0\" ? \"\" : `.${decPart}`}`;\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nconst StyledInput = styled.input<{ error?: boolean; fontSize?: string; align?: string }>`\n  width: 0;\n  position: relative;\n  font-weight: 500;\n  outline: none;\n  border: none;\n  flex: 1 1 auto;\n  background-color: transparent;\n  font-size: 16px;\n  text-align: ${({ align }) => align && align};\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  padding: 0px;\n  -webkit-appearance: textfield;\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  [type=\"number\"] {\n    -moz-appearance: textfield;\n  }\n\n  ::-webkit-outer-spin-button,\n  ::-webkit-inner-spin-button {\n    -webkit-appearance: none;\n  }\n\n  :disabled {\n    cursor: text;\n  }\n`;\n\nexport function escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\nconst inputRegex = RegExp(`^\\\\d*(?:\\\\\\\\[.])?\\\\d*$`); // match escaped \".\" characters via in a non-capturing group\n\nexport const Input = React.memo(function InnerInput({\n  value,\n  onUserInput,\n  placeholder,\n  ...rest\n}: {\n  value: string | number;\n  onUserInput: (input: string) => void;\n  error?: boolean;\n  fontSize?: string;\n  align?: \"right\" | \"left\";\n} & Omit<React.HTMLProps<HTMLInputElement>, \"ref\" | \"onChange\" | \"as\">) {\n  const enforcer = (nextUserInput: string) => {\n    if (nextUserInput === \"\" || inputRegex.test(escapeRegExp(nextUserInput))) {\n      onUserInput(nextUserInput);\n    }\n  };\n\n  return (\n    <StyledInput\n      {...rest}\n      value={value}\n      onChange={(event) => {\n        // replace commas with periods, because we exclusively uses period as the decimal separator\n        enforcer(event.target.value.replace(/,/g, \".\"));\n      }}\n      // universal input options\n      inputMode=\"decimal\"\n      title=\"Token Amount\"\n      autoComplete=\"off\"\n      autoCorrect=\"off\"\n      // text-specific options\n      type=\"text\"\n      pattern=\"^[0-9]*[.,]?[0-9]*$\"\n      placeholder={placeholder || \"0.0\"}\n      minLength={1}\n      maxLength={79}\n      spellCheck=\"false\"\n    />\n  );\n});\n\nexport default Input;\n","import { Typography } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nimport { getDisplayAmount } from \"../utils/formatTokenAmount\";\nimport NumericalInput from \"./NumericalInput\";\n\nconst StyleWrapper = styled.div`\n  font-size: 14px;\n  border-radius: 16px;\n  background-color: rgb(60, 58, 75);\n  box-shadow: rgb(74 74 104 / 10%) 0px 2px 2px -1px;\n  .first-row {\n    margin-bottom: 3px;\n    padding: 0.75rem 1rem 0px;\n  }\n  .anticon {\n    font-size: 12px;\n  }\n\n  .input-wrapper {\n    padding: 0.75rem 0.5rem 0.75rem 1rem;\n  }\n`;\nconst Row = styled.div`\n  display: flex;\n  justify-content: space-between;\n  .ant-typography {\n    color: white;\n    font-size: 16px;\n    font-weight: 400;\n    line-height: 1.5;\n  }\n  .ckb-logo {\n    height: 24px;\n    width: 24px;\n    margin-right: 8px;\n  }\n  .max-button {\n    height: 32px;\n    padding: 0px 16px;\n    background-color: transparent;\n    color: rgb(255, 67, 66);\n    font-weight: 600;\n    &:hover {\n      cursor: pointer;\n    }\n  }\n`;\n\ninterface CKBInputPanelProps {\n  value: string;\n  onUserInput: (value: string) => void;\n  isL1?: boolean;\n  label?: React.ReactElement | string;\n}\nexport default function CKBInputPanel({ value, onUserInput, label, isL1 }: CKBInputPanelProps) {\n  const [showMaxButton, setShowMaxButton] = useState(true);\n  const [ckbBalance, setCkbBalance] = useState(\"\");\n  const lightGodwoken = useLightGodwoken();\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const balance = isL1\n        ? (await lightGodwoken?.getL1CkbBalance()) || \"\"\n        : (await lightGodwoken?.getL2CkbBalance()) || \"\";\n      setCkbBalance(balance);\n    };\n    fetchData();\n  }, [lightGodwoken, isL1]);\n\n  useEffect(() => {\n    if (value !== getDisplayAmount(BigInt(ckbBalance), 8)) {\n      setShowMaxButton(true);\n    } else {\n      setShowMaxButton(false);\n    }\n  }, [value, ckbBalance]);\n\n  const handelMaxClick = () => {\n    onUserInput(getDisplayAmount(BigInt(ckbBalance) - BigInt(64 * 10 ** 8), 8));\n    setShowMaxButton(false);\n  };\n  return (\n    <StyleWrapper>\n      <Row className=\"first-row\">\n        <Typography.Text>{label}</Typography.Text>\n        <Typography.Text>Balance: {getDisplayAmount(BigInt(ckbBalance), 8) || \"\"}</Typography.Text>\n      </Row>\n      <Row className=\"input-wrapper\">\n        <NumericalInput\n          className=\"token-amount-input\"\n          value={value}\n          placeholder=\"Minimum 400 CKB\"\n          onUserInput={(val) => {\n            onUserInput(val);\n          }}\n        />\n        {showMaxButton && (\n          <Typography.Text className=\"max-button\" onClick={handelMaxClick}>\n            MAX\n          </Typography.Text>\n        )}\n        <img className=\"ckb-logo\" src=\"./static/ckb.svg\" alt=\"\" />\n        <Typography.Text>CKB</Typography.Text>\n      </Row>\n    </StyleWrapper>\n  );\n}\n","import { CopyOutlined } from \"@ant-design/icons\";\nimport { Button, Input, Tooltip } from \"antd\";\nimport React, { useMemo } from \"react\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../../hooks/useLightGodwoken\";\n\nconst TipWrapper = styled.div`\n  color: #fff;\n  .text-pair {\n    display: flex;\n    justify-content: space-between;\n  }\n`;\n\nfunction truncateMiddle(str: string, first = 6, last = 4): string {\n  return str.substring(0, first) + \"...\" + str.substring(str.length - last);\n}\n\nexport const Address: React.FC = () => {\n  const lightGodwoken = useLightGodwoken();\n\n  const l2Address = useMemo(() => {\n    if (!lightGodwoken) return undefined;\n    return lightGodwoken.provider.getL2Address();\n  }, [lightGodwoken]);\n\n  if (!lightGodwoken || !l2Address) return null;\n  const copyL1Address = () => {\n    navigator.clipboard.writeText(lightGodwoken?.provider.getL1Address() || \"\");\n  };\n  const copyL2Address = () => {\n    navigator.clipboard.writeText(lightGodwoken?.provider.getL2Address() || \"\");\n  };\n  return (\n    <Tooltip\n      title={\n        <TipWrapper>\n          <div className=\"address-content\">\n            <label htmlFor=\"\">ETH ADDRESS</label>\n            <Input.Group compact>\n              <Input style={{ width: \"calc(100% - 33px)\" }} value={lightGodwoken.provider.getL2Address()} />\n              <Tooltip title=\"copy git url\">\n                <Button icon={<CopyOutlined />} onClick={copyL2Address} />\n              </Tooltip>\n            </Input.Group>\n          </div>\n          {/* <div className=\"text-pair\">\n            <Text>L2 CKB Balance</Text>\n            <Text>{getFullDisplayAmount(BigInt(l2CkbBalance), 8)}</Text>\n          </div> */}\n          <div className=\"address-content\">\n            <label htmlFor=\"\">L1 WALLET ADDRESS</label>\n            <Input.Group compact>\n              <Input style={{ width: \"calc(100% - 33px)\" }} value={lightGodwoken.provider.getL1Address()} />\n              <Tooltip title=\"copy git url\">\n                <Button icon={<CopyOutlined />} onClick={copyL1Address} />\n              </Tooltip>\n            </Input.Group>\n          </div>\n        </TipWrapper>\n      }\n    >\n      {truncateMiddle(l2Address)}\n    </Tooltip>\n  );\n};\n","import detectEthereumProvider from \"@metamask/detect-provider\";\nimport { Button } from \"antd\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../../hooks/useLightGodwoken\";\nimport { Address } from \"../Address\";\nconst StyleWrapper = styled(Button)`\n  &.ant-btn-primary {\n    background: rgb(60, 58, 75);\n    border: none;\n  }\n`;\nexport const ConnectButton: React.FC = () => {\n  const lightGodwoken = useLightGodwoken();\n\n  function connectWallet() {\n    if (lightGodwoken) return;\n\n    detectEthereumProvider().then((ethereum: any) => {\n      ethereum.request({ method: \"eth_requestAccounts\" });\n    });\n  }\n\n  return (\n    <StyleWrapper type=\"primary\" onClick={connectWallet}>\n      {lightGodwoken ? <Address /> : \"Connect\"}\n    </StyleWrapper>\n  );\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport { ConnectButton } from \"../components/ConnectButton\";\n\nconst StyledPage = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n  padding: 16px;\n  background: radial-gradient(89.56% 89.56% at 50.04% 10.44%, rgb(60, 58, 75) 0%, rgb(28, 27, 37) 92.56%);\n  margin-bottom: 20px;\n  color: white;\n\n  .address:hover {\n    cursor: pointer;\n  }\n\n  a + a {\n    padding-left: 10px;\n  }\n`;\n\nconst PageHeader: React.FC<React.HTMLAttributes<HTMLDivElement>> = () => {\n  return (\n    <StyledPage>\n      <div className=\"title\">Light Godwoken</div>\n      <div className=\"address\">\n        <ConnectButton />\n      </div>\n    </StyledPage>\n  );\n};\n\nexport default PageHeader;\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport PageHeader from \"./PageHeader\";\n\nconst StyledPage = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 100%;\n  min-height: calc(100vh);\n  background: radial-gradient(89.56% 89.56% at 50.04% 10.44%, rgb(60, 58, 75) 0%, rgb(28, 27, 37) 92.56%);\n`;\n\nconst Page: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ children, ...props }) => {\n  return (\n    <StyledPage {...props}>\n      <PageHeader></PageHeader>\n      {children}\n    </StyledPage>\n  );\n};\n\nexport default Page;\n","import { CopyOutlined, InfoCircleOutlined, LoadingOutlined } from \"@ant-design/icons\";\nimport { Script } from \"@ckb-lumos/lumos\";\nimport { Button, Modal, notification, Tooltip, Typography } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nimport CKBInputPanel from \"./CKBInputPanel\";\nimport Page from \"./Page\";\nimport { useQuery } from \"react-query\";\nimport { getDisplayAmount } from \"../utils/formatTokenAmount\";\n\nconst { Text } = Typography;\n\nconst PageContent = styled.div`\n  width: 436px;\n  background: rgb(39, 37, 52);\n  border-radius: 24px;\n  color: white;\n`;\nconst PageHeader = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  padding: 24px;\n\n  a,\n  .ant-typography {\n    color: white;\n  }\n\n  .title {\n    font-weight: bold;\n    font-size: 20px;\n    padding-bottom: 5px;\n  }\n\n  .description {\n    font-size: 14px;\n  }\n`;\nconst PageMain = styled.div`\n  padding: 24px;\n  grid-auto-rows: auto;\n  row-gap: 8px;\n\n  .icon {\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    padding-top: 8px;\n    padding-bottom: 8px;\n  }\n\n  .l1-faucet {\n    display: flex;\n    flex-direction: column;\n    padding-top: 20px;\n\n    .ant-typography {\n      color: white;\n      padding-right: 5px;\n    }\n\n    a {\n      color: rgb(255, 67, 66);\n    }\n  }\n`;\nconst L1WalletAddress = styled.div`\n  display: flex;\n  flex-direction: column;\n  margin: 24px;\n  padding: 16px;\n  border: 1px solid rgb(60, 58, 75);\n  border-radius: 16px;\n\n  .ant-typography {\n    color: white;\n  }\n\n  .title {\n    font-size: 16px;\n    padding-bottom: 10px;\n  }\n\n  .address {\n    font-size: 16px;\n    padding-bottom: 10px;\n  }\n\n  .copy {\n    color: rgb(255, 67, 66);\n\n    .ant-typography {\n      font-size: 14px;\n      color: rgb(255, 67, 66);\n      padding-right: 5px;\n    }\n\n    &:hover {\n      cursor: pointer;\n    }\n  }\n`;\nconst WithDrawalButton = styled.div`\n  margin-top: 20px;\n  display: flex;\n  justify-content: center;\n\n  .submit-button {\n    align-items: center;\n    border: 0px;\n    border-radius: 16px;\n    box-shadow: rgb(14 14 44 / 40%) 0px -1px 0px 0px inset;\n    cursor: pointer;\n    display: inline-flex;\n    font-family: inherit;\n    font-size: 16px;\n    font-weight: 600;\n    -webkit-box-pack: center;\n    justify-content: center;\n    letter-spacing: 0.03em;\n    line-height: 1;\n    opacity: 1;\n    outline: 0px;\n    transition: background-color 0.2s ease 0s, opacity 0.2s ease 0s;\n    height: 48px;\n    padding: 0px 24px;\n    background-color: rgb(255, 67, 66);\n    color: white;\n    width: 100%;\n\n    &:disabled {\n      background-color: rgb(60, 55, 66);\n      border-color: rgb(60, 55, 66);\n      box-shadow: none;\n      color: rgb(104, 102, 123);\n      cursor: not-allowed;\n    }\n  }\n\n  button:hover {\n    cursor: pointer;\n  }\n`;\nconst ConfirmModal = styled(Modal)`\n  color: white;\n\n  .ant-modal-content {\n    border-radius: 32px;\n    background: rgb(39, 37, 52);\n    box-shadow: rgb(14 14 44 / 10%) 0px 20px 36px -8px, rgb(0 0 0 / 5%) 0px 1px 1px;\n    border: 1px solid rgb(60, 58, 75);\n    color: white;\n  }\n\n  .ant-modal-header {\n    background: rgb(39, 37, 52);\n    border: 1px solid rgb(60, 58, 75);\n    border-top-left-radius: 32px;\n    border-top-right-radius: 32px;\n    padding: 12px 24px;\n    height: 73px;\n    display: flex;\n    align-items: center;\n  }\n\n  .ant-modal-title,\n  .ant-list-item {\n    color: white;\n  }\n\n  .ant-modal-body {\n    padding: 24px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n\n  .ant-modal-close-x {\n    color: white;\n  }\n\n  .ant-typography {\n    color: white;\n    justify-content: space-between;\n  }\n\n  .tips {\n    margin: 24px 0;\n  }\n\n  .anticon-loading {\n    font-size: 50px;\n    color: rgb(255, 67, 66);\n  }\n\n  .icon-container {\n    padding-bottom: 20px;\n  }\n`;\n\ninterface Token {\n  name: string;\n  symbol: string;\n  decimals: number;\n  tokenURI: string;\n}\n\ninterface SUDT extends Token {\n  type: Script;\n}\n\nfunction L2Balance() {\n  const lightGodwoken = useLightGodwoken();\n\n  const l2Address = lightGodwoken?.provider.l2Address;\n  const { data: balance } = useQuery(\n    [\"queryL2Balance\", { address: l2Address }],\n    () => {\n      return lightGodwoken?.getL2CkbBalance();\n    },\n    {\n      enabled: !!lightGodwoken,\n    },\n  );\n\n  if (!l2Address) return null;\n  if (!balance) {\n    return (\n      <span>\n        <LoadingOutlined />\n      </span>\n    );\n  }\n  return <span>L2 Balance: {getDisplayAmount(BigInt(balance), 8)} CKB</span>;\n}\n\nexport default function Deposit() {\n  const [ckbInput, setCkbInput] = useState(\"\");\n  const [outputValue, setOutputValue] = useState(\"\");\n  const [isModalVisible, setIsModalVisible] = useState(false);\n  const [submitButtonDisable, setSubmitButtonDisable] = useState(true);\n  const [selectedSudt, setSelectedSudt] = useState<SUDT>();\n  const lightGodwoken = useLightGodwoken();\n\n  const showModal = async () => {\n    setIsModalVisible(true);\n    if (lightGodwoken) {\n      const capacity = BigInt(Number(ckbInput) * Math.pow(10, 8));\n      let amount = \"0x0\";\n      if (selectedSudt) {\n        amount = \"0x\" + BigInt(Number(outputValue) * Math.pow(10, selectedSudt.decimals)).toString(16);\n      }\n      const hash = await lightGodwoken.deposit({\n        capacity: \"0x\" + capacity.toString(16),\n        amount: amount,\n        sudtType: selectedSudt?.type,\n      });\n      notification.success({ message: `deposit Tx(${hash}) is successful` });\n      setIsModalVisible(false);\n    }\n  };\n\n  const handleCancel = () => {\n    setIsModalVisible(false);\n  };\n\n  useEffect(() => {\n    if (Number(ckbInput) >= 400) {\n      setSubmitButtonDisable(false);\n    } else {\n      setSubmitButtonDisable(true);\n    }\n  }, [ckbInput]);\n\n  const handleSelectedChange = (value: Token) => {\n    setSelectedSudt(value as SUDT);\n  };\n\n  const copyAddress = () => {\n    navigator.clipboard.writeText(lightGodwoken?.provider.getL1Address() || \"\");\n  };\n  return (\n    <Page>\n      <PageContent>\n        <PageHeader className=\"header\">\n          <Text className=\"title\">Deposit To Layer2</Text>\n          <Text className=\"description\">\n            To deposit, transfer CKB or supported sUDT tokens to your L1 Wallet Address first\n          </Text>\n        </PageHeader>\n        <L1WalletAddress>\n          <Text className=\"title\">L1 Wallet Address</Text>\n          <Text className=\"address\">{lightGodwoken?.provider.getL1Address()}</Text>\n          <div className=\"copy\" onClick={copyAddress}>\n            <Text>Copy Address</Text>\n            <CopyOutlined />\n          </div>\n        </L1WalletAddress>\n        <PageMain className=\"main\">\n          <CKBInputPanel\n            value={ckbInput}\n            onUserInput={setCkbInput}\n            label={\n              <span>\n                Deposit&nbsp;\n                <Tooltip title=\"For some reason it is needed to leave at least 64 CKBs on L1 when using this app, this issue will be optimised in the future.\">\n                  <InfoCircleOutlined style={{ verticalAlign: \"middle\" }} />\n                </Tooltip>\n              </span>\n            }\n            isL1\n          />\n\n          <WithDrawalButton>\n            <Button className=\"submit-button\" disabled={submitButtonDisable} onClick={showModal}>\n              Deposit\n            </Button>\n          </WithDrawalButton>\n\n          <div>\n            <L2Balance />\n          </div>\n          <div className=\"l1-faucet\">\n            <Text>Need Layer 1 test tokens?</Text>\n            <a href=\"https://faucet.nervos.org/\" target=\"_blank\" rel=\"noreferrer\">\n              CKB Testnet Faucet\n            </a>\n          </div>\n        </PageMain>\n        <div className=\"footer\"></div>\n      </PageContent>\n      <ConfirmModal title=\"Confirm Transaction\" visible={isModalVisible} onCancel={handleCancel} footer={null}>\n        <div className=\"icon-container\">\n          <LoadingOutlined />\n        </div>\n        <Text>Waiting For Confirmation</Text>\n        <Text>\n          Depositing {outputValue} {selectedSudt?.symbol} and {ckbInput} CKB\n        </Text>\n        <div className=\"tips\">Confirm this transaction in your wallet</div>\n      </ConfirmModal>\n    </Page>\n  );\n}\n","import \"antd/dist/antd.css\";\nimport React from \"react\";\nimport { HashRouter as Router, Route, Routes } from \"react-router-dom\";\nimport { Provider as LightGodwokenProvider } from \"./contexts/LightGodwokenContext\";\nimport Deposit from \"./views/Deposit\";\nimport { QueryClient, QueryClientProvider } from \"react-query\";\n\nfunction App() {\n  return (\n    <QueryClientProvider client={new QueryClient()}>\n      <LightGodwokenProvider>\n        <Router>\n          <Routes>\n            <Route path=\"/\" element={<Deposit />}></Route>\n            <Route path=\"/deposit\" element={<Deposit />}></Route>\n          </Routes>\n        </Router>\n      </LightGodwokenProvider>\n    </QueryClientProvider>\n  );\n}\n\nexport default App;\n","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { config } from \"@ckb-lumos/lumos\";\n\nconfig.initializeConfig(config.predefined.AGGRON4);\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\"),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","/* eslint-disable */\n(function (global, factory) {\n  typeof exports === \"object\" && typeof module !== \"undefined\"\n    ? factory(exports)\n    : typeof define === \"function\" && define.amd\n    ? define([\"exports\"], factory)\n    : ((global = typeof globalThis !== \"undefined\" ? globalThis : global || self), factory((global.Godwoken = {})));\n})(this, function (exports) {\n  \"use strict\";\n\n  function dataLengthError(actual, required) {\n    throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n  }\n\n  function assertDataLength(actual, required) {\n    if (actual !== required) {\n      dataLengthError(actual, required);\n    }\n  }\n\n  function assertArrayBuffer(reader) {\n    if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n      reader = reader.toArrayBuffer();\n    }\n    if (!(reader instanceof ArrayBuffer)) {\n      throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n    }\n    return reader;\n  }\n\n  function verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n    if (view.byteLength < 4) {\n      dataLengthError(view.byteLength, \">4\");\n    }\n    const requiredByteLength = view.getUint32(0, true);\n    assertDataLength(view.byteLength, requiredByteLength);\n    if (requiredByteLength === 4) {\n      return [requiredByteLength];\n    }\n    if (requiredByteLength < 8) {\n      dataLengthError(view.byteLength, \">8\");\n    }\n    const firstOffset = view.getUint32(4, true);\n    if (firstOffset % 4 !== 0 || firstOffset < 8) {\n      throw new Error(`Invalid first offset: ${firstOffset}`);\n    }\n    const itemCount = firstOffset / 4 - 1;\n    if (itemCount < expectedFieldCount) {\n      throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n    } else if (!compatible && itemCount > expectedFieldCount) {\n      throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n    }\n    if (requiredByteLength < firstOffset) {\n      throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n    }\n    const offsets = [];\n    for (let i = 0; i < itemCount; i++) {\n      const start = 4 + i * 4;\n      offsets.push(view.getUint32(start, true));\n    }\n    offsets.push(requiredByteLength);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      if (offsets[i] > offsets[i + 1]) {\n        throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n      }\n    }\n    return offsets;\n  }\n\n  function serializeTable(buffers) {\n    const itemCount = buffers.length;\n    let totalSize = 4 * (itemCount + 1);\n    const offsets = [];\n\n    for (let i = 0; i < itemCount; i++) {\n      offsets.push(totalSize);\n      totalSize += buffers[i].byteLength;\n    }\n\n    const buffer = new ArrayBuffer(totalSize);\n    const array = new Uint8Array(buffer);\n    const view = new DataView(buffer);\n\n    view.setUint32(0, totalSize, true);\n    for (let i = 0; i < itemCount; i++) {\n      view.setUint32(4 + i * 4, offsets[i], true);\n      array.set(new Uint8Array(buffers[i]), offsets[i]);\n    }\n    return buffer;\n  }\n\n  class Uint32Vec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * Uint32.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new Uint32(this.view.buffer.slice(4 + i * Uint32.size(), 4 + (i + 1) * Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeUint32Vec(value) {\n    const array = new Uint8Array(4 + Uint32.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeUint32(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * Uint32.size());\n    }\n    return array.buffer;\n  }\n\n  class BlockMerkleState {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getMerkleRoot() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getCount() {\n      return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, BlockMerkleState.size());\n      this.getMerkleRoot().validate(compatible);\n      this.getCount().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint64.size();\n    }\n  }\n\n  function SerializeBlockMerkleState(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n    array.set(new Uint8Array(SerializeUint64(value.count)), 0 + Byte32.size());\n    return array.buffer;\n  }\n\n  class AccountMerkleState {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getMerkleRoot() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getCount() {\n      return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, AccountMerkleState.size());\n      this.getMerkleRoot().validate(compatible);\n      this.getCount().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint32.size();\n    }\n  }\n\n  function SerializeAccountMerkleState(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n    array.set(new Uint8Array(SerializeUint32(value.count)), 0 + Byte32.size());\n    return array.buffer;\n  }\n\n  class GlobalStateV0 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getRollupConfigHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getAccount() {\n      return new AccountMerkleState(\n        this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n        { validate: false },\n      );\n    }\n\n    getBlock() {\n      return new BlockMerkleState(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getRevertedBlockRoot() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getTipBlockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getLastFinalizedBlockNumber() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n          0 +\n            Byte32.size() +\n            AccountMerkleState.size() +\n            BlockMerkleState.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getStatus() {\n      return this.view.getUint8(\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size(),\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, GlobalStateV0.size());\n      this.getRollupConfigHash().validate(compatible);\n      this.getAccount().validate(compatible);\n      this.getBlock().validate(compatible);\n      this.getRevertedBlockRoot().validate(compatible);\n      this.getTipBlockHash().validate(compatible);\n      this.getLastFinalizedBlockNumber().validate(compatible);\n    }\n    static size() {\n      return (\n        0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        1\n      );\n    }\n  }\n\n  function SerializeGlobalStateV0(value) {\n    const array = new Uint8Array(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        1,\n    );\n    const view = new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n    array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n    array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n    array.set(\n      new Uint8Array(SerializeByte32(value.reverted_block_root)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.tip_block_hash)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n    );\n    view.setUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size(),\n      value.status,\n    );\n    return array.buffer;\n  }\n\n  class GlobalState {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getRollupConfigHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getAccount() {\n      return new AccountMerkleState(\n        this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()),\n        { validate: false },\n      );\n    }\n\n    getBlock() {\n      return new BlockMerkleState(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getRevertedBlockRoot() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getTipBlockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getTipBlockTimestamp() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n          0 +\n            Byte32.size() +\n            AccountMerkleState.size() +\n            BlockMerkleState.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getLastFinalizedBlockNumber() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 +\n            Byte32.size() +\n            AccountMerkleState.size() +\n            BlockMerkleState.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size(),\n          0 +\n            Byte32.size() +\n            AccountMerkleState.size() +\n            BlockMerkleState.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size() +\n            Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getStatus() {\n      return this.view.getUint8(\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Uint64.size(),\n      );\n    }\n\n    getVersion() {\n      return this.view.getUint8(\n        0 +\n          Byte32.size() +\n          AccountMerkleState.size() +\n          BlockMerkleState.size() +\n          Byte32.size() +\n          Byte32.size() +\n          Uint64.size() +\n          Uint64.size() +\n          1,\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, GlobalState.size());\n      this.getRollupConfigHash().validate(compatible);\n      this.getAccount().validate(compatible);\n      this.getBlock().validate(compatible);\n      this.getRevertedBlockRoot().validate(compatible);\n      this.getTipBlockHash().validate(compatible);\n      this.getTipBlockTimestamp().validate(compatible);\n      this.getLastFinalizedBlockNumber().validate(compatible);\n    }\n    static size() {\n      return (\n        0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        1 +\n        1\n      );\n    }\n  }\n\n  function SerializeGlobalState(value) {\n    const array = new Uint8Array(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        1 +\n        1,\n    );\n    const view = new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n    array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n    array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n    array.set(\n      new Uint8Array(SerializeByte32(value.reverted_block_root)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.tip_block_hash)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.tip_block_timestamp)),\n      0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.last_finalized_block_number)),\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size(),\n    );\n    view.setUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size(),\n      value.status,\n    );\n    view.setUint8(\n      0 +\n        Byte32.size() +\n        AccountMerkleState.size() +\n        BlockMerkleState.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        1,\n      value.version,\n    );\n    return array.buffer;\n  }\n\n  class RollupConfig {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[10], offsets[11]), { validate: false }).validate();\n      if (offsets[12] - offsets[11] !== 1) {\n        throw new Error(`Invalid offset for reward_burn_rate: ${offsets[11]} - ${offsets[12]}`);\n      }\n      new Byte32Vec(this.view.buffer.slice(offsets[12], offsets[13]), { validate: false }).validate();\n      new Byte32Vec(this.view.buffer.slice(offsets[13], offsets[14]), { validate: false }).validate();\n    }\n\n    getL1SudtScriptTypeHash() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getCustodianScriptTypeHash() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getDepositScriptTypeHash() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getWithdrawalScriptTypeHash() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getChallengeScriptTypeHash() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getStakeScriptTypeHash() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getL2SudtValidatorScriptTypeHash() {\n      const start = 28;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBurnLockHash() {\n      const start = 32;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRequiredStakingCapacity() {\n      const start = 36;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getChallengeMaturityBlocks() {\n      const start = 40;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getFinalityBlocks() {\n      const start = 44;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRewardBurnRate() {\n      const start = 48;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n    }\n\n    getAllowedEoaTypeHashes() {\n      const start = 52;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getAllowedContractTypeHashes() {\n      const start = 56;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRollupConfig(value) {\n    const buffers = [];\n    buffers.push(SerializeByte32(value.l1_sudt_script_type_hash));\n    buffers.push(SerializeByte32(value.custodian_script_type_hash));\n    buffers.push(SerializeByte32(value.deposit_script_type_hash));\n    buffers.push(SerializeByte32(value.withdrawal_script_type_hash));\n    buffers.push(SerializeByte32(value.challenge_script_type_hash));\n    buffers.push(SerializeByte32(value.stake_script_type_hash));\n    buffers.push(SerializeByte32(value.l2_sudt_validator_script_type_hash));\n    buffers.push(SerializeByte32(value.burn_lock_hash));\n    buffers.push(SerializeUint64(value.required_staking_capacity));\n    buffers.push(SerializeUint64(value.challenge_maturity_blocks));\n    buffers.push(SerializeUint64(value.finality_blocks));\n    const rewardBurnRateView = new DataView(new ArrayBuffer(1));\n    rewardBurnRateView.setUint8(0, value.reward_burn_rate);\n    buffers.push(rewardBurnRateView.buffer);\n    buffers.push(SerializeByte32Vec(value.allowed_eoa_type_hashes));\n    buffers.push(SerializeByte32Vec(value.allowed_contract_type_hashes));\n    return serializeTable(buffers);\n  }\n\n  class RawL2Transaction {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Uint32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    }\n\n    getFromId() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getToId() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getNonce() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getArgs() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRawL2Transaction(value) {\n    const buffers = [];\n    buffers.push(SerializeUint32(value.from_id));\n    buffers.push(SerializeUint32(value.to_id));\n    buffers.push(SerializeUint32(value.nonce));\n    buffers.push(SerializeBytes(value.args));\n    return serializeTable(buffers);\n  }\n\n  class L2Transaction {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getRaw() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getSignature() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeL2Transaction(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2Transaction(value.raw));\n    buffers.push(SerializeBytes(value.signature));\n    return serializeTable(buffers);\n  }\n\n  class L2TransactionVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new L2Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeL2TransactionVec(value) {\n    return serializeTable(value.map((item) => SerializeL2Transaction(item)));\n  }\n\n  class SubmitTransactions {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getTxWitnessRoot() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTxCount() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getPrevStateCheckpoint() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeSubmitTransactions(value) {\n    const buffers = [];\n    buffers.push(SerializeByte32(value.tx_witness_root));\n    buffers.push(SerializeUint32(value.tx_count));\n    buffers.push(SerializeByte32(value.prev_state_checkpoint));\n    return serializeTable(buffers);\n  }\n\n  class SubmitWithdrawals {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getWithdrawalWitnessRoot() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getWithdrawalCount() {\n      return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, SubmitWithdrawals.size());\n      this.getWithdrawalWitnessRoot().validate(compatible);\n      this.getWithdrawalCount().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint32.size();\n    }\n  }\n\n  function SerializeSubmitWithdrawals(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.withdrawal_witness_root)), 0);\n    array.set(new Uint8Array(SerializeUint32(value.withdrawal_count)), 0 + Byte32.size());\n    return array.buffer;\n  }\n\n  class RawL2Block {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new AccountMerkleState(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n      new AccountMerkleState(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n      new Byte32Vec(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n      new SubmitWithdrawals(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n      new SubmitTransactions(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n    }\n\n    getNumber() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockProducerId() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getParentBlockHash() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getStakeCellOwnerLockHash() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTimestamp() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getPrevAccount() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getPostAccount() {\n      const start = 28;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getStateCheckpointList() {\n      const start = 32;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getSubmitWithdrawals() {\n      const start = 36;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new SubmitWithdrawals(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getSubmitTransactions() {\n      const start = 40;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new SubmitTransactions(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRawL2Block(value) {\n    const buffers = [];\n    buffers.push(SerializeUint64(value.number));\n    buffers.push(SerializeUint32(value.block_producer_id));\n    buffers.push(SerializeByte32(value.parent_block_hash));\n    buffers.push(SerializeByte32(value.stake_cell_owner_lock_hash));\n    buffers.push(SerializeUint64(value.timestamp));\n    buffers.push(SerializeAccountMerkleState(value.prev_account));\n    buffers.push(SerializeAccountMerkleState(value.post_account));\n    buffers.push(SerializeByte32Vec(value.state_checkpoint_list));\n    buffers.push(SerializeSubmitWithdrawals(value.submit_withdrawals));\n    buffers.push(SerializeSubmitTransactions(value.submit_transactions));\n    return serializeTable(buffers);\n  }\n\n  class RawL2BlockVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new RawL2Block(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRawL2BlockVec(value) {\n    return serializeTable(value.map((item) => SerializeRawL2Block(item)));\n  }\n\n  class L2Block {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new L2TransactionVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new WithdrawalRequestVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    }\n\n    getRaw() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvState() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvStateProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTransactions() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new L2TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockProof() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getWithdrawals() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new WithdrawalRequestVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeL2Block(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2Block(value.raw));\n    buffers.push(SerializeKVPairVec(value.kv_state));\n    buffers.push(SerializeBytes(value.kv_state_proof));\n    buffers.push(SerializeL2TransactionVec(value.transactions));\n    buffers.push(SerializeBytes(value.block_proof));\n    buffers.push(SerializeWithdrawalRequestVec(value.withdrawals));\n    return serializeTable(buffers);\n  }\n\n  class DepositRequest {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Script(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    }\n\n    getCapacity() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getAmount() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getSudtScriptHash() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getScript() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeDepositRequest(value) {\n    const buffers = [];\n    buffers.push(SerializeUint64(value.capacity));\n    buffers.push(SerializeUint128(value.amount));\n    buffers.push(SerializeByte32(value.sudt_script_hash));\n    buffers.push(SerializeScript(value.script));\n    return serializeTable(buffers);\n  }\n\n  class DepositRequestVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new DepositRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new DepositRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeDepositRequestVec(value) {\n    return serializeTable(value.map((item) => SerializeDepositRequest(item)));\n  }\n\n  class RawWithdrawalRequest {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getNonce() {\n      return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n    }\n\n    getCapacity() {\n      return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n        validate: false,\n      });\n    }\n\n    getAmount() {\n      return new Uint128(\n        this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size()),\n        { validate: false },\n      );\n    }\n\n    getSudtScriptHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint64.size() + Uint128.size(),\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getAccountScriptHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getSellAmount() {\n      return new Uint128(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getSellCapacity() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getOwnerLockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size(),\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getPaymentLockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getFee() {\n      return new Fee(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint64.size() +\n            Uint128.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Fee.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, RawWithdrawalRequest.size());\n      this.getNonce().validate(compatible);\n      this.getCapacity().validate(compatible);\n      this.getAmount().validate(compatible);\n      this.getSudtScriptHash().validate(compatible);\n      this.getAccountScriptHash().validate(compatible);\n      this.getSellAmount().validate(compatible);\n      this.getSellCapacity().validate(compatible);\n      this.getOwnerLockHash().validate(compatible);\n      this.getPaymentLockHash().validate(compatible);\n      this.getFee().validate(compatible);\n    }\n    static size() {\n      return (\n        0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Fee.size()\n      );\n    }\n  }\n\n  function SerializeRawWithdrawalRequest(value) {\n    const array = new Uint8Array(\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Fee.size(),\n    );\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint32(value.nonce)), 0);\n    array.set(new Uint8Array(SerializeUint64(value.capacity)), 0 + Uint32.size());\n    array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size() + Uint64.size());\n    array.set(\n      new Uint8Array(SerializeByte32(value.sudt_script_hash)),\n      0 + Uint32.size() + Uint64.size() + Uint128.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.account_script_hash)),\n      0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint128(value.sell_amount)),\n      0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.sell_capacity)),\n      0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.payment_lock_hash)),\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeFee(value.fee)),\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    return array.buffer;\n  }\n\n  function SerializeRawWithdrawalRequestV1(value) {\n    const array = new Uint8Array(\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size(),\n    );\n    const view = new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint32(value.nonce)), 0);\n    array.set(new Uint8Array(SerializeUint64(value.chain_id)), 0 + Uint32.size());\n    array.set(new Uint8Array(SerializeUint64(value.capacity)), 0 + Uint32.size() + Uint64.size());\n    array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size() + Uint64.size() + Uint64.size());\n    array.set(\n      new Uint8Array(SerializeByte32(value.sudt_script_hash)),\n      0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.account_script_hash)),\n      0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n      0 + Uint32.size() + Uint64.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.fee)),\n      0 +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint128.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    return array.buffer;\n  }\n\n  class WithdrawalRequestVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new WithdrawalRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeWithdrawalRequestVec(value) {\n    return serializeTable(value.map((item) => SerializeWithdrawalRequest(item)));\n  }\n\n  class WithdrawalRequest {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawWithdrawalRequest(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getRaw() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawWithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getSignature() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeWithdrawalRequest(value) {\n    const buffers = [];\n    buffers.push(SerializeRawWithdrawalRequest(value.raw));\n    buffers.push(SerializeBytes(value.signature));\n    return serializeTable(buffers);\n  }\n\n  class KVPair {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getK() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getV() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeKVPair(value) {\n    const buffers = [];\n    buffers.push(SerializeByte32(value.k));\n    buffers.push(SerializeByte32(value.v));\n    return serializeTable(buffers);\n  }\n\n  class KVPairVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new KVPair(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new KVPair(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeKVPairVec(value) {\n    return serializeTable(value.map((item) => SerializeKVPair(item)));\n  }\n\n  class BlockInfo {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getBlockProducerId() {\n      return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n    }\n\n    getNumber() {\n      return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), {\n        validate: false,\n      });\n    }\n\n    getTimestamp() {\n      return new Uint64(\n        this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint64.size()),\n        { validate: false },\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, BlockInfo.size());\n      this.getBlockProducerId().validate(compatible);\n      this.getNumber().validate(compatible);\n      this.getTimestamp().validate(compatible);\n    }\n    static size() {\n      return 0 + Uint32.size() + Uint64.size() + Uint64.size();\n    }\n  }\n\n  function SerializeBlockInfo(value) {\n    const array = new Uint8Array(0 + Uint32.size() + Uint64.size() + Uint64.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint32(value.block_producer_id)), 0);\n    array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size());\n    array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint64.size());\n    return array.buffer;\n  }\n\n  class DepositLockArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getOwnerLockHash() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getLayer2Lock() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getCancelTimeout() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeDepositLockArgs(value) {\n    const buffers = [];\n    buffers.push(SerializeByte32(value.owner_lock_hash));\n    buffers.push(SerializeScript(value.layer2_lock));\n    buffers.push(SerializeUint64(value.cancel_timeout));\n    return serializeTable(buffers);\n  }\n\n  class CustodianLockArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new DepositLockArgs(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getDepositLockArgs() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new DepositLockArgs(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getDepositBlockHash() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getDepositBlockNumber() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCustodianLockArgs(value) {\n    const buffers = [];\n    buffers.push(SerializeDepositLockArgs(value.deposit_lock_args));\n    buffers.push(SerializeByte32(value.deposit_block_hash));\n    buffers.push(SerializeUint64(value.deposit_block_number));\n    return serializeTable(buffers);\n  }\n\n  class UnlockCustodianViaRevertWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getDepositLockHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, UnlockCustodianViaRevertWitness.size());\n      this.getDepositLockHash().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size();\n    }\n  }\n\n  function SerializeUnlockCustodianViaRevertWitness(value) {\n    const array = new Uint8Array(0 + Byte32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.deposit_lock_hash)), 0);\n    return array.buffer;\n  }\n\n  class WithdrawalLockArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getAccountScriptHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getWithdrawalBlockHash() {\n      return new Byte32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Byte32.size()), {\n        validate: false,\n      });\n    }\n\n    getWithdrawalBlockNumber() {\n      return new Uint64(\n        this.view.buffer.slice(0 + Byte32.size() + Byte32.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size()),\n        { validate: false },\n      );\n    }\n\n    getSudtScriptHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + Byte32.size() + Uint64.size(),\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getSellAmount() {\n      return new Uint128(\n        this.view.buffer.slice(\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getSellCapacity() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getOwnerLockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n          0 +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getPaymentLockHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size(),\n          0 +\n            Byte32.size() +\n            Byte32.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Uint128.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, WithdrawalLockArgs.size());\n      this.getAccountScriptHash().validate(compatible);\n      this.getWithdrawalBlockHash().validate(compatible);\n      this.getWithdrawalBlockNumber().validate(compatible);\n      this.getSudtScriptHash().validate(compatible);\n      this.getSellAmount().validate(compatible);\n      this.getSellCapacity().validate(compatible);\n      this.getOwnerLockHash().validate(compatible);\n      this.getPaymentLockHash().validate(compatible);\n    }\n    static size() {\n      return (\n        0 +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size()\n      );\n    }\n  }\n\n  function SerializeWithdrawalLockArgs(value) {\n    const array = new Uint8Array(\n      0 +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.account_script_hash)), 0);\n    array.set(new Uint8Array(SerializeByte32(value.withdrawal_block_hash)), 0 + Byte32.size());\n    array.set(new Uint8Array(SerializeUint64(value.withdrawal_block_number)), 0 + Byte32.size() + Byte32.size());\n    array.set(\n      new Uint8Array(SerializeByte32(value.sudt_script_hash)),\n      0 + Byte32.size() + Byte32.size() + Uint64.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint128(value.sell_amount)),\n      0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeUint64(value.sell_capacity)),\n      0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.owner_lock_hash)),\n      0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.payment_lock_hash)),\n      0 +\n        Byte32.size() +\n        Byte32.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Uint128.size() +\n        Uint64.size() +\n        Byte32.size(),\n    );\n    return array.buffer;\n  }\n\n  class UnlockWithdrawalWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        assertDataLength(this.view.byteLength, \">4\");\n      }\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 1:\n          new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 2:\n          new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    unionType() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return \"UnlockWithdrawalViaFinalize\";\n        case 1:\n          return \"UnlockWithdrawalViaRevert\";\n        case 2:\n          return \"UnlockWithdrawalViaTrade\";\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    value() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false });\n        case 1:\n          return new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false });\n        case 2:\n          return new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false });\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n  }\n\n  function SerializeUnlockWithdrawalWitness(value) {\n    switch (value.type) {\n      case \"UnlockWithdrawalViaFinalize\": {\n        const itemBuffer = SerializeUnlockWithdrawalViaFinalize(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 0, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"UnlockWithdrawalViaRevert\": {\n        const itemBuffer = SerializeUnlockWithdrawalViaRevert(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 1, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"UnlockWithdrawalViaTrade\": {\n        const itemBuffer = SerializeUnlockWithdrawalViaTrade(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 2, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      default:\n        throw new Error(`Invalid type: ${value.type}`);\n    }\n  }\n\n  class UnlockWithdrawalViaFinalize {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      verifyAndExtractOffsets(this.view, 0, true);\n    }\n  }\n\n  function SerializeUnlockWithdrawalViaFinalize(value) {\n    const buffers = [];\n    return serializeTable(buffers);\n  }\n\n  class UnlockWithdrawalViaRevert {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getCustodianLockHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, UnlockWithdrawalViaRevert.size());\n      this.getCustodianLockHash().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size();\n    }\n  }\n\n  function SerializeUnlockWithdrawalViaRevert(value) {\n    const array = new Uint8Array(0 + Byte32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.custodian_lock_hash)), 0);\n    return array.buffer;\n  }\n\n  class UnlockWithdrawalViaTrade {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    }\n\n    getOwnerLock() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeUnlockWithdrawalViaTrade(value) {\n    const buffers = [];\n    buffers.push(SerializeScript(value.owner_lock));\n    return serializeTable(buffers);\n  }\n\n  class StakeLockArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getOwnerLockHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getStakeBlockNumber() {\n      return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, StakeLockArgs.size());\n      this.getOwnerLockHash().validate(compatible);\n      this.getStakeBlockNumber().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint64.size();\n    }\n  }\n\n  function SerializeStakeLockArgs(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0);\n    array.set(new Uint8Array(SerializeUint64(value.stake_block_number)), 0 + Byte32.size());\n    return array.buffer;\n  }\n\n  class MetaContractArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        assertDataLength(this.view.byteLength, \">4\");\n      }\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          new CreateAccount(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    unionType() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return \"CreateAccount\";\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    value() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return new CreateAccount(this.view.buffer.slice(4), { validate: false });\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n  }\n\n  function SerializeMetaContractArgs(value) {\n    switch (value.type) {\n      case \"CreateAccount\": {\n        const itemBuffer = SerializeCreateAccount(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 0, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      default:\n        throw new Error(`Invalid type: ${value.type}`);\n    }\n  }\n\n  class Fee {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getSudtId() {\n      return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n    }\n\n    getAmount() {\n      return new Uint128(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint128.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, Fee.size());\n      this.getSudtId().validate(compatible);\n      this.getAmount().validate(compatible);\n    }\n    static size() {\n      return 0 + Uint32.size() + Uint128.size();\n    }\n  }\n\n  function SerializeFee(value) {\n    const array = new Uint8Array(0 + Uint32.size() + Uint128.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint32(value.sudt_id)), 0);\n    array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size());\n    return array.buffer;\n  }\n\n  class CreateAccount {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Fee(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getScript() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getFee() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Fee(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCreateAccount(value) {\n    const buffers = [];\n    buffers.push(SerializeScript(value.script));\n    buffers.push(SerializeFee(value.fee));\n    return serializeTable(buffers);\n  }\n\n  class SUDTArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        assertDataLength(this.view.byteLength, \">4\");\n      }\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          new SUDTQuery(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 1:\n          new SUDTTransfer(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    unionType() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return \"SUDTQuery\";\n        case 1:\n          return \"SUDTTransfer\";\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    value() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return new SUDTQuery(this.view.buffer.slice(4), { validate: false });\n        case 1:\n          return new SUDTTransfer(this.view.buffer.slice(4), { validate: false });\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n  }\n\n  function SerializeSUDTArgs(value) {\n    switch (value.type) {\n      case \"SUDTQuery\": {\n        const itemBuffer = SerializeSUDTQuery(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 0, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"SUDTTransfer\": {\n        const itemBuffer = SerializeSUDTTransfer(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 1, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      default:\n        throw new Error(`Invalid type: ${value.type}`);\n    }\n  }\n\n  class SUDTQuery {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    }\n\n    getShortAddress() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeSUDTQuery(value) {\n    const buffers = [];\n    buffers.push(SerializeBytes(value.short_address));\n    return serializeTable(buffers);\n  }\n\n  class SUDTTransfer {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Uint128(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getTo() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getAmount() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getFee() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeSUDTTransfer(value) {\n    const buffers = [];\n    buffers.push(SerializeBytes(value.to));\n    buffers.push(SerializeUint128(value.amount));\n    buffers.push(SerializeUint128(value.fee));\n    return serializeTable(buffers);\n  }\n\n  class ChallengeTarget {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getBlockHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getTargetIndex() {\n      return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    getTargetType() {\n      return this.view.getUint8(0 + Byte32.size() + Uint32.size());\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, ChallengeTarget.size());\n      this.getBlockHash().validate(compatible);\n      this.getTargetIndex().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint32.size() + 1;\n    }\n  }\n\n  function SerializeChallengeTarget(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint32.size() + 1);\n    const view = new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.block_hash)), 0);\n    array.set(new Uint8Array(SerializeUint32(value.target_index)), 0 + Byte32.size());\n    view.setUint8(0 + Byte32.size() + Uint32.size(), value.target_type);\n    return array.buffer;\n  }\n\n  class ChallengeLockArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new ChallengeTarget(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getTarget() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new ChallengeTarget(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRewardsReceiverLock() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeChallengeLockArgs(value) {\n    const buffers = [];\n    buffers.push(SerializeChallengeTarget(value.target));\n    buffers.push(SerializeScript(value.rewards_receiver_lock));\n    return serializeTable(buffers);\n  }\n\n  class ChallengeWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getRawL2Block() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockProof() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeChallengeWitness(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2Block(value.raw_l2block));\n    buffers.push(SerializeBytes(value.block_proof));\n    return serializeTable(buffers);\n  }\n\n  class ScriptVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeScriptVec(value) {\n    return serializeTable(value.map((item) => SerializeScript(item)));\n  }\n\n  class BlockHashEntry {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getNumber() {\n      return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n    }\n\n    getHash() {\n      return new Byte32(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + Byte32.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, BlockHashEntry.size());\n      this.getNumber().validate(compatible);\n      this.getHash().validate(compatible);\n    }\n    static size() {\n      return 0 + Uint64.size() + Byte32.size();\n    }\n  }\n\n  function SerializeBlockHashEntry(value) {\n    const array = new Uint8Array(0 + Uint64.size() + Byte32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint64(value.number)), 0);\n    array.set(new Uint8Array(SerializeByte32(value.hash)), 0 + Uint64.size());\n    return array.buffer;\n  }\n\n  class BlockHashEntryVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * BlockHashEntry.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new BlockHashEntry(\n        this.view.buffer.slice(4 + i * BlockHashEntry.size(), 4 + (i + 1) * BlockHashEntry.size()),\n        { validate: false },\n      );\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeBlockHashEntryVec(value) {\n    const array = new Uint8Array(4 + BlockHashEntry.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeBlockHashEntry(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * BlockHashEntry.size());\n    }\n    return array.buffer;\n  }\n\n  class VerifyTransactionContext {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new BytesVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new ScriptVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new BlockHashEntryVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    }\n\n    getAccountCount() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvState() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getLoadData() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getScripts() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getReturnDataHash() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockHashes() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new BlockHashEntryVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeVerifyTransactionContext(value) {\n    const buffers = [];\n    buffers.push(SerializeUint32(value.account_count));\n    buffers.push(SerializeKVPairVec(value.kv_state));\n    buffers.push(SerializeBytesVec(value.load_data));\n    buffers.push(SerializeScriptVec(value.scripts));\n    buffers.push(SerializeByte32(value.return_data_hash));\n    buffers.push(SerializeBlockHashEntryVec(value.block_hashes));\n    return serializeTable(buffers);\n  }\n\n  class CKBMerkleProof {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint32Vec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getIndices() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getLemmas() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCKBMerkleProof(value) {\n    const buffers = [];\n    buffers.push(SerializeUint32Vec(value.indices));\n    buffers.push(SerializeByte32Vec(value.lemmas));\n    return serializeTable(buffers);\n  }\n\n  class VerifyTransactionWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new L2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new RawL2Block(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new VerifyTransactionContext(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    }\n\n    getL2Tx() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRawL2Block() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTxProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvStateProof() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockHashesProof() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getContext() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new VerifyTransactionContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeVerifyTransactionWitness(value) {\n    const buffers = [];\n    buffers.push(SerializeL2Transaction(value.l2tx));\n    buffers.push(SerializeRawL2Block(value.raw_l2block));\n    buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n    buffers.push(SerializeBytes(value.kv_state_proof));\n    buffers.push(SerializeBytes(value.block_hashes_proof));\n    buffers.push(SerializeVerifyTransactionContext(value.context));\n    return serializeTable(buffers);\n  }\n\n  class VerifyTransactionSignatureContext {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new ScriptVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getAccountCount() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvState() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getScripts() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeVerifyTransactionSignatureContext(value) {\n    const buffers = [];\n    buffers.push(SerializeUint32(value.account_count));\n    buffers.push(SerializeKVPairVec(value.kv_state));\n    buffers.push(SerializeScriptVec(value.scripts));\n    return serializeTable(buffers);\n  }\n\n  class VerifyTransactionSignatureWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new L2Transaction(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new VerifyTransactionSignatureContext(this.view.buffer.slice(offsets[4], offsets[5]), {\n        validate: false,\n      }).validate();\n    }\n\n    getRawL2Block() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getL2Tx() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTxProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getKvStateProof() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getContext() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new VerifyTransactionSignatureContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeVerifyTransactionSignatureWitness(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2Block(value.raw_l2block));\n    buffers.push(SerializeL2Transaction(value.l2tx));\n    buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n    buffers.push(SerializeBytes(value.kv_state_proof));\n    buffers.push(SerializeVerifyTransactionSignatureContext(value.context));\n    return serializeTable(buffers);\n  }\n\n  class VerifyWithdrawalWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new WithdrawalRequest(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getRawL2Block() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getWithdrawalRequest() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getWithdrawalProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeVerifyWithdrawalWitness(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2Block(value.raw_l2block));\n    buffers.push(SerializeWithdrawalRequest(value.withdrawal_request));\n    buffers.push(SerializeCKBMerkleProof(value.withdrawal_proof));\n    return serializeTable(buffers);\n  }\n\n  class RollupSubmitBlock {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new L2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getBlock() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new L2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRevertedBlockHashes() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRevertedBlockProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRollupSubmitBlock(value) {\n    const buffers = [];\n    buffers.push(SerializeL2Block(value.block));\n    buffers.push(SerializeByte32Vec(value.reverted_block_hashes));\n    buffers.push(SerializeBytes(value.reverted_block_proof));\n    return serializeTable(buffers);\n  }\n\n  class RollupEnterChallenge {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new ChallengeWitness(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    }\n\n    getWitness() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new ChallengeWitness(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRollupEnterChallenge(value) {\n    const buffers = [];\n    buffers.push(SerializeChallengeWitness(value.witness));\n    return serializeTable(buffers);\n  }\n\n  class RollupCancelChallenge {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      verifyAndExtractOffsets(this.view, 0, true);\n    }\n  }\n\n  function SerializeRollupCancelChallenge(value) {\n    const buffers = [];\n    return serializeTable(buffers);\n  }\n\n  class RollupRevert {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawL2BlockVec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new RawL2Block(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    }\n\n    getRevertedBlocks() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawL2BlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getBlockProof() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getRevertedBlockProof() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getNewTipBlock() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRollupRevert(value) {\n    const buffers = [];\n    buffers.push(SerializeRawL2BlockVec(value.reverted_blocks));\n    buffers.push(SerializeBytes(value.block_proof));\n    buffers.push(SerializeBytes(value.reverted_block_proof));\n    buffers.push(SerializeRawL2Block(value.new_tip_block));\n    return serializeTable(buffers);\n  }\n\n  class RollupAction {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        assertDataLength(this.view.byteLength, \">4\");\n      }\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 1:\n          new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 2:\n          new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        case 3:\n          new RollupRevert(this.view.buffer.slice(4), { validate: false }).validate();\n          break;\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    unionType() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return \"RollupSubmitBlock\";\n        case 1:\n          return \"RollupEnterChallenge\";\n        case 2:\n          return \"RollupCancelChallenge\";\n        case 3:\n          return \"RollupRevert\";\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n\n    value() {\n      const t = this.view.getUint32(0, true);\n      switch (t) {\n        case 0:\n          return new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false });\n        case 1:\n          return new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false });\n        case 2:\n          return new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false });\n        case 3:\n          return new RollupRevert(this.view.buffer.slice(4), { validate: false });\n        default:\n          throw new Error(`Invalid type: ${t}`);\n      }\n    }\n  }\n\n  function SerializeRollupAction(value) {\n    switch (value.type) {\n      case \"RollupSubmitBlock\": {\n        const itemBuffer = SerializeRollupSubmitBlock(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 0, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"RollupEnterChallenge\": {\n        const itemBuffer = SerializeRollupEnterChallenge(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 1, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"RollupCancelChallenge\": {\n        const itemBuffer = SerializeRollupCancelChallenge(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 2, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      case \"RollupRevert\": {\n        const itemBuffer = SerializeRollupRevert(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 3, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n      default:\n        throw new Error(`Invalid type: ${value.type}`);\n    }\n  }\n\n  class Uint16 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 2);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    toBigEndianUint16() {\n      return this.view.getUint16(0, false);\n    }\n\n    toLittleEndianUint16() {\n      return this.view.getUint16(0, true);\n    }\n\n    static size() {\n      return 2;\n    }\n  }\n\n  function SerializeUint16(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 2);\n    return buffer;\n  }\n\n  class Uint32 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 4);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    toBigEndianUint32() {\n      return this.view.getUint32(0, false);\n    }\n\n    toLittleEndianUint32() {\n      return this.view.getUint32(0, true);\n    }\n\n    static size() {\n      return 4;\n    }\n  }\n\n  function SerializeUint32(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 4);\n    return buffer;\n  }\n\n  class Uint64 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 8);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    toBigEndianBigUint64() {\n      return this.view.getBigUint64(0, false);\n    }\n\n    toLittleEndianBigUint64() {\n      return this.view.getBigUint64(0, true);\n    }\n\n    static size() {\n      return 8;\n    }\n  }\n\n  function SerializeUint64(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 8);\n    return buffer;\n  }\n\n  class Uint128 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 16);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    static size() {\n      return 16;\n    }\n  }\n\n  function SerializeUint128(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 16);\n    return buffer;\n  }\n\n  class Byte32 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 32);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    static size() {\n      return 32;\n    }\n  }\n\n  function SerializeByte32(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 32);\n    return buffer;\n  }\n\n  class Uint256 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 32);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    static size() {\n      return 32;\n    }\n  }\n\n  function SerializeUint256(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 32);\n    return buffer;\n  }\n\n  class Bytes {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n    }\n\n    raw() {\n      return this.view.buffer.slice(4);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(4 + i);\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeBytes(value) {\n    const item = assertArrayBuffer(value);\n    const array = new Uint8Array(4 + item.byteLength);\n    new DataView(array.buffer).setUint32(0, item.byteLength, true);\n    array.set(new Uint8Array(item), 4);\n    return array.buffer;\n  }\n\n  class BytesOpt {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.hasValue()) {\n        this.value().validate(compatible);\n      }\n    }\n\n    value() {\n      return new Bytes(this.view.buffer, { validate: false });\n    }\n\n    hasValue() {\n      return this.view.byteLength > 0;\n    }\n  }\n\n  function SerializeBytesOpt(value) {\n    if (value) {\n      return SerializeBytes(value);\n    } else {\n      return new ArrayBuffer(0);\n    }\n  }\n\n  class BytesVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeBytesVec(value) {\n    return serializeTable(value.map((item) => SerializeBytes(item)));\n  }\n\n  class Byte32Vec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * Byte32.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {\n        validate: false,\n      });\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeByte32Vec(value) {\n    const array = new Uint8Array(4 + Byte32.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeByte32(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n    }\n    return array.buffer;\n  }\n\n  class ScriptOpt {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.hasValue()) {\n        this.value().validate(compatible);\n      }\n    }\n\n    value() {\n      return new Script(this.view.buffer, { validate: false });\n    }\n\n    hasValue() {\n      return this.view.byteLength > 0;\n    }\n  }\n\n  function SerializeScriptOpt(value) {\n    if (value) {\n      return SerializeScript(value);\n    } else {\n      return new ArrayBuffer(0);\n    }\n  }\n\n  class ProposalShortId {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, 10);\n    }\n\n    indexAt(i) {\n      return this.view.getUint8(i);\n    }\n\n    raw() {\n      return this.view.buffer;\n    }\n\n    static size() {\n      return 10;\n    }\n  }\n\n  function SerializeProposalShortId(value) {\n    const buffer = assertArrayBuffer(value);\n    assertDataLength(buffer.byteLength, 10);\n    return buffer;\n  }\n\n  class UncleBlockVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new UncleBlock(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeUncleBlockVec(value) {\n    return serializeTable(value.map((item) => SerializeUncleBlock(item)));\n  }\n\n  class TransactionVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeTransactionVec(value) {\n    return serializeTable(value.map((item) => SerializeTransaction(item)));\n  }\n\n  class ProposalShortIdVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new ProposalShortId(\n        this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()),\n        { validate: false },\n      );\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeProposalShortIdVec(value) {\n    const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeProposalShortId(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n    }\n    return array.buffer;\n  }\n\n  class CellDepVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * CellDep.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {\n        validate: false,\n      });\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeCellDepVec(value) {\n    const array = new Uint8Array(4 + CellDep.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeCellDep(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n    }\n    return array.buffer;\n  }\n\n  class CellInputVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      if (this.view.byteLength < 4) {\n        dataLengthError(this.view.byteLength, \">4\");\n      }\n      const requiredByteLength = this.length() * CellInput.size() + 4;\n      assertDataLength(this.view.byteLength, requiredByteLength);\n      for (let i = 0; i < 0; i++) {\n        const item = this.indexAt(i);\n        item.validate(compatible);\n      }\n    }\n\n    indexAt(i) {\n      return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {\n        validate: false,\n      });\n    }\n\n    length() {\n      return this.view.getUint32(0, true);\n    }\n  }\n\n  function SerializeCellInputVec(value) {\n    const array = new Uint8Array(4 + CellInput.size() * value.length);\n    new DataView(array.buffer).setUint32(0, value.length, true);\n    for (let i = 0; i < value.length; i++) {\n      const itemBuffer = SerializeCellInput(value[i]);\n      array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n    }\n    return array.buffer;\n  }\n\n  class CellOutputVec {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      for (let i = 0; i < offsets.length - 1; i++) {\n        new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n      }\n    }\n\n    length() {\n      if (this.view.byteLength < 8) {\n        return 0;\n      } else {\n        return this.view.getUint32(4, true) / 4 - 1;\n      }\n    }\n\n    indexAt(i) {\n      const start = 4 + i * 4;\n      const offset = this.view.getUint32(start, true);\n      let offset_end = this.view.byteLength;\n      if (i + 1 < this.length()) {\n        offset_end = this.view.getUint32(start + 4, true);\n      }\n      return new CellOutput(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCellOutputVec(value) {\n    return serializeTable(value.map((item) => SerializeCellOutput(item)));\n  }\n\n  class Script {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      if (offsets[2] - offsets[1] !== 1) {\n        throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);\n      }\n      new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getCodeHash() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getHashType() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n    }\n\n    getArgs() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeScript(value) {\n    const buffers = [];\n    buffers.push(SerializeByte32(value.code_hash));\n    const hashTypeView = new DataView(new ArrayBuffer(1));\n    hashTypeView.setUint8(0, value.hash_type);\n    buffers.push(hashTypeView.buffer);\n    buffers.push(SerializeBytes(value.args));\n    return serializeTable(buffers);\n  }\n\n  class OutPoint {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getTxHash() {\n      return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n    }\n\n    getIndex() {\n      return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, OutPoint.size());\n      this.getTxHash().validate(compatible);\n      this.getIndex().validate(compatible);\n    }\n    static size() {\n      return 0 + Byte32.size() + Uint32.size();\n    }\n  }\n\n  function SerializeOutPoint(value) {\n    const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n    array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n    return array.buffer;\n  }\n\n  class CellInput {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getSince() {\n      return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n    }\n\n    getPreviousOutput() {\n      return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, CellInput.size());\n      this.getSince().validate(compatible);\n      this.getPreviousOutput().validate(compatible);\n    }\n    static size() {\n      return 0 + Uint64.size() + OutPoint.size();\n    }\n  }\n\n  function SerializeCellInput(value) {\n    const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n    array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n    return array.buffer;\n  }\n\n  class CellOutput {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getCapacity() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getLock() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getType() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new ScriptOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCellOutput(value) {\n    const buffers = [];\n    buffers.push(SerializeUint64(value.capacity));\n    buffers.push(SerializeScript(value.lock));\n    buffers.push(SerializeScriptOpt(value.type_));\n    return serializeTable(buffers);\n  }\n\n  class CellDep {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getOutPoint() {\n      return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), { validate: false });\n    }\n\n    getDepType() {\n      return this.view.getUint8(0 + OutPoint.size());\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, CellDep.size());\n      this.getOutPoint().validate(compatible);\n    }\n    static size() {\n      return 0 + OutPoint.size() + 1;\n    }\n  }\n\n  function SerializeCellDep(value) {\n    const array = new Uint8Array(0 + OutPoint.size() + 1);\n    const view = new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n    view.setUint8(0 + OutPoint.size(), value.dep_type);\n    return array.buffer;\n  }\n\n  class RawTransaction {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n      new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    }\n\n    getVersion() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getCellDeps() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new CellDepVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getHeaderDeps() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getInputs() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new CellInputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getOutputs() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new CellOutputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getOutputsData() {\n      const start = 24;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeRawTransaction(value) {\n    const buffers = [];\n    buffers.push(SerializeUint32(value.version));\n    buffers.push(SerializeCellDepVec(value.cell_deps));\n    buffers.push(SerializeByte32Vec(value.header_deps));\n    buffers.push(SerializeCellInputVec(value.inputs));\n    buffers.push(SerializeCellOutputVec(value.outputs));\n    buffers.push(SerializeBytesVec(value.outputs_data));\n    return serializeTable(buffers);\n  }\n\n  class Transaction {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getRaw() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new RawTransaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getWitnesses() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeTransaction(value) {\n    const buffers = [];\n    buffers.push(SerializeRawTransaction(value.raw));\n    buffers.push(SerializeBytesVec(value.witnesses));\n    return serializeTable(buffers);\n  }\n\n  class RawHeader {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getVersion() {\n      return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n    }\n\n    getCompactTarget() {\n      return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {\n        validate: false,\n      });\n    }\n\n    getTimestamp() {\n      return new Uint64(\n        this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()),\n        { validate: false },\n      );\n    }\n\n    getNumber() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint32.size() + Uint64.size(),\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getEpoch() {\n      return new Uint64(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getParentHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getTransactionsRoot() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getProposalsHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getExtraHash() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    getDao() {\n      return new Byte32(\n        this.view.buffer.slice(\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size(),\n          0 +\n            Uint32.size() +\n            Uint32.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Uint64.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size() +\n            Byte32.size(),\n        ),\n        { validate: false },\n      );\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, RawHeader.size());\n      this.getVersion().validate(compatible);\n      this.getCompactTarget().validate(compatible);\n      this.getTimestamp().validate(compatible);\n      this.getNumber().validate(compatible);\n      this.getEpoch().validate(compatible);\n      this.getParentHash().validate(compatible);\n      this.getTransactionsRoot().validate(compatible);\n      this.getProposalsHash().validate(compatible);\n      this.getExtraHash().validate(compatible);\n      this.getDao().validate(compatible);\n    }\n    static size() {\n      return (\n        0 +\n        Uint32.size() +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size()\n      );\n    }\n  }\n\n  function SerializeRawHeader(value) {\n    const array = new Uint8Array(\n      0 +\n        Uint32.size() +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n    array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n    array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n    array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n    array.set(\n      new Uint8Array(SerializeUint64(value.epoch)),\n      0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.parent_hash)),\n      0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.transactions_root)),\n      0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.proposals_hash)),\n      0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.extra_hash)),\n      0 +\n        Uint32.size() +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    array.set(\n      new Uint8Array(SerializeByte32(value.dao)),\n      0 +\n        Uint32.size() +\n        Uint32.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Uint64.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size() +\n        Byte32.size(),\n    );\n    return array.buffer;\n  }\n\n  class Header {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    getRaw() {\n      return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), { validate: false });\n    }\n\n    getNonce() {\n      return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {\n        validate: false,\n      });\n    }\n\n    validate(compatible = false) {\n      assertDataLength(this.view.byteLength, Header.size());\n      this.getRaw().validate(compatible);\n      this.getNonce().validate(compatible);\n    }\n    static size() {\n      return 0 + RawHeader.size() + Uint128.size();\n    }\n  }\n\n  function SerializeHeader(value) {\n    const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n    new DataView(array.buffer);\n    array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n    array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n    return array.buffer;\n  }\n\n  class UncleBlock {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getHeader() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getProposals() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeUncleBlock(value) {\n    const buffers = [];\n    buffers.push(SerializeHeader(value.header));\n    buffers.push(SerializeProposalShortIdVec(value.proposals));\n    return serializeTable(buffers);\n  }\n\n  class Block {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    }\n\n    getHeader() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getUncles() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTransactions() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getProposals() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeBlock(value) {\n    const buffers = [];\n    buffers.push(SerializeHeader(value.header));\n    buffers.push(SerializeUncleBlockVec(value.uncles));\n    buffers.push(SerializeTransactionVec(value.transactions));\n    buffers.push(SerializeProposalShortIdVec(value.proposals));\n    return serializeTable(buffers);\n  }\n\n  class BlockV1 {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n      new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    }\n\n    getHeader() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getUncles() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getTransactions() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getProposals() {\n      const start = 16;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getExtension() {\n      const start = 20;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeBlockV1(value) {\n    const buffers = [];\n    buffers.push(SerializeHeader(value.header));\n    buffers.push(SerializeUncleBlockVec(value.uncles));\n    buffers.push(SerializeTransactionVec(value.transactions));\n    buffers.push(SerializeProposalShortIdVec(value.proposals));\n    buffers.push(SerializeBytes(value.extension));\n    return serializeTable(buffers);\n  }\n\n  class CellbaseWitness {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    }\n\n    getLock() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getMessage() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeCellbaseWitness(value) {\n    const buffers = [];\n    buffers.push(SerializeScript(value.lock));\n    buffers.push(SerializeBytes(value.message));\n    return serializeTable(buffers);\n  }\n\n  class WitnessArgs {\n    constructor(reader, { validate = true } = {}) {\n      this.view = new DataView(assertArrayBuffer(reader));\n      if (validate) {\n        this.validate();\n      }\n    }\n\n    validate(compatible = false) {\n      const offsets = verifyAndExtractOffsets(this.view, 0, true);\n      new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n      new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n      new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    }\n\n    getLock() {\n      const start = 4;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getInputType() {\n      const start = 8;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.getUint32(start + 4, true);\n      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n\n    getOutputType() {\n      const start = 12;\n      const offset = this.view.getUint32(start, true);\n      const offset_end = this.view.byteLength;\n      return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n    }\n  }\n\n  function SerializeWitnessArgs(value) {\n    const buffers = [];\n    buffers.push(SerializeBytesOpt(value.lock));\n    buffers.push(SerializeBytesOpt(value.input_type));\n    buffers.push(SerializeBytesOpt(value.output_type));\n    return serializeTable(buffers);\n  }\n\n  exports.AccountMerkleState = AccountMerkleState;\n  exports.Block = Block;\n  exports.BlockHashEntry = BlockHashEntry;\n  exports.BlockHashEntryVec = BlockHashEntryVec;\n  exports.BlockInfo = BlockInfo;\n  exports.BlockMerkleState = BlockMerkleState;\n  exports.BlockV1 = BlockV1;\n  exports.Byte32 = Byte32;\n  exports.Byte32Vec = Byte32Vec;\n  exports.Bytes = Bytes;\n  exports.BytesOpt = BytesOpt;\n  exports.BytesVec = BytesVec;\n  exports.CKBMerkleProof = CKBMerkleProof;\n  exports.CellDep = CellDep;\n  exports.CellDepVec = CellDepVec;\n  exports.CellInput = CellInput;\n  exports.CellInputVec = CellInputVec;\n  exports.CellOutput = CellOutput;\n  exports.CellOutputVec = CellOutputVec;\n  exports.CellbaseWitness = CellbaseWitness;\n  exports.ChallengeLockArgs = ChallengeLockArgs;\n  exports.ChallengeTarget = ChallengeTarget;\n  exports.ChallengeWitness = ChallengeWitness;\n  exports.CreateAccount = CreateAccount;\n  exports.CustodianLockArgs = CustodianLockArgs;\n  exports.DepositLockArgs = DepositLockArgs;\n  exports.DepositRequest = DepositRequest;\n  exports.DepositRequestVec = DepositRequestVec;\n  exports.Fee = Fee;\n  exports.GlobalState = GlobalState;\n  exports.GlobalStateV0 = GlobalStateV0;\n  exports.Header = Header;\n  exports.KVPair = KVPair;\n  exports.KVPairVec = KVPairVec;\n  exports.L2Block = L2Block;\n  exports.L2Transaction = L2Transaction;\n  exports.L2TransactionVec = L2TransactionVec;\n  exports.MetaContractArgs = MetaContractArgs;\n  exports.OutPoint = OutPoint;\n  exports.ProposalShortId = ProposalShortId;\n  exports.ProposalShortIdVec = ProposalShortIdVec;\n  exports.RawHeader = RawHeader;\n  exports.RawL2Block = RawL2Block;\n  exports.RawL2BlockVec = RawL2BlockVec;\n  exports.RawL2Transaction = RawL2Transaction;\n  exports.RawTransaction = RawTransaction;\n  exports.RawWithdrawalRequest = RawWithdrawalRequest;\n  exports.RollupAction = RollupAction;\n  exports.RollupCancelChallenge = RollupCancelChallenge;\n  exports.RollupConfig = RollupConfig;\n  exports.RollupEnterChallenge = RollupEnterChallenge;\n  exports.RollupRevert = RollupRevert;\n  exports.RollupSubmitBlock = RollupSubmitBlock;\n  exports.SUDTArgs = SUDTArgs;\n  exports.SUDTQuery = SUDTQuery;\n  exports.SUDTTransfer = SUDTTransfer;\n  exports.Script = Script;\n  exports.ScriptOpt = ScriptOpt;\n  exports.ScriptVec = ScriptVec;\n  exports.SerializeAccountMerkleState = SerializeAccountMerkleState;\n  exports.SerializeBlock = SerializeBlock;\n  exports.SerializeBlockHashEntry = SerializeBlockHashEntry;\n  exports.SerializeBlockHashEntryVec = SerializeBlockHashEntryVec;\n  exports.SerializeBlockInfo = SerializeBlockInfo;\n  exports.SerializeBlockMerkleState = SerializeBlockMerkleState;\n  exports.SerializeBlockV1 = SerializeBlockV1;\n  exports.SerializeByte32 = SerializeByte32;\n  exports.SerializeByte32Vec = SerializeByte32Vec;\n  exports.SerializeBytes = SerializeBytes;\n  exports.SerializeBytesOpt = SerializeBytesOpt;\n  exports.SerializeBytesVec = SerializeBytesVec;\n  exports.SerializeCKBMerkleProof = SerializeCKBMerkleProof;\n  exports.SerializeCellDep = SerializeCellDep;\n  exports.SerializeCellDepVec = SerializeCellDepVec;\n  exports.SerializeCellInput = SerializeCellInput;\n  exports.SerializeCellInputVec = SerializeCellInputVec;\n  exports.SerializeCellOutput = SerializeCellOutput;\n  exports.SerializeCellOutputVec = SerializeCellOutputVec;\n  exports.SerializeCellbaseWitness = SerializeCellbaseWitness;\n  exports.SerializeChallengeLockArgs = SerializeChallengeLockArgs;\n  exports.SerializeChallengeTarget = SerializeChallengeTarget;\n  exports.SerializeChallengeWitness = SerializeChallengeWitness;\n  exports.SerializeCreateAccount = SerializeCreateAccount;\n  exports.SerializeCustodianLockArgs = SerializeCustodianLockArgs;\n  exports.SerializeDepositLockArgs = SerializeDepositLockArgs;\n  exports.SerializeDepositRequest = SerializeDepositRequest;\n  exports.SerializeDepositRequestVec = SerializeDepositRequestVec;\n  exports.SerializeFee = SerializeFee;\n  exports.SerializeGlobalState = SerializeGlobalState;\n  exports.SerializeGlobalStateV0 = SerializeGlobalStateV0;\n  exports.SerializeHeader = SerializeHeader;\n  exports.SerializeKVPair = SerializeKVPair;\n  exports.SerializeKVPairVec = SerializeKVPairVec;\n  exports.SerializeL2Block = SerializeL2Block;\n  exports.SerializeL2Transaction = SerializeL2Transaction;\n  exports.SerializeL2TransactionVec = SerializeL2TransactionVec;\n  exports.SerializeMetaContractArgs = SerializeMetaContractArgs;\n  exports.SerializeOutPoint = SerializeOutPoint;\n  exports.SerializeProposalShortId = SerializeProposalShortId;\n  exports.SerializeProposalShortIdVec = SerializeProposalShortIdVec;\n  exports.SerializeRawHeader = SerializeRawHeader;\n  exports.SerializeRawL2Block = SerializeRawL2Block;\n  exports.SerializeRawL2BlockVec = SerializeRawL2BlockVec;\n  exports.SerializeRawL2Transaction = SerializeRawL2Transaction;\n  exports.SerializeRawTransaction = SerializeRawTransaction;\n  exports.SerializeRawWithdrawalRequest = SerializeRawWithdrawalRequest;\n  exports.SerializeRollupAction = SerializeRollupAction;\n  exports.SerializeRollupCancelChallenge = SerializeRollupCancelChallenge;\n  exports.SerializeRollupConfig = SerializeRollupConfig;\n  exports.SerializeRollupEnterChallenge = SerializeRollupEnterChallenge;\n  exports.SerializeRollupRevert = SerializeRollupRevert;\n  exports.SerializeRollupSubmitBlock = SerializeRollupSubmitBlock;\n  exports.SerializeSUDTArgs = SerializeSUDTArgs;\n  exports.SerializeSUDTQuery = SerializeSUDTQuery;\n  exports.SerializeSUDTTransfer = SerializeSUDTTransfer;\n  exports.SerializeScript = SerializeScript;\n  exports.SerializeScriptOpt = SerializeScriptOpt;\n  exports.SerializeScriptVec = SerializeScriptVec;\n  exports.SerializeStakeLockArgs = SerializeStakeLockArgs;\n  exports.SerializeSubmitTransactions = SerializeSubmitTransactions;\n  exports.SerializeSubmitWithdrawals = SerializeSubmitWithdrawals;\n  exports.SerializeTransaction = SerializeTransaction;\n  exports.SerializeTransactionVec = SerializeTransactionVec;\n  exports.SerializeUint128 = SerializeUint128;\n  exports.SerializeUint16 = SerializeUint16;\n  exports.SerializeUint256 = SerializeUint256;\n  exports.SerializeUint32 = SerializeUint32;\n  exports.SerializeUint32Vec = SerializeUint32Vec;\n  exports.SerializeUint64 = SerializeUint64;\n  exports.SerializeUncleBlock = SerializeUncleBlock;\n  exports.SerializeUncleBlockVec = SerializeUncleBlockVec;\n  exports.SerializeUnlockCustodianViaRevertWitness = SerializeUnlockCustodianViaRevertWitness;\n  exports.SerializeUnlockWithdrawalViaFinalize = SerializeUnlockWithdrawalViaFinalize;\n  exports.SerializeUnlockWithdrawalViaRevert = SerializeUnlockWithdrawalViaRevert;\n  exports.SerializeUnlockWithdrawalViaTrade = SerializeUnlockWithdrawalViaTrade;\n  exports.SerializeUnlockWithdrawalWitness = SerializeUnlockWithdrawalWitness;\n  exports.SerializeVerifyTransactionContext = SerializeVerifyTransactionContext;\n  exports.SerializeVerifyTransactionSignatureContext = SerializeVerifyTransactionSignatureContext;\n  exports.SerializeVerifyTransactionSignatureWitness = SerializeVerifyTransactionSignatureWitness;\n  exports.SerializeVerifyTransactionWitness = SerializeVerifyTransactionWitness;\n  exports.SerializeVerifyWithdrawalWitness = SerializeVerifyWithdrawalWitness;\n  exports.SerializeWithdrawalLockArgs = SerializeWithdrawalLockArgs;\n  exports.SerializeWithdrawalRequest = SerializeWithdrawalRequest;\n  exports.SerializeWithdrawalRequestVec = SerializeWithdrawalRequestVec;\n  exports.SerializeWitnessArgs = SerializeWitnessArgs;\n  exports.StakeLockArgs = StakeLockArgs;\n  exports.SubmitTransactions = SubmitTransactions;\n  exports.SubmitWithdrawals = SubmitWithdrawals;\n  exports.Transaction = Transaction;\n  exports.TransactionVec = TransactionVec;\n  exports.Uint128 = Uint128;\n  exports.Uint16 = Uint16;\n  exports.Uint256 = Uint256;\n  exports.Uint32 = Uint32;\n  exports.Uint32Vec = Uint32Vec;\n  exports.Uint64 = Uint64;\n  exports.UncleBlock = UncleBlock;\n  exports.UncleBlockVec = UncleBlockVec;\n  exports.UnlockCustodianViaRevertWitness = UnlockCustodianViaRevertWitness;\n  exports.UnlockWithdrawalViaFinalize = UnlockWithdrawalViaFinalize;\n  exports.UnlockWithdrawalViaRevert = UnlockWithdrawalViaRevert;\n  exports.UnlockWithdrawalViaTrade = UnlockWithdrawalViaTrade;\n  exports.UnlockWithdrawalWitness = UnlockWithdrawalWitness;\n  exports.VerifyTransactionContext = VerifyTransactionContext;\n  exports.VerifyTransactionSignatureContext = VerifyTransactionSignatureContext;\n  exports.VerifyTransactionSignatureWitness = VerifyTransactionSignatureWitness;\n  exports.VerifyTransactionWitness = VerifyTransactionWitness;\n  exports.VerifyWithdrawalWitness = VerifyWithdrawalWitness;\n  exports.WithdrawalLockArgs = WithdrawalLockArgs;\n  exports.WithdrawalRequest = WithdrawalRequest;\n  exports.WithdrawalRequestVec = WithdrawalRequestVec;\n  exports.WitnessArgs = WitnessArgs;\n\n  Object.defineProperty(exports, \"__esModule\", { value: true });\n});\n"],"sourceRoot":""}