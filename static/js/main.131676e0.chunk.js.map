{"version":3,"sources":["light-godwoken/constants/index.ts","light-godwoken/constants/tokens.ts","light-godwoken/godwoken/normalizer.ts","light-godwoken/constants/providerConfig.ts","light-godwoken/schemas/index.esm.js","light-godwoken/godwoken/godwoken.ts","light-godwoken/omni-lock/omni.js","light-godwoken/lightGodwokenProvider.ts","light-godwoken/constants/sudtErc20ProxyAbi.ts","light-godwoken/lightGodwoken.ts","contexts/LightGodwokenContext.tsx","hooks/useLightGodwoken.ts","utils/formatTokenAmount.ts","views/NumericalInput.tsx","views/CKBInputPanel.tsx","utils/getTimePeriods.ts","views/WithdrawalRequestCard.tsx","views/CurrencyInputPanel.tsx","components/Address/index.tsx","components/ConnectButton/index.tsx","views/PageHeader.tsx","views/Page.tsx","views/RequestWithdrawal.tsx","views/Withdrawal.tsx","hooks/useClock.ts","App.js","reportWebVitals.js","index.js"],"names":["SCRIPTS","code_hash","hash_type","tx_hash","index","dep_type","short_id","ROLLUP_CONFIG","TOKEN_LIST","symbol","name","decimals","tokenURI","sudt_script_hash","address","issuerLockHash","l1Lock","args","normalizeHexNumber","length","debugPath","value","ArrayBuffer","intValue","BigInt","toString","Error","view","DataView","i","start","setUint8","parseInt","substr","buffer","byteLength","array","Uint8Array","set","normalizeRawData","Reader","toArrayBuffer","normalizeObject","obj","keys","result","key","f","Object","entries","undefined","toNormalize","normalize","NormalizeFee","fee","sudt_id","amount","NormalizeRawWithdrawalRequest","raw_request","nonce","capacity","account_script_hash","sell_amount","sell_capacity","owner_lock_hash","payment_lock_hash","PROVIDER_CONFIG","CKB_INDEXER_URL","CKB_RPC_URL","GW_POLYJUICE_RPC_URL","dataLengthError","actual","required","assertDataLength","assertArrayBuffer","reader","Function","serializeTable","buffers","itemCount","totalSize","offsets","push","setUint32","SerializeRawWithdrawalRequest","Uint32","size","Uint64","Uint128","Byte32","Fee","SerializeUint32","SerializeUint64","SerializeUint128","SerializeByte32","SerializeFee","SerializeWithdrawalRequest","raw","SerializeBytes","signature","SerializeUnlockWithdrawalViaFinalize","constructor","validate","this","getSudtId","slice","getAmount","compatible","indexAt","getUint8","toBigEndianUint32","getUint32","toLittleEndianUint32","toBigEndianBigUint64","getBigUint64","toLittleEndianBigUint64","item","GodwokenClient","url","rpc","RPC","method_name","request","data","NormalizeWithdrawalRequest","serializeJson","rpcCall","scriptHash","shortAddress","txHash","accountId","SerializeRcIdentity","SerializeIdentity","identity","map","maskView","mask","SerializeSmtProof","proof","SerializeSmtProofEntry","SerializeSmtProofEntryVec","proofs","SerializeRcLockWitnessLock","SerializeBytesOpt","SerializeRcIdentityOpt","rc_identity","preimage","POLYJUICE_CONFIG","web3Url","abiItems","polyjuiceProvider","PolyjuiceHttpProvider","DefaultLightGodwokenProvider","ethAddress","ethereum","env","l2Address","l1Address","ckbIndexer","web3","godwokenClient","config","initializeConfig","predefined","AGGRON4","Indexer","LINA","generateL1Address","on","accounts","console","log","Web3","withdrawalRequest","submitWithdrawalRequest","getL2Address","getL1Address","isMetaMask","method","then","catch","error","code","omniLock","substring","helpers","generateAddress","tx","send_transaction","txSkeleton","message","generateMessage","signedMessage","params","selectedAddress","v","Number","padStart","signedWitness","toolkit","core","SerializeWitnessArgs","lock","update","witnesses","createTransactionFromSkeleton","hasher","utils","CKBHasher","rawTxHash","ckbHash","SerializeRawTransaction","normalizers","NormalizeRawTransaction","serializedWitness","repeat","hashWitness","digestHex","witness","lengthBuffer","setBigUint64","queryOptions","type","collector","rollupCell","cell","collect","getRollupCell","globalState","godwokenCore","GlobalState","lastFinalizedBlockNumber","getLastFinalizedBlockNumber","DefaultLightGodwoken","provider","getBlockProduceTime","payload","parseAddress","outputCells","cell_output","dummySudtCell","sudtCapacity","minimalCellCapacity","capacityLeft","newWitnessArgs","NormalizeWitnessArgs","withdrawalWitness","TransactionSkeleton","cellProvider","omniLockCellDep","out_point","secp256k1CellDep","withdrawalLockDep","cell_dep","rollupDep","inputs","outputs","cell_deps","sudtCellDep","injectCapacity","signedTx","signL1Transaction","sendL1Transaction","searchParams","getWithdrawalCellSearchParams","collectedCells","script","ownerCKBLock","ownerLock","ownerLockHash","computeScriptHash","rawLockArgs","lockArgs","WithdrawalLockArgs","withdrawBlock","getWithdrawalBlockNumber","containsOwnerLock","includes","erc20","sudtTypeHash","sudtType","getBuiltinErc20List","find","e","readBigUInt128LE","withdrawalBlockNumber","remainingBlockNumber","Math","max","sortedWithdrawals","sort","a","b","startsWith","layer2Lock","script_type_hash","toLowerCase","accountScriptHash","script_type","withdrawWithEvent","eventEmitter","EventEmitter","withdraw","emit","rollupTypeHash","ethAccountTypeHash","withdrawal_address","l2AccountScript","fromId","getAccountIdByScriptHash","isSudt","minCapacity","minimalWithdrawalCapacity","getNonce","paymentLockHash","rawWithdrawalRequest","generateWithdrawalMessageToSign","signatureMetamaskPersonalSign","signMessageMetamaskPersonalSign","loop","nIntervId","setInterval","async","withdrawal","getWithdrawal","status","clearInterval","signMessage","privateKey","signObject","secp256k1","signatureBuffer","signatureArray","recid","serializedRawWithdrawalRequest","dummyHash","dummyHexNumber","dummyRollupTypeHash","dummyWithdrawalLockArgs","withdrawal_block_hash","withdrawal_block_number","serialized","SerializeWithdrawalLockArgs","withdrawal_lock_args","NormalizeWithdrawalLockArgs","balance","eth","getBalance","forEach","token","tokenL1Script","tokenScriptHash","balances","promises","addresses","usdcBalancePromise","Contract","methods","balanceOf","call","Promise","all","values","fromScript","neededCapacity","collectedSum","changeOutput","LightGodwokenContext","createContext","Provider","props","lightGodwoken","setLightGodwoken","useState","useEffect","detectEthereumProvider","instance","children","useLightGodwoken","useContext","getDisplayAmount","valueStr","intPart","unit","decPart","round","toFixed","replace","getFullDisplayAmount","options","maxDecimalPlace","StyledInput","styled","input","align","inputRegex","RegExp","Input","React","memo","onUserInput","placeholder","rest","onChange","event","nextUserInput","target","test","inputMode","title","autoComplete","autoCorrect","pattern","minLength","maxLength","spellCheck","StyleWrapper","div","Row","CKBInputPanel","label","showMaxButton","setShowMaxButton","l2CkbBalance","setL2CkbBalance","getL2CkbBalance","fetchData","className","Text","NumericalInput","val","onClick","src","alt","HOUR_IN_SECONDS","DAY_IN_SECONDS","MONTH_IN_SECONDS","YEAR_IN_SECONDS","getTimePeriods","seconds","delta","abs","timeLeft","years","months","days","hours","minutes","floor","Typography","FixedHeightRow","WithdrawalRequestCard","now","shouldShowMore","setShouldShowMore","blockProduceTime","setBlockProduceTime","handleToggleShowMore","useCallback","fetchBlockProduceTime","estimatedArrivalDate","useMemo","Date","estimatedSecondsLeft","isMature","daysLeft","hoursLeft","minutesLeft","secondsLeft","ckbAmount","ckbFullAmount","capacityBI","sudtAmount","sudtFullAmount","amountBI","placement","onConfirm","unlock","notification","success","window","open","okText","cancelText","UpOutlined","DownOutlined","TokenList","TokenListModal","Modal","CurrencyInputPanel","autoFocus","disableInput","onSelectedChange","selectedCurrencyBalance","setCurrencyBalance","erc20List","setErc20List","balancesList","setBalancesList","selectedCurrency","setSelectedCurrency","selectedIndex","setSelectedIndex","isModalVisible","setIsModalVisible","results","addressList","getErc20Balances","currencyBalance","disabled","visible","onOk","onCancel","footer","dataSource","renderItem","Item","handleErc20Selected","TipWrapper","truncateMiddle","str","first","last","Address","htmlFor","Group","compact","style","width","icon","CopyOutlined","Button","ConnectButton","StyledPage","PageHeader","Page","PageContent","PageMain","WithDrawalButton","ConfirmModal","RequestWithdrawal","ckbInput","setCkbInput","outputValue","setOutputValue","loading","setLoading","submitButtonDisable","setSubmitButtonDisable","selectedSudt","setSelectedSudt","to","ArrowLeftOutlined","QuestionCircleOutlined","PlusOutlined","pow","info","JSON","stringify","ResultList","Withdrawal","withdrawList","setWithdrawList","setTime","setTimeout","useClock","listWithdraw","fetchWithdrawList","App","path","element","reportWebVitals","onPerfEntry","import","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.131676e0.chunk.js","sourcesContent":["export const SCRIPTS = {\n  omni_lock: {\n    code_hash: \"0x79f90bb5e892d80dd213439eeab551120eb417678824f282b4ffb5f21bad2e1e\",\n    hash_type: \"type\",\n    tx_hash: \"0x9154df4f7336402114d04495175b37390ce86a4906d2d4001cf02c3e6d97f39c\",\n    index: \"0x0\",\n    dep_type: \"code\"\n  },\n  withdrawal_lock: {\n    \"script_type_hash\": \"0x170ef156e9f6132dbca6069dfd3e436f7d91c29d3ac7332c4b33e633b6a299b5\",\n    \"cell_dep\": {\n      \"out_point\": {\n        \"tx_hash\": \"0xb4b07dcd1571ac18683b515ada40e13b99bd0622197b6817047adc9f407f4828\",\n        \"index\": \"0x0\"\n      },\n      \"dep_type\": \"code\"\n    }\n  },\n  eth_account_lock: {\n    \"script_type_hash\": \"0xdeec13a7b8e100579541384ccaf4b5223733e4a5483c3aec95ddc4c1d5ea5b22\",\n    \"cell_dep\": {\n      \"out_point\": {\n        \"tx_hash\": \"0x2f9f8ec8a1556238aeeefed29e990d53ea75060ef04249371fd8b5246fffb8ea\",\n        \"index\": \"0x0\"\n      },\n      \"dep_type\": \"code\"\n    }\n  },\n  secp256k1_blake160: {\n    code_hash: \"0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8\",\n    hash_type: \"type\",\n    tx_hash: \"0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37\",\n    index: \"0x0\",\n    dep_type: \"dep_group\",\n    short_id: 0,\n  },\n  sudt: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      tx_hash: \"0xe12877ebd2c3c364dc46c5c992bcfaf4fee33fa13eebdf82c591fc9825aab769\",\n      index: \"0x0\",\n      dep_type: \"code\",\n  },\n}\nexport const ROLLUP_CONFIG = {\n  \"rollup_type_hash\": \"0x4cc2e6526204ae6a2e8fcf12f7ad472f41a1606d5b9624beebd215d780809f6a\",\n  \"rollup_type_script\": {\n    \"code_hash\": \"0x5c365147bb6c40e817a2a53e0dec3661f7390cc77f0c02db138303177b12e9fb\",\n    \"hash_type\": \"type\",\n    \"args\": \"0x213743d13048e9f36728c547ab736023a7426e15a3d7d1c82f43ec3b5f266df2\"\n  },\n}","export const TOKEN_LIST = [\n  {\n    symbol: \"USDC\",\n    name: \"USD Coin\",\n    decimals: 18,\n    tokenURI: \"https://cryptologos.cc/logos/usd-coin-usdc-logo.svg?v=002\",\n    sudt_script_hash: \"\",\n    address: '0xca6FcAAA5129aD9e5219397527A17c26E5AD6a6a',\n    issuerLockHash: '0x58bef38794236b315b7c23fd8132d7f42676228d659b291936e8c6c7ba9f064e',\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x58bef38794236b315b7c23fd8132d7f42676228d659b291936e8c6c7ba9f064e\"\n    }\n  },\n  {\n    symbol: \"ETH\",\n    name: \"Ethereum\",\n    decimals: 18,\n    tokenURI: \"https://cryptologos.cc/logos/ethereum-eth-logo.svg?v=002\",\n    sudt_script_hash: \"\",\n    address: '0xB1235Dd5bd72d9Ef2F0E311fC5ce7df0583B6458',\n    issuerLockHash: '0x1b072aa0ded384067106ea0c43c85bd71bafa5afdb432123511da46b390a4e33',\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x1b072aa0ded384067106ea0c43c85bd71bafa5afdb432123511da46b390a4e33\"\n    }\n  },\n  {\n    symbol: \"TAI\",\n    name: \"NexisDAO TAI\",\n    decimals: 18,\n    tokenURI: \"data:image/png;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAQDAwQDAwQEAwQFBAQFBgoHBgYGBg0JCggKDw0QEA8NDw4RExgUERIXEg4PFRwVFxkZGxsbEBQdHx0aHxgaGxr/2wBDAQQFBQYFBgwHBwwaEQ8RGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhr/wAARCAAoACgDASIAAhEBAxEB/8QAGgAAAgMBAQAAAAAAAAAAAAAAAAgEBQYBCf/EADQQAAEDAwEEBwUJAAAAAAAAAAIAAQQDBRIGBxETURUhIjJCUmIWgYKisggUFyczNEFTZ//EABkBAAMBAQEAAAAAAAAAAAAAAAMFBgIEB//EACQRAAEEAgEDBQEAAAAAAAAAAAMAAQIEERIFEyHCFCIxMoKS/9oADAMBAAIRAxEAPwB85kwIdPI/c3NZyVc68ot+TgHJmVHtFmhV0xqApFSbTj04FdiKA2+QI8Msipevy+pKXC1zGgEIWXbHe7Mfhj6js9Qh+IxHFcsti7aSUtctkKTSH1Ti5Fv35OpsW5Vo795zDk6V32y2hjZBuhbRtAdBvW4PS2RfqY5YY445Y9rHJZGbrmNNMgvG2O93gvFH09ZzEfhPHH5ks9ObbaJP52l4oIpyD7op8YcsJdNiB+v+W5IWE2cy6Q6a08cc5px6lvoMJT/3BNgOL1fX5vUhbrXR2IPv8x7KpCRyQy6muzsT71An2O2XQSa5W+JMEv76An9SvLjGePJPyH1soqS2iyCSUVNtX6ctZJBgCgWzKJGKmBRvxSKjwsezjwy7KeqBYbZaxFrbbokPHu8CgIfSkJpVvy3hv/rZN8hL0HQebsSjGP68UyCHVdHvDihS7bQevIHyB1uhJqXHWLgurB8MmjCwr6ZDCVTcT9z8ln5FurR37ubc2QhW/KVBGC5JN3ZYmOMnylqD7L9YbBQs3T4vSpaz9pOL927WPDIeFj5t/iTLx7dWkP3cG5uhCj6zPylhh2HyzIg4sr6NFCIGFP3vzQhC9JEKAIMMbYZkRf/Z\",\n    sudt_script_hash: \"\",\n    address: '0x8290f27935A2D353adc834c9F3c5F6ef19635C2D',\n    issuerLockHash: '0x13d640a864c7e84d60afd8ca9c6689d345a18f63e2e426c9623a2811776cf211',\n    l1Lock: {\n      code_hash: \"0xc5e5dcf215925f7ef4dfaf5f4b4f105bc321c02776d6e7d52a1db3fcd9d011a4\",\n      hash_type: \"type\",\n      args: \"0x13d640a864c7e84d60afd8ca9c6689d345a18f63e2e426c9623a2811776cf211\"\n    }\n  }\n]","import {\n  Hash,\n  HexNumber,\n  HexString,\n  PackedSince,\n  Script,\n} from \"@ckb-lumos/lumos\";\nimport { normalizers, Reader } from \"ckb-js-toolkit\";\n\n// Taken for now from https://github.com/xxuejie/ckb-js-toolkit/blob/68f5ff709f78eb188ee116b2887a362123b016cc/src/normalizers.js#L17-L69,\n// later we can think about exposing those functions directly.\nfunction normalizeHexNumber(length: number) {\n  return function (debugPath: string, value: any) {\n    if (!(value instanceof ArrayBuffer)) {\n      let intValue = BigInt(value).toString(16);\n      if (intValue.length % 2 !== 0) {\n        intValue = \"0\" + intValue;\n      }\n      if (intValue.length / 2 > length) {\n        throw new Error(\n          `${debugPath} is ${\n            intValue.length / 2\n          } bytes long, expected length is ${length}!`\n        );\n      }\n      const view = new DataView(new ArrayBuffer(length));\n      for (let i = 0; i < intValue.length / 2; i++) {\n        const start = intValue.length - (i + 1) * 2;\n        view.setUint8(i, parseInt(intValue.substr(start, 2), 16));\n      }\n      value = view.buffer;\n    }\n    if (value.byteLength < length) {\n      const array = new Uint8Array(length);\n      array.set(new Uint8Array(value), 0);\n      value = array.buffer;\n    }\n    return value;\n  };\n}\n\nfunction normalizeRawData(length: number) {\n  return function (debugPath: string, value: any) {\n    value = new Reader(value).toArrayBuffer();\n    if (length > 0 && value.byteLength !== length) {\n      throw new Error(\n        `${debugPath} has invalid length ${value.byteLength}, required: ${length}`\n      );\n    }\n    return value;\n  };\n}\n\nfunction normalizeObject(debugPath: string, obj: any, keys: object) {\n  const result: any = {};\n\n  for (const [key, f] of Object.entries(keys)) {\n    const value = obj[key];\n    if (value === undefined || value === null) {\n      throw new Error(`${debugPath} is missing ${key}!`);\n    }\n    result[key] = f(`${debugPath}.${key}`, value);\n  }\n  return result;\n}\n\nfunction toNormalize(normalize: Function) {\n  return function (debugPath: string, value: any) {\n    return normalize(value, {\n      debugPath,\n    });\n  };\n}\n\nexport interface DepositLockArgs {\n  owner_lock_hash: Hash;\n  layer2_lock: Script;\n  cancel_timeout: PackedSince;\n}\n\nexport function NormalizeDepositLockArgs(\n  args: object,\n  { debugPath = \"deposit_lock_args\" } = {}\n) {\n  return normalizeObject(debugPath, args, {\n    owner_lock_hash: normalizeRawData(32),\n    layer2_lock: toNormalize(normalizers.NormalizeScript),\n    cancel_timeout: normalizeHexNumber(8),\n  });\n}\n\n/**\n * sudt_id: uint32\n * amount: uint128\n */\nexport interface Fee {\n  sudt_id: HexNumber;\n  amount: HexNumber;\n}\n\nexport function NormalizeFee(fee: object, { debugPath = \"fee\" } = {}) {\n  return normalizeObject(debugPath, fee, {\n    sudt_id: normalizeHexNumber(4),\n    amount: normalizeHexNumber(16),\n  });\n}\n\nexport interface RawWithdrawalRequest {\n  nonce: HexNumber;\n  // CKB amount\n  capacity: HexNumber;\n  // SUDT amount\n  amount: HexNumber;\n  sudt_script_hash: Hash;\n  // layer2 account_script_hash\n  account_script_hash: Hash;\n  // buyer can pay sell_amount and sell_capacity to unlock\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n  fee: Fee;\n}\nexport interface WithdrawalRequest {\n  raw: RawWithdrawalRequest;\n  signature: HexString;\n}\n\nexport function NormalizeRawWithdrawalRequest(\n  raw_request: object,\n  { debugPath = \"raw_withdrawal_request\" } = {}\n) {\n  return normalizeObject(debugPath, raw_request, {\n    nonce: normalizeHexNumber(4),\n    capacity: normalizeHexNumber(8),\n    amount: normalizeHexNumber(16),\n    sudt_script_hash: normalizeRawData(32),\n    account_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    owner_lock_hash: normalizeRawData(32),\n    payment_lock_hash: normalizeRawData(32),\n    fee: toNormalize(NormalizeFee),\n  });\n}\n\nexport function NormalizeWithdrawalRequest(\n  request: WithdrawalRequest,\n  { debugPath = \"withdrawal_request\" } = {}\n) {\n  return normalizeObject(debugPath, request, {\n    raw: toNormalize(NormalizeRawWithdrawalRequest),\n    signature: normalizeRawData(65),\n  });\n}\n\nexport interface WithdrawalLockArgs {\n  // layer2 account script hash\n  account_script_hash: Hash;\n  withdrawal_block_hash: Hash;\n  withdrawal_block_number: HexNumber;\n  // buyer can pay sell_amount token to unlock\n  sudt_script_hash: Hash;\n  sell_amount: HexNumber;\n  sell_capacity: HexNumber;\n  // layer1 lock to withdraw after challenge period\n  owner_lock_hash: Hash;\n  // layer1 lock to receive the payment, must exists on the chain\n  payment_lock_hash: Hash;\n}\n\nexport function NormalizeWithdrawalLockArgs(\n  withdrawal_lock_args: WithdrawalLockArgs,\n  { debugPath = \"withdrawal_lock_args\" } = {}\n) {\n  return normalizeObject(debugPath, withdrawal_lock_args, {\n    account_script_hash: normalizeRawData(32),\n    withdrawal_block_hash: normalizeRawData(32),\n    withdrawal_block_number: normalizeHexNumber(8),\n    sudt_script_hash: normalizeRawData(32),\n    sell_amount: normalizeHexNumber(16),\n    sell_capacity: normalizeHexNumber(8),\n    owner_lock_hash: normalizeRawData(32),\n    payment_lock_hash: normalizeRawData(32),\n  });\n}\n\nexport function NormalizeUnlockWithdrawalViaFinalize(\n  unlock_withdrawal_finalize: object,\n  { debugPath = \"unlock_withdrawal_finalize\" } = {}\n) {\n  return normalizeObject(debugPath, unlock_withdrawal_finalize, {});\n}\n\nexport interface RawL2Transaction {\n  from_id: HexNumber;\n  to_id: HexNumber;\n  nonce: HexNumber;\n  args: HexString;\n}\n\nexport function NormalizeRawL2Transaction(\n  rawL2Transaction: RawL2Transaction,\n  { debugPath = \"raw_l2_transaction\" } = {}\n) {\n  return normalizeObject(debugPath, rawL2Transaction, {\n    from_id: normalizeHexNumber(4),\n    to_id: normalizeHexNumber(4),\n    nonce: normalizeHexNumber(4),\n    args: normalizeRawData(-1),\n  });\n}\n\nexport interface L2Transaction {\n  raw: RawL2Transaction;\n  signature: HexString;\n}\n\nexport function NormalizeL2Transaction(\n  l2Transaction: L2Transaction,\n  { debugPath = \"l2_transaction\" } = {}\n) {\n  return normalizeObject(debugPath, l2Transaction, {\n    raw: toNormalize(NormalizeRawL2Transaction),\n    signature: normalizeRawData(-1),\n  });\n}\n","export const PROVIDER_CONFIG = {\n  LINA: {\n    //TODO: fake urls\n    CKB_INDEXER_URL: \"https://testnet.ckb.dev/indexer\",\n    CKB_RPC_URL: \"https://testnet.ckb.dev\",\n    GW_POLYJUICE_RPC_URL:\"https://godwoken-testnet-web3-rpc.ckbapp.dev\",\n  },\n  AGGRON: {\n    CKB_INDEXER_URL: \"https://testnet.ckb.dev/indexer\",\n    CKB_RPC_URL: \"https://testnet.ckb.dev\",\n    GW_POLYJUICE_RPC_URL:\"https://godwoken-testnet-web3-rpc.ckbapp.dev\",\n  }\n}","function dataLengthError(actual, required) {\n    throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n}\n\nfunction assertDataLength(actual, required) {\n  if (actual !== required) {\n    dataLengthError(actual, required);\n  }\n}\n\nfunction assertArrayBuffer(reader) {\n  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n    reader = reader.toArrayBuffer();\n  }\n  if (!(reader instanceof ArrayBuffer)) {\n    throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n  }\n  return reader;\n}\n\nfunction verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n  if (view.byteLength < 4) {\n    dataLengthError(view.byteLength, \">4\");\n  }\n  const requiredByteLength = view.getUint32(0, true);\n  assertDataLength(view.byteLength, requiredByteLength);\n  if (requiredByteLength === 4) {\n    return [requiredByteLength];\n  }\n  if (requiredByteLength < 8) {\n    dataLengthError(view.byteLength, \">8\");\n  }\n  const firstOffset = view.getUint32(4, true);\n  if (firstOffset % 4 !== 0 || firstOffset < 8) {\n    throw new Error(`Invalid first offset: ${firstOffset}`);\n  }\n  const itemCount = firstOffset / 4 - 1;\n  if (itemCount < expectedFieldCount) {\n    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  } else if ((!compatible) && itemCount > expectedFieldCount) {\n    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  }\n  if (requiredByteLength < firstOffset) {\n    throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n  }\n  const offsets = [];\n  for (let i = 0; i < itemCount; i++) {\n    const start = 4 + i * 4;\n    offsets.push(view.getUint32(start, true));\n  }\n  offsets.push(requiredByteLength);\n  for (let i = 0; i < offsets.length - 1; i++) {\n    if (offsets[i] > offsets[i + 1]) {\n      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n    }\n  }\n  return offsets;\n}\n\nfunction serializeTable(buffers) {\n  const itemCount = buffers.length;\n  let totalSize = 4 * (itemCount + 1);\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    offsets.push(totalSize);\n    totalSize += buffers[i].byteLength;\n  }\n\n  const buffer = new ArrayBuffer(totalSize);\n  const array = new Uint8Array(buffer);\n  const view = new DataView(buffer);\n\n  view.setUint32(0, totalSize, true);\n  for (let i = 0; i < itemCount; i++) {\n    view.setUint32(4 + i * 4, offsets[i], true);\n    array.set(new Uint8Array(buffers[i]), offsets[i]);\n  }\n  return buffer;\n}\n\nexport class Uint32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Uint32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Uint32(this.view.buffer.slice(4 + i * Uint32.size(), 4 + (i + 1) * Uint32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeUint32Vec(value) {\n  const array = new Uint8Array(4 + Uint32.size() * value.length);\n  (new DataView(array.buffer)).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeUint32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Uint32.size());\n  }\n  return array.buffer;\n}\n\nexport class BlockMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class AccountMerkleState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getMerkleRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, AccountMerkleState.size());\n    this.getMerkleRoot().validate(compatible);\n    this.getCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeAccountMerkleState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class GlobalStateV0 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()), { validate: false });\n  }\n\n  getBlock() {\n    return new BlockMerkleState(this.view.buffer.slice(0 + Byte32.size() + AccountMerkleState.size(), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size()), { validate: false });\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size()), { validate: false });\n  }\n\n  getTipBlockHash() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size()), { validate: false });\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size()), { validate: false });\n  }\n\n  getStatus() {\n    return this.view.getUint8(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalStateV0.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size() + 1;\n  }\n}\n\nexport function SerializeGlobalStateV0(value) {\n  const array = new Uint8Array(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(new Uint8Array(SerializeByte32(value.reverted_block_root)), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size());\n  array.set(new Uint8Array(SerializeByte32(value.tip_block_hash)), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeUint64(value.last_finalized_block_number)), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size());\n  view.setUint8(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size(), value.status);\n  return array.buffer;\n}\n\nexport class GlobalState {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRollupConfigHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getAccount() {\n    return new AccountMerkleState(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()), { validate: false });\n  }\n\n  getBlock() {\n    return new BlockMerkleState(this.view.buffer.slice(0 + Byte32.size() + AccountMerkleState.size(), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size()), { validate: false });\n  }\n\n  getRevertedBlockRoot() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size()), { validate: false });\n  }\n\n  getTipBlockHash() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size()), { validate: false });\n  }\n\n  getTipBlockTimestamp() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size()), { validate: false });\n  }\n\n  getLastFinalizedBlockNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size(), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size() + Uint64.size()), { validate: false });\n  }\n\n  getStatus() {\n    return this.view.getUint8(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size() + Uint64.size());\n  }\n\n  getVersion() {\n    return this.view.getUint8(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size() + Uint64.size() + 1);\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, GlobalState.size());\n    this.getRollupConfigHash().validate(compatible);\n    this.getAccount().validate(compatible);\n    this.getBlock().validate(compatible);\n    this.getRevertedBlockRoot().validate(compatible);\n    this.getTipBlockHash().validate(compatible);\n    this.getTipBlockTimestamp().validate(compatible);\n    this.getLastFinalizedBlockNumber().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size() + Uint64.size() + 1 + 1;\n  }\n}\n\nexport function SerializeGlobalState(value) {\n  const array = new Uint8Array(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size() + Uint64.size() + 1 + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);\n  array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());\n  array.set(new Uint8Array(SerializeByte32(value.reverted_block_root)), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size());\n  array.set(new Uint8Array(SerializeByte32(value.tip_block_hash)), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeUint64(value.tip_block_timestamp)), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeUint64(value.last_finalized_block_number)), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size());\n  view.setUint8(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size() + Uint64.size(), value.status);\n  view.setUint8(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size() + Byte32.size() + Byte32.size() + Uint64.size() + Uint64.size() + 1, value.version);\n  return array.buffer;\n}\n\nexport class RollupConfig {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[10], offsets[11]), { validate: false }).validate();\n    if (offsets[12] - offsets[11] !== 1) {\n      throw new Error(`Invalid offset for reward_burn_rate: ${offsets[11]} - ${offsets[12]}`)\n    }\n    new Byte32Vec(this.view.buffer.slice(offsets[12], offsets[13]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[13], offsets[14]), { validate: false }).validate();\n  }\n\n  getL1SudtScriptTypeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCustodianScriptTypeHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositScriptTypeHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalScriptTypeHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeScriptTypeHash() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeScriptTypeHash() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2SudtValidatorScriptTypeHash() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBurnLockHash() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRequiredStakingCapacity() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getChallengeMaturityBlocks() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFinalityBlocks() {\n    const start = 44;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardBurnRate() {\n    const start = 48;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getAllowedEoaTypeHashes() {\n    const start = 52;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAllowedContractTypeHashes() {\n    const start = 56;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupConfig(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.l1_sudt_script_type_hash));\n  buffers.push(SerializeByte32(value.custodian_script_type_hash));\n  buffers.push(SerializeByte32(value.deposit_script_type_hash));\n  buffers.push(SerializeByte32(value.withdrawal_script_type_hash));\n  buffers.push(SerializeByte32(value.challenge_script_type_hash));\n  buffers.push(SerializeByte32(value.stake_script_type_hash));\n  buffers.push(SerializeByte32(value.l2_sudt_validator_script_type_hash));\n  buffers.push(SerializeByte32(value.burn_lock_hash));\n  buffers.push(SerializeUint64(value.required_staking_capacity));\n  buffers.push(SerializeUint64(value.challenge_maturity_blocks));\n  buffers.push(SerializeUint64(value.finality_blocks));\n  const rewardBurnRateView = new DataView(new ArrayBuffer(1));\n  rewardBurnRateView.setUint8(0, value.reward_burn_rate);\n  buffers.push(rewardBurnRateView.buffer)\n  buffers.push(SerializeByte32Vec(value.allowed_eoa_type_hashes));\n  buffers.push(SerializeByte32Vec(value.allowed_contract_type_hashes));\n  return serializeTable(buffers);\n}\n\nexport class RawL2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getFromId() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getToId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNonce() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getArgs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.from_id));\n  buffers.push(SerializeUint32(value.to_id));\n  buffers.push(SerializeUint32(value.nonce));\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class L2Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Transaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Transaction(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class L2TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new L2Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2TransactionVec(value) {\n  return serializeTable(value.map(item => SerializeL2Transaction(item)));\n}\n\nexport class SubmitTransactions {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getTxWitnessRoot() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxCount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPrevStateCheckpoint() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSubmitTransactions(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.tx_witness_root));\n  buffers.push(SerializeUint32(value.tx_count));\n  buffers.push(SerializeByte32(value.prev_state_checkpoint));\n  return serializeTable(buffers);\n}\n\nexport class SubmitWithdrawals {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getWithdrawalWitnessRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalCount() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SubmitWithdrawals.size());\n    this.getWithdrawalWitnessRoot().validate(compatible);\n    this.getWithdrawalCount().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeSubmitWithdrawals(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_witness_root)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.withdrawal_count)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class RawL2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n    new AccountMerkleState(this.view.buffer.slice(offsets[6], offsets[7]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[7], offsets[8]), { validate: false }).validate();\n    new SubmitWithdrawals(this.view.buffer.slice(offsets[8], offsets[9]), { validate: false }).validate();\n    new SubmitTransactions(this.view.buffer.slice(offsets[9], offsets[10]), { validate: false }).validate();\n  }\n\n  getNumber() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProducerId() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getParentBlockHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStakeCellOwnerLockHash() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTimestamp() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPrevAccount() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getPostAccount() {\n    const start = 28;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getStateCheckpointList() {\n    const start = 32;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitWithdrawals() {\n    const start = 36;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new SubmitWithdrawals(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSubmitTransactions() {\n    const start = 40;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SubmitTransactions(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.number));\n  buffers.push(SerializeUint32(value.block_producer_id));\n  buffers.push(SerializeByte32(value.parent_block_hash));\n  buffers.push(SerializeByte32(value.stake_cell_owner_lock_hash));\n  buffers.push(SerializeUint64(value.timestamp));\n  buffers.push(SerializeAccountMerkleState(value.prev_account));\n  buffers.push(SerializeAccountMerkleState(value.post_account));\n  buffers.push(SerializeByte32Vec(value.state_checkpoint_list));\n  buffers.push(SerializeSubmitWithdrawals(value.submit_withdrawals));\n  buffers.push(SerializeSubmitTransactions(value.submit_transactions));\n  return serializeTable(buffers);\n}\n\nexport class RawL2BlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new RawL2Block(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawL2BlockVec(value) {\n  return serializeTable(value.map(item => SerializeRawL2Block(item)));\n}\n\nexport class L2Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new L2TransactionVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new WithdrawalRequestVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawals() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new WithdrawalRequestVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeL2Block(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeL2TransactionVec(value.transactions));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeWithdrawalRequestVec(value.withdrawals));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSudtScriptHash() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScript() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeByte32(value.sudt_script_hash));\n  buffers.push(SerializeScript(value.script));\n  return serializeTable(buffers);\n}\n\nexport class DepositRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new DepositRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new DepositRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositRequestVec(value) {\n  return serializeTable(value.map(item => SerializeDepositRequest(item)));\n}\n\nexport class RawWithdrawalRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNonce() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getCapacity() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), { validate: false });\n  }\n\n  getAmount() {\n    return new Uint128(this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size()), { validate: false });\n  }\n\n  getSudtScriptHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint64.size() + Uint128.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size()), { validate: false });\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size()), { validate: false });\n  }\n\n  getSellAmount() {\n    return new Uint128(this.view.buffer.slice(0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size()), { validate: false });\n  }\n\n  getSellCapacity() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size()), { validate: false });\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size()), { validate: false });\n  }\n\n  getPaymentLockHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size() + Byte32.size()), { validate: false });\n  }\n\n  getFee() {\n    return new Fee(this.view.buffer.slice(0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size() + Byte32.size() + Fee.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawWithdrawalRequest.size());\n    this.getNonce().validate(compatible);\n    this.getCapacity().validate(compatible);\n    this.getAmount().validate(compatible);\n    this.getSudtScriptHash().validate(compatible);\n    this.getAccountScriptHash().validate(compatible);\n    this.getSellAmount().validate(compatible);\n    this.getSellCapacity().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n    this.getPaymentLockHash().validate(compatible);\n    this.getFee().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size() + Byte32.size() + Fee.size();\n  }\n}\n\nexport function SerializeRawWithdrawalRequest(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size() + Byte32.size() + Fee.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.nonce)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.capacity)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeByte32(value.sudt_script_hash)), 0 + Uint32.size() + Uint64.size() + Uint128.size());\n  array.set(new Uint8Array(SerializeByte32(value.account_script_hash)), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeUint128(value.sell_amount)), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeUint64(value.sell_capacity)), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size());\n  array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeByte32(value.payment_lock_hash)), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeFee(value.fee)), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size() + Byte32.size());\n  return array.buffer;\n}\n\nexport class WithdrawalRequestVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new WithdrawalRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequestVec(value) {\n  return serializeTable(value.map(item => SerializeWithdrawalRequest(item)));\n}\n\nexport class WithdrawalRequest {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawWithdrawalRequest(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawWithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getSignature() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWithdrawalRequest(value) {\n  const buffers = [];\n  buffers.push(SerializeRawWithdrawalRequest(value.raw));\n  buffers.push(SerializeBytes(value.signature));\n  return serializeTable(buffers);\n}\n\nexport class KVPair {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getK() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getV() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeKVPair(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.k));\n  buffers.push(SerializeByte32(value.v));\n  return serializeTable(buffers);\n}\n\nexport class KVPairVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new KVPair(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new KVPair(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeKVPairVec(value) {\n  return serializeTable(value.map(item => SerializeKVPair(item)));\n}\n\nexport class BlockInfo {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockProducerId() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), { validate: false });\n  }\n\n  getTimestamp() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint64.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockInfo.size());\n    this.getBlockProducerId().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getTimestamp().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint64.size() + Uint64.size();\n  }\n}\n\nexport function SerializeBlockInfo(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint64.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.block_producer_id)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint64.size());\n  return array.buffer;\n}\n\nexport class DepositLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getOwnerLockHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLayer2Lock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCancelTimeout() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeDepositLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.owner_lock_hash));\n  buffers.push(SerializeScript(value.layer2_lock));\n  buffers.push(SerializeUint64(value.cancel_timeout));\n  return serializeTable(buffers);\n}\n\nexport class CustodianLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new DepositLockArgs(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getDepositLockArgs() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DepositLockArgs(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockHash() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getDepositBlockNumber() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCustodianLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeDepositLockArgs(value.deposit_lock_args));\n  buffers.push(SerializeByte32(value.deposit_block_hash));\n  buffers.push(SerializeUint64(value.deposit_block_number));\n  return serializeTable(buffers);\n}\n\nexport class UnlockCustodianViaRevertWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getDepositLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockCustodianViaRevertWitness.size());\n    this.getDepositLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockCustodianViaRevertWitness(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.deposit_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class WithdrawalLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getAccountScriptHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalBlockHash() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Byte32.size()), { validate: false });\n  }\n\n  getWithdrawalBlockNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size() + Byte32.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size()), { validate: false });\n  }\n\n  getSudtScriptHash() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size() + Byte32.size() + Uint64.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size()), { validate: false });\n  }\n\n  getSellAmount() {\n    return new Uint128(this.view.buffer.slice(0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size()), { validate: false });\n  }\n\n  getSellCapacity() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size()), { validate: false });\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size()), { validate: false });\n  }\n\n  getPaymentLockHash() {\n    return new Byte32(this.view.buffer.slice(0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size() + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, WithdrawalLockArgs.size());\n    this.getAccountScriptHash().validate(compatible);\n    this.getWithdrawalBlockHash().validate(compatible);\n    this.getWithdrawalBlockNumber().validate(compatible);\n    this.getSudtScriptHash().validate(compatible);\n    this.getSellAmount().validate(compatible);\n    this.getSellCapacity().validate(compatible);\n    this.getOwnerLockHash().validate(compatible);\n    this.getPaymentLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size() + Byte32.size();\n  }\n}\n\nexport function SerializeWithdrawalLockArgs(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.account_script_hash)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.withdrawal_block_hash)), 0 + Byte32.size());\n  array.set(new Uint8Array(SerializeUint64(value.withdrawal_block_number)), 0 + Byte32.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.sudt_script_hash)), 0 + Byte32.size() + Byte32.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeUint128(value.sell_amount)), 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeUint64(value.sell_capacity)), 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size());\n  array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeByte32(value.payment_lock_hash)), 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size() + Uint128.size() + Uint64.size() + Byte32.size());\n  return array.buffer;\n}\n\nexport class UnlockWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false }).validate();\n      break;\n    case 1:\n      new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false }).validate();\n      break;\n    case 2:\n      new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false }).validate();\n      break;\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      return \"UnlockWithdrawalViaFinalize\";\n    case 1:\n      return \"UnlockWithdrawalViaRevert\";\n    case 2:\n      return \"UnlockWithdrawalViaTrade\";\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      return new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), { validate: false });\n    case 1:\n      return new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), { validate: false });\n    case 2:\n      return new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), { validate: false });\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeUnlockWithdrawalWitness(value) {\n  switch (value.type) {\n  case \"UnlockWithdrawalViaFinalize\":\n    {\n      const itemBuffer = SerializeUnlockWithdrawalViaFinalize(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n  case \"UnlockWithdrawalViaRevert\":\n    {\n      const itemBuffer = SerializeUnlockWithdrawalViaRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n  case \"UnlockWithdrawalViaTrade\":\n    {\n      const itemBuffer = SerializeUnlockWithdrawalViaTrade(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n  default:\n    throw new Error(`Invalid type: ${value.type}`);\n  }\n\n}\n\nexport class UnlockWithdrawalViaFinalize {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n\n}\n\nexport function SerializeUnlockWithdrawalViaFinalize(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class UnlockWithdrawalViaRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getCustodianLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, UnlockWithdrawalViaRevert.size());\n    this.getCustodianLockHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size();\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaRevert(value) {\n  const array = new Uint8Array(0 + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.custodian_lock_hash)), 0);\n  return array.buffer;\n}\n\nexport class UnlockWithdrawalViaTrade {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getOwnerLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUnlockWithdrawalViaTrade(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.owner_lock));\n  return serializeTable(buffers);\n}\n\nexport class StakeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOwnerLockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getStakeBlockNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, StakeLockArgs.size());\n    this.getOwnerLockHash().validate(compatible);\n    this.getStakeBlockNumber().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint64.size();\n  }\n}\n\nexport function SerializeStakeLockArgs(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint64.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0);\n  array.set(new Uint8Array(SerializeUint64(value.stake_block_number)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class MetaContractArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      new CreateAccount(this.view.buffer.slice(4), { validate: false }).validate();\n      break;\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      return \"CreateAccount\";\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      return new CreateAccount(this.view.buffer.slice(4), { validate: false });\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeMetaContractArgs(value) {\n  switch (value.type) {\n  case \"CreateAccount\":\n    {\n      const itemBuffer = SerializeCreateAccount(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n  default:\n    throw new Error(`Invalid type: ${value.type}`);\n  }\n\n}\n\nexport class Fee {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSudtId() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getAmount() {\n    return new Uint128(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint128.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Fee.size());\n    this.getSudtId().validate(compatible);\n    this.getAmount().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint128.size();\n  }\n}\n\nexport function SerializeFee(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.sudt_id)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size());\n  return array.buffer;\n}\n\nexport class CreateAccount {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Fee(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getScript() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Fee(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCreateAccount(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.script));\n  buffers.push(SerializeFee(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class SUDTArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      new SUDTQuery(this.view.buffer.slice(4), { validate: false }).validate();\n      break;\n    case 1:\n      new SUDTTransfer(this.view.buffer.slice(4), { validate: false }).validate();\n      break;\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      return \"SUDTQuery\";\n    case 1:\n      return \"SUDTTransfer\";\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      return new SUDTQuery(this.view.buffer.slice(4), { validate: false });\n    case 1:\n      return new SUDTTransfer(this.view.buffer.slice(4), { validate: false });\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeSUDTArgs(value) {\n  switch (value.type) {\n  case \"SUDTQuery\":\n    {\n      const itemBuffer = SerializeSUDTQuery(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n  case \"SUDTTransfer\":\n    {\n      const itemBuffer = SerializeSUDTTransfer(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n  default:\n    throw new Error(`Invalid type: ${value.type}`);\n  }\n\n}\n\nexport class SUDTQuery {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getShortAddress() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTQuery(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.short_address));\n  return serializeTable(buffers);\n}\n\nexport class SUDTTransfer {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Uint128(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getTo() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getAmount() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getFee() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Uint128(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeSUDTTransfer(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.to));\n  buffers.push(SerializeUint128(value.amount));\n  buffers.push(SerializeUint128(value.fee));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeTarget {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getBlockHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getTargetIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), { validate: false });\n  }\n\n  getTargetType() {\n    return this.view.getUint8(0 + Byte32.size() + Uint32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, ChallengeTarget.size());\n    this.getBlockHash().validate(compatible);\n    this.getTargetIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size() + 1;\n  }\n}\n\nexport function SerializeChallengeTarget(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.block_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.target_index)), 0 + Byte32.size());\n  view.setUint8(0 + Byte32.size() + Uint32.size(), value.target_type);\n  return array.buffer;\n}\n\nexport class ChallengeLockArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeTarget(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getTarget() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ChallengeTarget(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRewardsReceiverLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeLockArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeTarget(value.target));\n  buffers.push(SerializeScript(value.rewards_receiver_lock));\n  return serializeTable(buffers);\n}\n\nexport class ChallengeWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeChallengeWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeBytes(value.block_proof));\n  return serializeTable(buffers);\n}\n\nexport class ScriptVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScriptVec(value) {\n  return serializeTable(value.map(item => SerializeScript(item)));\n}\n\nexport class BlockHashEntry {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, BlockHashEntry.size());\n    this.getNumber().validate(compatible);\n    this.getHash().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + Byte32.size();\n  }\n}\n\nexport function SerializeBlockHashEntry(value) {\n  const array = new Uint8Array(0 + Uint64.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0);\n  array.set(new Uint8Array(SerializeByte32(value.hash)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class BlockHashEntryVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * BlockHashEntry.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new BlockHashEntry(this.view.buffer.slice(4 + i * BlockHashEntry.size(), 4 + (i + 1) * BlockHashEntry.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBlockHashEntryVec(value) {\n  const array = new Uint8Array(4 + BlockHashEntry.size() * value.length);\n  (new DataView(array.buffer)).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeBlockHashEntry(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * BlockHashEntry.size());\n  }\n  return array.buffer;\n}\n\nexport class VerifyTransactionContext {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ScriptVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new BlockHashEntryVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getAccountCount() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLoadData() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScripts() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getReturnDataHash() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashes() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BlockHashEntryVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionContext(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeBytesVec(value.load_data));\n  buffers.push(SerializeScriptVec(value.scripts));\n  buffers.push(SerializeByte32(value.return_data_hash));\n  buffers.push(SerializeBlockHashEntryVec(value.block_hashes));\n  return serializeTable(buffers);\n}\n\nexport class CKBMerkleProof {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32Vec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getIndices() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLemmas() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCKBMerkleProof(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32Vec(value.indices));\n  buffers.push(SerializeByte32Vec(value.lemmas));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new VerifyTransactionContext(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getL2Tx() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRawL2Block() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockHashesProof() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getContext() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new VerifyTransactionContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeBytes(value.block_hashes_proof));\n  buffers.push(SerializeVerifyTransactionContext(value.context));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionSignatureContext {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new ScriptVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getAccountCount() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvState() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new KVPairVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getScripts() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionSignatureContext(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.account_count));\n  buffers.push(SerializeKVPairVec(value.kv_state));\n  buffers.push(SerializeScriptVec(value.scripts));\n  return serializeTable(buffers);\n}\n\nexport class VerifyTransactionSignatureWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new L2Transaction(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new VerifyTransactionSignatureContext(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getL2Tx() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTxProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getKvStateProof() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getContext() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new VerifyTransactionSignatureContext(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyTransactionSignatureWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeL2Transaction(value.l2tx));\n  buffers.push(SerializeCKBMerkleProof(value.tx_proof));\n  buffers.push(SerializeBytes(value.kv_state_proof));\n  buffers.push(SerializeVerifyTransactionSignatureContext(value.context));\n  return serializeTable(buffers);\n}\n\nexport class VerifyWithdrawalWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new WithdrawalRequest(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new CKBMerkleProof(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getRawL2Block() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalRequest() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWithdrawalProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new CKBMerkleProof(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeVerifyWithdrawalWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2Block(value.raw_l2block));\n  buffers.push(SerializeWithdrawalRequest(value.withdrawal_request));\n  buffers.push(SerializeCKBMerkleProof(value.withdrawal_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupSubmitBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new L2Block(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getBlock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new L2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockHashes() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupSubmitBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeL2Block(value.block));\n  buffers.push(SerializeByte32Vec(value.reverted_block_hashes));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  return serializeTable(buffers);\n}\n\nexport class RollupEnterChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ChallengeWitness(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n  }\n\n  getWitness() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ChallengeWitness(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupEnterChallenge(value) {\n  const buffers = [];\n  buffers.push(SerializeChallengeWitness(value.witness));\n  return serializeTable(buffers);\n}\n\nexport class RollupCancelChallenge {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n  }\n\n}\n\nexport function SerializeRollupCancelChallenge(value) {\n  const buffers = [];\n  return serializeTable(buffers);\n}\n\nexport class RollupRevert {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawL2BlockVec(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new RawL2Block(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getRevertedBlocks() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawL2BlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getBlockProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getRevertedBlockProof() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getNewTipBlock() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new RawL2Block(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRollupRevert(value) {\n  const buffers = [];\n  buffers.push(SerializeRawL2BlockVec(value.reverted_blocks));\n  buffers.push(SerializeBytes(value.block_proof));\n  buffers.push(SerializeBytes(value.reverted_block_proof));\n  buffers.push(SerializeRawL2Block(value.new_tip_block));\n  return serializeTable(buffers);\n}\n\nexport class RollupAction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false }).validate();\n      break;\n    case 1:\n      new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n      break;\n    case 2:\n      new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false }).validate();\n      break;\n    case 3:\n      new RollupRevert(this.view.buffer.slice(4), { validate: false }).validate();\n      break;\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      return \"RollupSubmitBlock\";\n    case 1:\n      return \"RollupEnterChallenge\";\n    case 2:\n      return \"RollupCancelChallenge\";\n    case 3:\n      return \"RollupRevert\";\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n    switch (t) {\n    case 0:\n      return new RollupSubmitBlock(this.view.buffer.slice(4), { validate: false });\n    case 1:\n      return new RollupEnterChallenge(this.view.buffer.slice(4), { validate: false });\n    case 2:\n      return new RollupCancelChallenge(this.view.buffer.slice(4), { validate: false });\n    case 3:\n      return new RollupRevert(this.view.buffer.slice(4), { validate: false });\n    default:\n      throw new Error(`Invalid type: ${t}`);\n    }\n  }\n}\n\nexport function SerializeRollupAction(value) {\n  switch (value.type) {\n  case \"RollupSubmitBlock\":\n    {\n      const itemBuffer = SerializeRollupSubmitBlock(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 0, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n  case \"RollupEnterChallenge\":\n    {\n      const itemBuffer = SerializeRollupEnterChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 1, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n  case \"RollupCancelChallenge\":\n    {\n      const itemBuffer = SerializeRollupCancelChallenge(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 2, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n  case \"RollupRevert\":\n    {\n      const itemBuffer = SerializeRollupRevert(value.value);\n      const array = new Uint8Array(4 + itemBuffer.byteLength);\n      const view = new DataView(array.buffer);\n      view.setUint32(0, 3, true);\n      array.set(new Uint8Array(itemBuffer), 4);\n      return array.buffer;\n    }\n  default:\n    throw new Error(`Invalid type: ${value.type}`);\n  }\n\n}\n\nexport class Uint16 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 2);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint16() {\n    return this.view.getUint16(0, false);\n  }\n\n  toLittleEndianUint16() {\n    return this.view.getUint16(0, true);\n  }\n\n  static size() {\n    return 2;\n  }\n}\n\nexport function SerializeUint16(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 2);\n  return buffer;\n}\n\nexport class Uint32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint32() {\n    return this.view.getUint32(0, false);\n  }\n\n  toLittleEndianUint32() {\n    return this.view.getUint32(0, true);\n  }\n\n  static size() {\n    return 4;\n  }\n}\n\nexport function SerializeUint32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 4);\n  return buffer;\n}\n\nexport class Uint64 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 8);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianBigUint64() {\n    return this.view.getBigUint64(0, false);\n  }\n\n  toLittleEndianBigUint64() {\n    return this.view.getBigUint64(0, true);\n  }\n\n  static size() {\n    return 8;\n  }\n}\n\nexport function SerializeUint64(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 8);\n  return buffer;\n}\n\nexport class Uint128 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 16);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 16;\n  }\n}\n\nexport function SerializeUint128(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 16);\n  return buffer;\n}\n\nexport class Byte32 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeByte32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Uint256 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n}\n\nexport function SerializeUint256(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nexport class Bytes {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\")\n    }\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeBytes(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  (new DataView(array.buffer)).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nexport class BytesOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Bytes(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeBytesOpt(value) {\n  if (value) {\n    return SerializeBytes(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class BytesVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBytesVec(value) {\n  return serializeTable(value.map(item => SerializeBytes(item)));\n}\n\nexport class Byte32Vec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeByte32Vec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  (new DataView(array.buffer)).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n  return array.buffer;\n}\n\nexport class ScriptOpt {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Script(this.view.buffer, { validate: false });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n}\n\nexport function SerializeScriptOpt(value) {\n  if (value) {\n    return SerializeScript(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nexport class ProposalShortId {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 10);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 10;\n  }\n}\n\nexport function SerializeProposalShortId(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 10);\n  return buffer;\n}\n\nexport class UncleBlockVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new UncleBlock(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlockVec(value) {\n  return serializeTable(value.map(item => SerializeUncleBlock(item)));\n}\n\nexport class TransactionVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new Transaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransactionVec(value) {\n  return serializeTable(value.map(item => SerializeTransaction(item)));\n}\n\nexport class ProposalShortIdVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new ProposalShortId(this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeProposalShortIdVec(value) {\n  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n  (new DataView(array.buffer)).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeProposalShortId(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n  }\n  return array.buffer;\n}\n\nexport class CellDepVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellDep.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellDepVec(value) {\n  const array = new Uint8Array(4 + CellDep.size() * value.length);\n  (new DataView(array.buffer)).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellDep(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n  }\n  return array.buffer;\n}\n\nexport class CellInputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n    const requiredByteLength = this.length() * CellInput.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), { validate: false });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n}\n\nexport function SerializeCellInputVec(value) {\n  const array = new Uint8Array(4 + CellInput.size() * value.length);\n  (new DataView(array.buffer)).setUint32(0, value.length, true);\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellInput(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n  }\n  return array.buffer;\n}\n\nexport class CellOutputVec {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n    return new CellOutput(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutputVec(value) {\n  return serializeTable(value.map(item => SerializeCellOutput(item)));\n}\n\nexport class Script {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    if (offsets[2] - offsets[1] !== 1) {\n      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`)\n    }\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCodeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHashType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getArgs() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeScript(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.code_hash));\n  const hashTypeView = new DataView(new ArrayBuffer(1));\n  hashTypeView.setUint8(0, value.hash_type);\n  buffers.push(hashTypeView.buffer)\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nexport class OutPoint {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), { validate: false });\n  }\n\n  getIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, OutPoint.size());\n    this.getTxHash().validate(compatible);\n    this.getIndex().validate(compatible);\n  }\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n}\n\nexport function SerializeOutPoint(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nexport class CellInput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSince() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), { validate: false });\n  }\n\n  getPreviousOutput() {\n    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellInput.size());\n    this.getSince().validate(compatible);\n    this.getPreviousOutput().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint64.size() + OutPoint.size();\n  }\n}\n\nexport function SerializeCellInput(value) {\n  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nexport class CellOutput {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellOutput(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeScriptOpt(value.type_));\n  return serializeTable(buffers);\n}\n\nexport class CellDep {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOutPoint() {\n    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), { validate: false });\n  }\n\n  getDepType() {\n    return this.view.getUint8(0 + OutPoint.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellDep.size());\n    this.getOutPoint().validate(compatible);\n  }\n  static size() {\n    return 0 + OutPoint.size() + 1;\n  }\n}\n\nexport function SerializeCellDep(value) {\n  const array = new Uint8Array(0 + OutPoint.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n  view.setUint8(0 + OutPoint.size(), value.dep_type);\n  return array.buffer;\n}\n\nexport class RawTransaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();\n  }\n\n  getVersion() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getCellDeps() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellDepVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getHeaderDeps() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellInputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputs() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputsData() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeRawTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.version));\n  buffers.push(SerializeCellDepVec(value.cell_deps));\n  buffers.push(SerializeByte32Vec(value.header_deps));\n  buffers.push(SerializeCellInputVec(value.inputs));\n  buffers.push(SerializeCellOutputVec(value.outputs));\n  buffers.push(SerializeBytesVec(value.outputs_data));\n  return serializeTable(buffers);\n}\n\nexport class Transaction {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawTransaction(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getWitnesses() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawTransaction(value.raw));\n  buffers.push(SerializeBytesVec(value.witnesses));\n  return serializeTable(buffers);\n}\n\nexport class RawHeader {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getVersion() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), { validate: false });\n  }\n\n  getCompactTarget() {\n    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), { validate: false });\n  }\n\n  getTimestamp() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()), { validate: false });\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size()), { validate: false });\n  }\n\n  getEpoch() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size()), { validate: false });\n  }\n\n  getParentHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size()), { validate: false });\n  }\n\n  getTransactionsRoot() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size()), { validate: false });\n  }\n\n  getProposalsHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size()), { validate: false });\n  }\n\n  getExtraHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size()), { validate: false });\n  }\n\n  getDao() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawHeader.size());\n    this.getVersion().validate(compatible);\n    this.getCompactTarget().validate(compatible);\n    this.getTimestamp().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getEpoch().validate(compatible);\n    this.getParentHash().validate(compatible);\n    this.getTransactionsRoot().validate(compatible);\n    this.getProposalsHash().validate(compatible);\n    this.getExtraHash().validate(compatible);\n    this.getDao().validate(compatible);\n  }\n  static size() {\n    return 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size();\n  }\n}\n\nexport function SerializeRawHeader(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeUint64(value.epoch)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeByte32(value.parent_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeByte32(value.transactions_root)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.proposals_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.extra_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.dao)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());\n  return array.buffer;\n}\n\nexport class Header {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRaw() {\n    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), { validate: false });\n  }\n\n  getNonce() {\n    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), { validate: false });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Header.size());\n    this.getRaw().validate(compatible);\n    this.getNonce().validate(compatible);\n  }\n  static size() {\n    return 0 + RawHeader.size() + Uint128.size();\n  }\n}\n\nexport function SerializeHeader(value) {\n  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n  return array.buffer;\n}\n\nexport class UncleBlock {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeUncleBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class Block {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nexport class BlockV1 {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getExtension() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeBlockV1(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  buffers.push(SerializeBytes(value.extension));\n  return serializeTable(buffers);\n}\n\nexport class CellbaseWitness {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getMessage() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeCellbaseWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeBytes(value.message));\n  return serializeTable(buffers);\n}\n\nexport class WitnessArgs {\n  constructor(reader, { validate = true } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), { validate: false }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), { validate: false }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getInputType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n\n  getOutputType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), { validate: false });\n  }\n}\n\nexport function SerializeWitnessArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.lock));\n  buffers.push(SerializeBytesOpt(value.input_type));\n  buffers.push(SerializeBytesOpt(value.output_type));\n  return serializeTable(buffers);\n}\n\n","import { RPC, Reader } from \"ckb-js-toolkit\";\nimport { Hash, HexNumber, HexString } from \"@ckb-lumos/lumos\";\nimport { NormalizeWithdrawalRequest, WithdrawalRequest } from \"./normalizer\";\nimport { SerializeWithdrawalRequest } from \"../schemas/index.esm\";\n\n/**\n * Godwoken RPC client\n */\nexport class GodwokenClient {\n  private rpc: RPC;\n\n  constructor(url: string) {\n    this.rpc = new RPC(url);\n  }\n\n  private async rpcCall(method_name: string, ...args: any[]): Promise<any> {\n    const name = \"gw_\" + method_name;\n    const result = await this.rpc[name](...args);\n    return result;\n  }\n\n  /**\n   * Serialize withdrawal request and submit to godwoken\n   *\n   * @param request\n   * @returns\n   */\n  async submitWithdrawalRequest(request: WithdrawalRequest): Promise<void> {\n    const data = new Reader(\n      SerializeWithdrawalRequest(NormalizeWithdrawalRequest(request))\n    ).serializeJson();\n    return await this.rpcCall(\"submit_withdrawal_request\", data);\n  }\n\n  /**\n   *\n   * @param scriptHash layer2 lock script hash\n   * @returns uint32\n   */\n  async getAccountIdByScriptHash(\n    scriptHash: Hash\n  ): Promise<HexNumber | undefined> {\n    const id = await this.rpcCall(\"get_account_id_by_script_hash\", scriptHash);\n    return id;\n  }\n\n  /**\n   *\n   * @param shortAddress scriptHash160 (scriptHash first 20 bytes)\n   * @returns uint32\n   */\n  async getScriptHashByShortAddress(\n    shortAddress: HexString\n  ): Promise<Hash | undefined> {\n    const scriptHash = await this.rpcCall(\n      \"get_script_hash_by_short_address\",\n      shortAddress\n    );\n    return scriptHash;\n  }\n  /**\n   *\n   * @param txHash Hash \n   * @returns uint32\n   */\n  async getWithdrawal(\n    txHash: Hash\n  ): Promise<Hash | undefined> {\n    const withdrawal = await this.rpcCall(\n      \"get_withdrawal\",\n      txHash\n    );\n    return withdrawal;\n  }\n  /**\n   *\n   * @param accountId uint32 in hex number\n   * @returns uint32 in hex number\n   */\n  async getNonce(accountId: HexNumber): Promise<HexNumber> {\n    const nonce = await this.rpcCall(\"get_nonce\", accountId);\n    return nonce;\n  }\n\n  /**\n   *\n   * @param accountId uint32 in hex number\n   * @returns\n   */\n  async getScriptHash(accountId: HexNumber): Promise<Hash> {\n    return await this.rpcCall(\"get_script_hash\", accountId);\n  }\n}\n","\"use strict\";\n\n// Object.defineProperty(\n//   value: true\n// });\n\nfunction dataLengthError(actual, required) {\n  throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);\n}\n\nfunction assertDataLength(actual, required) {\n  if (actual !== required) {\n    dataLengthError(actual, required);\n  }\n}\n\nfunction assertArrayBuffer(reader) {\n  if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {\n    reader = reader.toArrayBuffer();\n  }\n\n  if (!(reader instanceof ArrayBuffer)) {\n    throw new Error(\"Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!\");\n  }\n\n  return reader;\n}\n\nfunction verifyAndExtractOffsets(view, expectedFieldCount, compatible) {\n  if (view.byteLength < 4) {\n    dataLengthError(view.byteLength, \">4\");\n  }\n\n  const requiredByteLength = view.getUint32(0, true);\n  assertDataLength(view.byteLength, requiredByteLength);\n\n  if (requiredByteLength === 4) {\n    return [requiredByteLength];\n  }\n\n  if (requiredByteLength < 8) {\n    dataLengthError(view.byteLength, \">8\");\n  }\n\n  const firstOffset = view.getUint32(4, true);\n\n  if (firstOffset % 4 !== 0 || firstOffset < 8) {\n    throw new Error(`Invalid first offset: ${firstOffset}`);\n  }\n\n  const itemCount = firstOffset / 4 - 1;\n\n  if (itemCount < expectedFieldCount) {\n    throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  } else if (!compatible && itemCount > expectedFieldCount) {\n    throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);\n  }\n\n  if (requiredByteLength < firstOffset) {\n    throw new Error(`First offset is larger than byte length: ${firstOffset}`);\n  }\n\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    const start = 4 + i * 4;\n    offsets.push(view.getUint32(start, true));\n  }\n\n  offsets.push(requiredByteLength);\n\n  for (let i = 0; i < offsets.length - 1; i++) {\n    if (offsets[i] > offsets[i + 1]) {\n      throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);\n    }\n  }\n\n  return offsets;\n}\n\nfunction serializeTable(buffers) {\n  const itemCount = buffers.length;\n  let totalSize = 4 * (itemCount + 1);\n  const offsets = [];\n\n  for (let i = 0; i < itemCount; i++) {\n    offsets.push(totalSize);\n    totalSize += buffers[i].byteLength;\n  }\n\n  const buffer = new ArrayBuffer(totalSize);\n  const array = new Uint8Array(buffer);\n  const view = new DataView(buffer);\n  view.setUint32(0, totalSize, true);\n\n  for (let i = 0; i < itemCount; i++) {\n    view.setUint32(4 + i * 4, offsets[i], true);\n    array.set(new Uint8Array(buffers[i]), offsets[i]);\n  }\n\n  return buffer;\n}\n\nclass Identity {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 21);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 21;\n  }\n\n}\n\n\n\nfunction SerializeIdentity(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 21);\n  return buffer;\n}\n\nclass RcIdentity {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Identity(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new SmtProofEntryVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n  }\n\n  getIdentity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Identity(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getProofs() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProofEntryVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeRcIdentity(value) {\n  const buffers = [];\n  buffers.push(SerializeIdentity(value.identity));\n  buffers.push(SerializeSmtProofEntryVec(value.proofs));\n  return serializeTable(buffers);\n}\n\nclass RcIdentityOpt {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new RcIdentity(this.view.buffer, {\n      validate: false\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n\n}\n\n\n\nfunction SerializeRcIdentityOpt(value) {\n  if (value) {\n    return SerializeRcIdentity(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass RcLockWitnessLock {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new RcIdentityOpt(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false\n    }).validate();\n  }\n\n  getSignature() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getRcIdentity() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RcIdentityOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getPreimage() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n}\n\n\nexport function SerializeRcLockWitnessLock(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.signature));\n  buffers.push(SerializeRcIdentityOpt(value.rc_identity));\n  buffers.push(SerializeBytesOpt(value.preimage));\n  return serializeTable(buffers);\n}\n\nclass ScriptVec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeScriptVec(value) {\n  return serializeTable(value.map(item => SerializeScript(item)));\n}\n\nclass ScriptVecOpt {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new ScriptVec(this.view.buffer, {\n      validate: false\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n\n}\n\n\n\nfunction SerializeScriptVecOpt(value) {\n  if (value) {\n    return SerializeScriptVec(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass XudtWitnessInput {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new ScriptVecOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n  }\n\n  getRawExtensionData() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new ScriptVecOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getExtensionData() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeXudtWitnessInput(value) {\n  const buffers = [];\n  buffers.push(SerializeScriptVecOpt(value.raw_extension_data));\n  buffers.push(SerializeBytesVec(value.extension_data));\n  return serializeTable(buffers);\n}\n\nclass RCRule {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSmtRoot() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false\n    });\n  }\n\n  getFlags() {\n    return this.view.getUint8(0 + Byte32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RCRule.size());\n    this.getSmtRoot().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + 1;\n  }\n\n}\n\n\n\nfunction SerializeRCRule(value) {\n  const array = new Uint8Array(0 + Byte32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.smt_root)), 0);\n  view.setUint8(0 + Byte32.size(), value.flags);\n  return array.buffer;\n}\n\nclass RCCellVec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {\n      validate: false\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n\n}\n\n\n\nfunction SerializeRCCellVec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n\n  return array.buffer;\n}\n\nclass RCData {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      assertDataLength(this.view.byteLength, \">4\");\n    }\n\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        new RCRule(this.view.buffer.slice(4), {\n          validate: false\n        }).validate();\n        break;\n\n      case 1:\n        new RCCellVec(this.view.buffer.slice(4), {\n          validate: false\n        }).validate();\n        break;\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  unionType() {\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        return \"RCRule\";\n\n      case 1:\n        return \"RCCellVec\";\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n  value() {\n    const t = this.view.getUint32(0, true);\n\n    switch (t) {\n      case 0:\n        return new RCRule(this.view.buffer.slice(4), {\n          validate: false\n        });\n\n      case 1:\n        return new RCCellVec(this.view.buffer.slice(4), {\n          validate: false\n        });\n\n      default:\n        throw new Error(`Invalid type: ${t}`);\n    }\n  }\n\n}\n\nfunction SerializeRCData(value) {\n  switch (value.type) {\n    case \"RCRule\":\n      {\n        const itemBuffer = SerializeRCRule(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 0, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n\n    case \"RCCellVec\":\n      {\n        const itemBuffer = SerializeRCCellVec(value.value);\n        const array = new Uint8Array(4 + itemBuffer.byteLength);\n        const view = new DataView(array.buffer);\n        view.setUint32(0, 1, true);\n        array.set(new Uint8Array(itemBuffer), 4);\n        return array.buffer;\n      }\n\n    default:\n      throw new Error(`Invalid type: ${value.type}`);\n  }\n}\n\nclass SmtProof {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n\n}\n\n\nfunction SerializeSmtProof(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nclass SmtProofEntry {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    if (offsets[1] - offsets[0] !== 1) {\n      throw new Error(`Invalid offset for mask: ${offsets[0]} - ${offsets[1]}`);\n    }\n\n    new SmtProof(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n  }\n\n  getMask() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProof(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\nfunction SerializeSmtProofEntry(value) {\n  const buffers = [];\n  const maskView = new DataView(new ArrayBuffer(1));\n  maskView.setUint8(0, value.mask);\n  buffers.push(maskView.buffer);\n  buffers.push(SerializeSmtProof(value.proof));\n  return serializeTable(buffers);\n}\n\nclass SmtProofEntryVec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new SmtProofEntry(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new SmtProofEntry(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeSmtProofEntryVec(value) {\n  return serializeTable(value.map(item => SerializeSmtProofEntry(item)));\n}\n\nclass SmtUpdateItem {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getKey() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false\n    });\n  }\n\n  getPackedValues() {\n    return this.view.getUint8(0 + Byte32.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, SmtUpdateItem.size());\n    this.getKey().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + 1;\n  }\n\n}\n\n\n\nfunction SerializeSmtUpdateItem(value) {\n  const array = new Uint8Array(0 + Byte32.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.key)), 0);\n  view.setUint8(0 + Byte32.size(), value.packed_values);\n  return array.buffer;\n}\n\nclass SmtUpdateItemVec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * SmtUpdateItem.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new SmtUpdateItem(this.view.buffer.slice(4 + i * SmtUpdateItem.size(), 4 + (i + 1) * SmtUpdateItem.size()), {\n      validate: false\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n\n}\n\n\n\nfunction SerializeSmtUpdateItemVec(value) {\n  const array = new Uint8Array(4 + SmtUpdateItem.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeSmtUpdateItem(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * SmtUpdateItem.size());\n  }\n\n  return array.buffer;\n}\n\nclass SmtUpdateAction {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new SmtUpdateItemVec(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new SmtProof(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n  }\n\n  getUpdates() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new SmtUpdateItemVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getProof() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new SmtProof(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeSmtUpdateAction(value) {\n  const buffers = [];\n  buffers.push(SerializeSmtUpdateItemVec(value.updates));\n  buffers.push(SerializeSmtProof(value.proof));\n  return serializeTable(buffers);\n}\n\nclass XudtData {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getData() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeXudtData(value) {\n  const buffers = [];\n  buffers.push(SerializeBytes(value.lock));\n  buffers.push(SerializeBytesVec(value.data));\n  return serializeTable(buffers);\n}\n\nclass Uint32 {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  toBigEndianUint32() {\n    return this.view.getUint32(0, false);\n  }\n\n  toLittleEndianUint32() {\n    return this.view.getUint32(0, true);\n  }\n\n  static size() {\n    return 4;\n  }\n\n}\n\n\n\nfunction SerializeUint32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 4);\n  return buffer;\n}\n\nclass Uint64 {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 8);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 8;\n  }\n\n}\n\n\n\nfunction SerializeUint64(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 8);\n  return buffer;\n}\n\nclass Uint128 {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 16);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 16;\n  }\n\n}\n\n\n\nfunction SerializeUint128(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 16);\n  return buffer;\n}\n\nclass Byte32 {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n\n}\n\n\n\nfunction SerializeByte32(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nclass Uint256 {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 32);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 32;\n  }\n\n}\n\n\n\nfunction SerializeUint256(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 32);\n  return buffer;\n}\n\nclass Bytes {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n  }\n\n  raw() {\n    return this.view.buffer.slice(4);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(4 + i);\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n\n}\n\n\n\nfunction SerializeBytes(value) {\n  const item = assertArrayBuffer(value);\n  const array = new Uint8Array(4 + item.byteLength);\n  new DataView(array.buffer).setUint32(0, item.byteLength, true);\n  array.set(new Uint8Array(item), 4);\n  return array.buffer;\n}\n\nclass BytesOpt {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Bytes(this.view.buffer, {\n      validate: false\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n\n}\n\n\n\nfunction SerializeBytesOpt(value) {\n  if (value) {\n    return SerializeBytes(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass BytesVec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeBytesVec(value) {\n  return serializeTable(value.map(item => SerializeBytes(item)));\n}\n\nclass Byte32Vec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * Byte32.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), {\n      validate: false\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n\n}\n\n\n\nfunction SerializeByte32Vec(value) {\n  const array = new Uint8Array(4 + Byte32.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeByte32(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());\n  }\n\n  return array.buffer;\n}\n\nclass ScriptOpt {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.hasValue()) {\n      this.value().validate(compatible);\n    }\n  }\n\n  value() {\n    return new Script(this.view.buffer, {\n      validate: false\n    });\n  }\n\n  hasValue() {\n    return this.view.byteLength > 0;\n  }\n\n}\n\n\n\nfunction SerializeScriptOpt(value) {\n  if (value) {\n    return SerializeScript(value);\n  } else {\n    return new ArrayBuffer(0);\n  }\n}\n\nclass ProposalShortId {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, 10);\n  }\n\n  indexAt(i) {\n    return this.view.getUint8(i);\n  }\n\n  raw() {\n    return this.view.buffer;\n  }\n\n  static size() {\n    return 10;\n  }\n\n}\n\n\n\nfunction SerializeProposalShortId(value) {\n  const buffer = assertArrayBuffer(value);\n  assertDataLength(buffer.byteLength, 10);\n  return buffer;\n}\n\nclass UncleBlockVec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new UncleBlock(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeUncleBlockVec(value) {\n  return serializeTable(value.map(item => SerializeUncleBlock(item)));\n}\n\nclass TransactionVec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new Transaction(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeTransactionVec(value) {\n  return serializeTable(value.map(item => SerializeTransaction(item)));\n}\n\nclass ProposalShortIdVec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * ProposalShortId.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new ProposalShortId(this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()), {\n      validate: false\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n\n}\n\n\n\nfunction SerializeProposalShortIdVec(value) {\n  const array = new Uint8Array(4 + ProposalShortId.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeProposalShortId(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellDepVec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * CellDep.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), {\n      validate: false\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n\n}\n\n\n\nfunction SerializeCellDepVec(value) {\n  const array = new Uint8Array(4 + CellDep.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellDep(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellInputVec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    if (this.view.byteLength < 4) {\n      dataLengthError(this.view.byteLength, \">4\");\n    }\n\n    const requiredByteLength = this.length() * CellInput.size() + 4;\n    assertDataLength(this.view.byteLength, requiredByteLength);\n\n    for (let i = 0; i < 0; i++) {\n      const item = this.indexAt(i);\n      item.validate(compatible);\n    }\n  }\n\n  indexAt(i) {\n    return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), {\n      validate: false\n    });\n  }\n\n  length() {\n    return this.view.getUint32(0, true);\n  }\n\n}\n\n\n\nfunction SerializeCellInputVec(value) {\n  const array = new Uint8Array(4 + CellInput.size() * value.length);\n  new DataView(array.buffer).setUint32(0, value.length, true);\n\n  for (let i = 0; i < value.length; i++) {\n    const itemBuffer = SerializeCellInput(value[i]);\n    array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());\n  }\n\n  return array.buffer;\n}\n\nclass CellOutputVec {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n\n    for (let i = 0; i < offsets.length - 1; i++) {\n      new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), {\n        validate: false\n      }).validate();\n    }\n  }\n\n  length() {\n    if (this.view.byteLength < 8) {\n      return 0;\n    } else {\n      return this.view.getUint32(4, true) / 4 - 1;\n    }\n  }\n\n  indexAt(i) {\n    const start = 4 + i * 4;\n    const offset = this.view.getUint32(start, true);\n    let offset_end = this.view.byteLength;\n\n    if (i + 1 < this.length()) {\n      offset_end = this.view.getUint32(start + 4, true);\n    }\n\n    return new CellOutput(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeCellOutputVec(value) {\n  return serializeTable(value.map(item => SerializeCellOutput(item)));\n}\n\nclass Script {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n\n    if (offsets[2] - offsets[1] !== 1) {\n      throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);\n    }\n\n    new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false\n    }).validate();\n  }\n\n  getCodeHash() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getHashType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);\n  }\n\n  getArgs() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeScript(value) {\n  const buffers = [];\n  buffers.push(SerializeByte32(value.code_hash));\n  const hashTypeView = new DataView(new ArrayBuffer(1));\n  hashTypeView.setUint8(0, value.hash_type);\n  buffers.push(hashTypeView.buffer);\n  buffers.push(SerializeBytes(value.args));\n  return serializeTable(buffers);\n}\n\nclass OutPoint {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getTxHash() {\n    return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {\n      validate: false\n    });\n  }\n\n  getIndex() {\n    return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), {\n      validate: false\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, OutPoint.size());\n    this.getTxHash().validate(compatible);\n    this.getIndex().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Byte32.size() + Uint32.size();\n  }\n\n}\n\n\n\nfunction SerializeOutPoint(value) {\n  const array = new Uint8Array(0 + Byte32.size() + Uint32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());\n  return array.buffer;\n}\n\nclass CellInput {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getSince() {\n    return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), {\n      validate: false\n    });\n  }\n\n  getPreviousOutput() {\n    return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), {\n      validate: false\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellInput.size());\n    this.getSince().validate(compatible);\n    this.getPreviousOutput().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Uint64.size() + OutPoint.size();\n  }\n\n}\n\n\n\nfunction SerializeCellInput(value) {\n  const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint64(value.since)), 0);\n  array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());\n  return array.buffer;\n}\n\nclass CellOutput {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new Script(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n    new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false\n    }).validate();\n  }\n\n  getCapacity() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint64(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getLock() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ScriptOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeCellOutput(value) {\n  const buffers = [];\n  buffers.push(SerializeUint64(value.capacity));\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeScriptOpt(value.type_));\n  return serializeTable(buffers);\n}\n\nclass CellDep {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getOutPoint() {\n    return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), {\n      validate: false\n    });\n  }\n\n  getDepType() {\n    return this.view.getUint8(0 + OutPoint.size());\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, CellDep.size());\n    this.getOutPoint().validate(compatible);\n  }\n\n  static size() {\n    return 0 + OutPoint.size() + 1;\n  }\n\n}\n\n\n\nfunction SerializeCellDep(value) {\n  const array = new Uint8Array(0 + OutPoint.size() + 1);\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);\n  view.setUint8(0 + OutPoint.size(), value.dep_type);\n  return array.buffer;\n}\n\nclass RawTransaction {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n    new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false\n    }).validate();\n    new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), {\n      validate: false\n    }).validate();\n    new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), {\n      validate: false\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), {\n      validate: false\n    }).validate();\n  }\n\n  getVersion() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Uint32(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getCellDeps() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellDepVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getHeaderDeps() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Byte32Vec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getInputs() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellInputVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getOutputs() {\n    const start = 20;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new CellOutputVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getOutputsData() {\n    const start = 24;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeRawTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeUint32(value.version));\n  buffers.push(SerializeCellDepVec(value.cell_deps));\n  buffers.push(SerializeByte32Vec(value.header_deps));\n  buffers.push(SerializeCellInputVec(value.inputs));\n  buffers.push(SerializeCellOutputVec(value.outputs));\n  buffers.push(SerializeBytesVec(value.outputs_data));\n  return serializeTable(buffers);\n}\n\nclass Transaction {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n  }\n\n  getRaw() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new RawTransaction(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getWitnesses() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeTransaction(value) {\n  const buffers = [];\n  buffers.push(SerializeRawTransaction(value.raw));\n  buffers.push(SerializeBytesVec(value.witnesses));\n  return serializeTable(buffers);\n}\n\nclass RawHeader {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getVersion() {\n    return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), {\n      validate: false\n    });\n  }\n\n  getCompactTarget() {\n    return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), {\n      validate: false\n    });\n  }\n\n  getTimestamp() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()), {\n      validate: false\n    });\n  }\n\n  getNumber() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size()), {\n      validate: false\n    });\n  }\n\n  getEpoch() {\n    return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size()), {\n      validate: false\n    });\n  }\n\n  getParentHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size()), {\n      validate: false\n    });\n  }\n\n  getTransactionsRoot() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size()), {\n      validate: false\n    });\n  }\n\n  getProposalsHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size()), {\n      validate: false\n    });\n  }\n\n  getUnclesHash() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size()), {\n      validate: false\n    });\n  }\n\n  getDao() {\n    return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size()), {\n      validate: false\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, RawHeader.size());\n    this.getVersion().validate(compatible);\n    this.getCompactTarget().validate(compatible);\n    this.getTimestamp().validate(compatible);\n    this.getNumber().validate(compatible);\n    this.getEpoch().validate(compatible);\n    this.getParentHash().validate(compatible);\n    this.getTransactionsRoot().validate(compatible);\n    this.getProposalsHash().validate(compatible);\n    this.getUnclesHash().validate(compatible);\n    this.getDao().validate(compatible);\n  }\n\n  static size() {\n    return 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size();\n  }\n\n}\n\n\n\nfunction SerializeRawHeader(value) {\n  const array = new Uint8Array(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeUint32(value.version)), 0);\n  array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());\n  array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeUint64(value.epoch)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeByte32(value.parent_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size());\n  array.set(new Uint8Array(SerializeByte32(value.transactions_root)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.proposals_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.uncles_hash)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size());\n  array.set(new Uint8Array(SerializeByte32(value.dao)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size() + Uint64.size() + Byte32.size() + Byte32.size() + Byte32.size() + Byte32.size());\n  return array.buffer;\n}\n\nclass Header {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  getRaw() {\n    return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), {\n      validate: false\n    });\n  }\n\n  getNonce() {\n    return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), {\n      validate: false\n    });\n  }\n\n  validate(compatible = false) {\n    assertDataLength(this.view.byteLength, Header.size());\n    this.getRaw().validate(compatible);\n    this.getNonce().validate(compatible);\n  }\n\n  static size() {\n    return 0 + RawHeader.size() + Uint128.size();\n  }\n\n}\n\n\n\nfunction SerializeHeader(value) {\n  const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());\n  const view = new DataView(array.buffer);\n  array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);\n  array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());\n  return array.buffer;\n}\n\nclass UncleBlock {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getProposals() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeUncleBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nclass Block {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Header(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n    new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false\n    }).validate();\n    new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), {\n      validate: false\n    }).validate();\n  }\n\n  getHeader() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Header(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getUncles() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getTransactions() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new TransactionVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getProposals() {\n    const start = 16;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeBlock(value) {\n  const buffers = [];\n  buffers.push(SerializeHeader(value.header));\n  buffers.push(SerializeUncleBlockVec(value.uncles));\n  buffers.push(SerializeTransactionVec(value.transactions));\n  buffers.push(SerializeProposalShortIdVec(value.proposals));\n  return serializeTable(buffers);\n}\n\nclass CellbaseWitness {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new Script(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new Script(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getMessage() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new Bytes(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeCellbaseWitness(value) {\n  const buffers = [];\n  buffers.push(SerializeScript(value.lock));\n  buffers.push(SerializeBytes(value.message));\n  return serializeTable(buffers);\n}\n\nclass WitnessArgs {\n  constructor(reader, {\n    validate = true\n  } = {}) {\n    this.view = new DataView(assertArrayBuffer(reader));\n\n    if (validate) {\n      this.validate();\n    }\n  }\n\n  validate(compatible = false) {\n    const offsets = verifyAndExtractOffsets(this.view, 0, true);\n    new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {\n      validate: false\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), {\n      validate: false\n    }).validate();\n    new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {\n      validate: false\n    }).validate();\n  }\n\n  getLock() {\n    const start = 4;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getInputType() {\n    const start = 8;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.getUint32(start + 4, true);\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n  getOutputType() {\n    const start = 12;\n    const offset = this.view.getUint32(start, true);\n    const offset_end = this.view.byteLength;\n    return new BytesOpt(this.view.buffer.slice(offset, offset_end), {\n      validate: false\n    });\n  }\n\n}\n\n\n\nfunction SerializeWitnessArgs(value) {\n  const buffers = [];\n  buffers.push(SerializeBytesOpt(value.lock));\n  buffers.push(SerializeBytesOpt(value.input_type));\n  buffers.push(SerializeBytesOpt(value.output_type));\n  return serializeTable(buffers);\n}\n","import { SCRIPTS } from './constants/index';\nimport { Address, Indexer, RPC, config, helpers, Transaction, HexString, utils, core, toolkit, Hash, Cell, HashType, Script } from \"@ckb-lumos/lumos\"\nimport { core as godwokenCore } from '@polyjuice-provider/godwoken';\nimport { ROLLUP_CONFIG } from \"./constants\"\nimport { PROVIDER_CONFIG } from './constants/providerConfig'\nimport { PolyjuiceHttpProvider } from \"@polyjuice-provider/web3\";\nimport { SUDT_ERC20_PROXY_ABI } from './constants/sudtErc20ProxyAbi'\nimport { AbiItems, PolyjuiceConfig } from \"@polyjuice-provider/base\"\nimport { GodwokenClient } from './godwoken/godwoken'\nimport Web3 from \"web3\";   \nimport { LightGodwokenProvider } from './lightGodwokenType'\nimport { WithdrawalRequest } from './godwoken/normalizer';\nimport { SerializeRcLockWitnessLock } from './omni-lock/index';\n\nexport const POLYJUICE_CONFIG = {\n  web3Url: PROVIDER_CONFIG.LINA.GW_POLYJUICE_RPC_URL,\n  abiItems: SUDT_ERC20_PROXY_ABI as AbiItems,\n};\n\nexport const polyjuiceProvider = new PolyjuiceHttpProvider(\n  POLYJUICE_CONFIG.web3Url,\n  POLYJUICE_CONFIG as PolyjuiceConfig\n);\n\nexport default class DefaultLightGodwokenProvider implements LightGodwokenProvider {\n  l2Address: Address = \"\"\n  l1Address: Address = \"\"\n  ckbIndexer\n  rpc\n  ethereum\n  web3\n  godwokenClient\n\n  constructor(ethAddress: Address, ethereum: any, env = 'AGGRON') {\n    if (env === 'AGGRON') {\n      config.initializeConfig(config.predefined.AGGRON4)\n      this.ckbIndexer = new Indexer(PROVIDER_CONFIG.AGGRON.CKB_INDEXER_URL, PROVIDER_CONFIG.AGGRON.CKB_RPC_URL)\n      this.rpc = new RPC(PROVIDER_CONFIG.AGGRON.CKB_RPC_URL)\n      this.godwokenClient = new GodwokenClient(PROVIDER_CONFIG.LINA.GW_POLYJUICE_RPC_URL);\n\n    } else if (env === 'LINA') {\n      config.initializeConfig(config.predefined.LINA)\n      this.ckbIndexer = new Indexer(PROVIDER_CONFIG.LINA.CKB_INDEXER_URL, PROVIDER_CONFIG.LINA.CKB_RPC_URL)\n      this.rpc = new RPC(PROVIDER_CONFIG.LINA.CKB_RPC_URL)\n      this.godwokenClient = new GodwokenClient(PROVIDER_CONFIG.LINA.GW_POLYJUICE_RPC_URL);\n    } else {\n      throw new Error(\"env not defined, please use AGGRON or LINA.\")\n    }\n    this.ethereum = ethereum\n    this.l2Address = ethAddress;\n    this.l1Address = this.generateL1Address(this.l2Address);\n    ethereum.on('accountsChanged',  (accounts: any) => {\n      console.log(\"eth accounts changed\", accounts);\n      this.l2Address = accounts[0];\n      this.l1Address = this.generateL1Address(this.l2Address);\n    });\n    \n    this.web3 = new Web3(polyjuiceProvider);\n  }\n\n  async sendWithdrawTransaction(withdrawalRequest: WithdrawalRequest): Promise<string>{\n    const result = await this.godwokenClient.submitWithdrawalRequest(withdrawalRequest);\n    return result as unknown as string;\n  }\n\n  getL2Address(): string {\n    return this.l2Address;\n  }\n  getL1Address(): string {\n    return this.l1Address;\n  }\n\n  static async CreateProvider(ethereum: any): Promise<LightGodwokenProvider> {\n    if(!ethereum || !ethereum.isMetaMask) {\n      throw new Error(\"please provide metamask ethereum object\");\n    }\n    return ethereum\n    .request({ method: 'eth_requestAccounts' })\n    .then((accounts: any) => {\n      console.log(\"eth_requestAccounts\", accounts);\n      return new DefaultLightGodwokenProvider(accounts[0], ethereum);\n    })\n    .catch((error: any) => {\n      if (error.code === 4001) {\n        // EIP-1193 userRejectedRequest error\n        console.log('Please connect to MetaMask.');\n      } else {\n        console.error(error);\n      }\n    });\n  }\n\n  generateL1Address(l2Address: Address): Address {\n    const omniLock: Script = {\n      code_hash: SCRIPTS.omni_lock.code_hash,\n      hash_type: SCRIPTS.omni_lock.hash_type as HashType,\n      // omni flag       pubkey hash   omni lock flags\n      // chain identity   eth addr      function flag()\n      // 00: Nervos       👇            00: owner\n      // 01: Ethereum     👇            01: administrator\n      //      👇          👇            👇\n      args: `0x01${l2Address.substring(2)}00`,\n    };\n    return helpers.generateAddress(omniLock);\n  }\n\n  // // TODO the unknown is godwoken submit_withdrawal_tx\n  // sendWithdrawTransaction: (tx: unknown) => Promise<Hash>;\n\n  // // now only supported omni lock, the other lock type will be supported later\n  async sendL1Transaction(tx: Transaction): Promise<Hash> {\n    return await this.rpc.send_transaction(tx, \"passthrough\");\n  }\n\n  async signL1Transaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Transaction> {\n    const message = this.generateMessage(txSkeleton);\n    let signedMessage = await this.ethereum.request({\n      method: \"personal_sign\",\n      params: [this.ethereum.selectedAddress, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    const signedWitness = new toolkit.Reader(\n      core.SerializeWitnessArgs({\n        lock: SerializeRcLockWitnessLock({\n          signature: new toolkit.Reader(signedMessage),\n        }),\n      })\n    ).serializeJson();\n    txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) => witnesses.push(`${signedWitness}`));\n    const signedTx = helpers.createTransactionFromSkeleton(txSkeleton);\n    return signedTx;\n  }\n\n  generateMessage(tx: helpers.TransactionSkeletonType): HexString {\n    const hasher = new utils.CKBHasher();\n    const rawTxHash = utils.ckbHash(\n      core.SerializeRawTransaction(\n        toolkit.normalizers.NormalizeRawTransaction(helpers.createTransactionFromSkeleton(tx))\n      )\n    );\n    const serializedWitness = core.SerializeWitnessArgs({\n      lock: new toolkit.Reader(\n        \"0x\" +\n          \"00\".repeat(\n            SerializeRcLockWitnessLock({\n              signature: new toolkit.Reader(\"0x\" + \"00\".repeat(65)),\n            }).byteLength\n          )\n      ),\n    });\n    hasher.update(rawTxHash);\n    this.hashWitness(hasher, serializedWitness);\n    return hasher.digestHex();\n  }\n\n  hashWitness(hasher: utils.CKBHasher, witness: ArrayBuffer): void {\n    const lengthBuffer = new ArrayBuffer(8);\n    const view = new DataView(lengthBuffer);\n    view.setBigUint64(0, BigInt(new toolkit.Reader(witness).length()), true);\n    hasher.update(lengthBuffer);\n    hasher.update(witness);\n  }\n\n  async getRollupCell(): Promise<Cell | undefined> {\n    const queryOptions = {\n      type: {\n        code_hash: ROLLUP_CONFIG.rollup_type_script.code_hash as Hash,\n        hash_type: ROLLUP_CONFIG.rollup_type_script.hash_type as HashType,\n        args: ROLLUP_CONFIG.rollup_type_script.args as HexString,\n      }\n    }\n    const collector = this.ckbIndexer.collector(queryOptions)\n    let rollupCell;\n    for await (const cell of collector.collect()) {\n      if (cell === null) {\n        return undefined;\n      } else {\n        rollupCell = cell\n        break;\n      }\n    }\n    return rollupCell\n  }\n\n  async getLastFinalizedBlockNumber(): Promise<number> {\n    const rollupCell = await this.getRollupCell();\n    if(!rollupCell === undefined) {\n      return 0;\n    }\n    const globalState = new godwokenCore.GlobalState(new toolkit.Reader(rollupCell!.data))\n    const lastFinalizedBlockNumber = Number(globalState.getLastFinalizedBlockNumber().toLittleEndianBigUint64())\n    console.log(\"last finalized block number: \", lastFinalizedBlockNumber);\n    return lastFinalizedBlockNumber\n  }\n}\n","export const SUDT_ERC20_PROXY_ABI = [\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"name_\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"symbol_\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalSupply_\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"sudtId_\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"decimals_\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"sudtId\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"addedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"increaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"subtractedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"decreaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n","import {\n  Cell,\n  CellDep,\n  core,\n  DepType,\n  Hash,\n  HashType,\n  helpers,\n  HexNumber,\n  HexString,\n  Script,\n  toolkit,\n  utils,\n  WitnessArgs,\n} from \"@ckb-lumos/lumos\";\nimport { core as godwokenCore } from \"@polyjuice-provider/godwoken\";\nimport EventEmitter from \"events\";\nimport * as secp256k1 from \"secp256k1\";\nimport { ROLLUP_CONFIG, SCRIPTS } from \"./constants\";\nimport { TOKEN_LIST } from \"./constants/tokens\";\nimport {\n  NormalizeRawWithdrawalRequest,\n  NormalizeWithdrawalLockArgs,\n  RawWithdrawalRequest,\n  WithdrawalLockArgs,\n  WithdrawalRequest,\n} from \"./godwoken/normalizer\";\nimport LightGodwokenProvider, { POLYJUICE_CONFIG } from \"./lightGodwokenProvider\";\nimport {\n  GetErc20Balances,\n  GetErc20BalancesResult,\n  GetL2CkbBalancePayload,\n  L1MappedErc20,\n  LightGodwoken,\n  UnlockPayload,\n  WithdrawalEventEmitter,\n  WithdrawalEventEmitterPayload,\n  WithdrawResult,\n} from \"./lightGodwokenType\";\nimport {\n  SerializeRawWithdrawalRequest,\n  SerializeUnlockWithdrawalViaFinalize,\n  SerializeWithdrawalLockArgs,\n} from \"./schemas/index.esm\";\n\nexport default class DefaultLightGodwoken implements LightGodwoken {\n  provider: LightGodwokenProvider;\n  constructor(provider: LightGodwokenProvider) {\n    this.provider = provider;\n  }\n  /**\n   * get producing 1 block time\n   */\n  getBlockProduceTime(): number {\n    return 45 * 1000;\n  }\n\n  async unlock(payload: UnlockPayload): Promise<Hash> {\n    const l1Address = this.provider.l1Address;\n    const l1Lock = helpers.parseAddress(l1Address);\n    const outputCells: Cell[] = [];\n    if(payload.cell.cell_output.type) {\n      const dummySudtCell = {\n        cell_output: {\n          capacity: \"0x0\",\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      }\n      const sudtCapacity: bigint = helpers.minimalCellCapacity(dummySudtCell);\n      const capacityLeft = BigInt(payload.cell.cell_output.capacity) - sudtCapacity\n\n      outputCells.push({\n        cell_output: {\n          capacity: `0x${capacityLeft.toString(16)}`,\n          lock: l1Lock,\n        },\n        data: \"0x\",\n      });\n      outputCells.push({\n        cell_output: {\n          capacity: `0x${sudtCapacity.toString(16)}`,\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      });\n    } else {\n      outputCells.push({\n        cell_output: {\n          capacity: payload.cell.cell_output.capacity,\n          lock: l1Lock,\n          type: payload.cell.cell_output.type,\n        },\n        data: payload.cell.data,\n      });\n    }\n    const data =\n      \"0x00000000\" +\n      new toolkit.Reader(SerializeUnlockWithdrawalViaFinalize(toolkit.normalizers.NormalizeWitnessArgs({})))\n        .serializeJson()\n        .slice(2);\n    const newWitnessArgs: WitnessArgs = {\n      lock: data,\n    };\n    const withdrawalWitness = new toolkit.Reader(\n      core.SerializeWitnessArgs(toolkit.normalizers.NormalizeWitnessArgs(newWitnessArgs)),\n    ).serializeJson();\n\n    let txSkeleton = helpers.TransactionSkeleton({ cellProvider: this.provider.ckbIndexer });\n    const omniLockCellDep: CellDep = {\n      out_point: {\n        tx_hash: SCRIPTS.omni_lock.tx_hash,\n        index: SCRIPTS.omni_lock.index,\n      },\n      dep_type: SCRIPTS.omni_lock.dep_type as DepType,\n    };\n    const secp256k1CellDep: CellDep = {\n      out_point: {\n        tx_hash: SCRIPTS.secp256k1_blake160.tx_hash,\n        index: SCRIPTS.secp256k1_blake160.index,\n      },\n      dep_type: SCRIPTS.secp256k1_blake160.dep_type as DepType,\n    };\n    const withdrawalLockDep: CellDep = {\n      out_point: {\n        tx_hash: SCRIPTS.withdrawal_lock.cell_dep.out_point.tx_hash,\n        index: SCRIPTS.withdrawal_lock.cell_dep.out_point.index,\n      },\n      dep_type: SCRIPTS.withdrawal_lock.cell_dep.dep_type as DepType,\n    };\n    const rollupCell = await this.provider.getRollupCell();\n    if (!rollupCell || !rollupCell.cell_output) {\n      throw new Error(\"rollup cell outpoint not found\");\n    }\n    const rollupDep: CellDep = {\n      out_point: {\n        tx_hash: rollupCell.out_point!.tx_hash,\n        index: rollupCell.out_point!.index,\n      },\n      dep_type: \"code\" as DepType,\n    };\n    txSkeleton = txSkeleton\n      .update(\"inputs\", (inputs) => {\n        return inputs.push(payload.cell);\n      })\n      .update(\"outputs\", (outputs) => {\n        return outputs.push(...outputCells);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(withdrawalLockDep);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(rollupDep);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(omniLockCellDep);\n      })\n      .update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(secp256k1CellDep);\n      })\n      .update(\"witnesses\", (witnesses) => {\n        return witnesses.push(withdrawalWitness);\n      });\n\n    if (payload.cell.cell_output.type) {\n      const sudtCellDep: CellDep = {\n        out_point: {\n          tx_hash: SCRIPTS.sudt.tx_hash,\n          index:  SCRIPTS.sudt.index,\n        },\n        dep_type:  SCRIPTS.sudt.dep_type as DepType,\n      };\n      txSkeleton = txSkeleton.update(\"cellDeps\", (cell_deps) => {\n        return cell_deps.push(sudtCellDep);\n      });\n    }\n\n    txSkeleton = await this.injectCapacity(txSkeleton, l1Lock, BigInt(0));\n\n    const signedTx = await this.provider.signL1Transaction(txSkeleton);\n    const txHash = await this.provider.sendL1Transaction(signedTx);\n    return txHash;\n  }\n\n  async listWithdraw(): Promise<WithdrawResult[]> {\n    const searchParams = this.getWithdrawalCellSearchParams(this.provider.l2Address);\n    console.log(\"searchParams is:\", searchParams);\n    const collectedCells: WithdrawResult[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: searchParams.script });\n    const lastFinalizedBlockNumber = await this.provider.getLastFinalizedBlockNumber();\n\n    const ownerCKBLock = helpers.parseAddress(this.provider.l1Address);\n    const ownerLock: Script = {\n      code_hash: ownerCKBLock.code_hash,\n      args: ownerCKBLock.args,\n      hash_type: ownerCKBLock.hash_type as HashType,\n    };\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n\n    for await (const cell of collector.collect()) {\n      const rawLockArgs = cell.cell_output.lock.args;\n      const lockArgs = new godwokenCore.WithdrawalLockArgs(new toolkit.Reader(`0x${rawLockArgs.slice(66)}`));\n\n      if (lockArgs == null) {\n        continue;\n      }\n\n      const withdrawBlock = Number(lockArgs.getWithdrawalBlockNumber().toLittleEndianBigUint64());\n      const containsOwnerLock = cell.cell_output.lock.args.includes(ownerLockHash.substring(2));\n\n      let sudtTypeHash = \"0x\" + \"00\".repeat(32);\n      let erc20: L1MappedErc20 | undefined = undefined;\n      let amount: HexNumber = \"0x0\";\n\n      if (cell.cell_output.type) {\n        const sudtType: Script = {\n          code_hash: cell.cell_output.type.code_hash,\n          args: cell.cell_output.type.args,\n          hash_type: cell.cell_output.type.hash_type as HashType,\n        };\n        sudtTypeHash = utils.computeScriptHash(sudtType);\n        const builtinErc20List = this.getBuiltinErc20List();\n        erc20 = builtinErc20List.find((e) => e.sudt_script_hash === sudtTypeHash);\n        amount = `0x${utils.readBigUInt128LE(cell.data).toString(16)}`;\n      }\n\n      if (containsOwnerLock) {\n        collectedCells.push({\n          cell,\n          withdrawalBlockNumber: withdrawBlock,\n          remainingBlockNumber: Math.max(0, withdrawBlock - lastFinalizedBlockNumber),\n          capacity: cell.cell_output.capacity,\n          amount,\n          sudt_script_hash: sudtTypeHash,\n          erc20,\n        });\n      }\n    }\n    const sortedWithdrawals = collectedCells.sort((a, b) => {\n      return a.withdrawalBlockNumber - b.withdrawalBlockNumber;\n    });\n    console.log(\"found withdraw cells:\", sortedWithdrawals);\n    return sortedWithdrawals;\n  }\n\n  getWithdrawalCellSearchParams(ethAddress: string) {\n    if (ethAddress.length !== 42 || !ethAddress.startsWith(\"0x\")) {\n      throw new Error(\"eth address format error!\");\n    }\n    const layer2Lock: Script = {\n      code_hash: SCRIPTS.eth_account_lock.script_type_hash as string,\n      hash_type: \"type\",\n      args: ROLLUP_CONFIG.rollup_type_hash + ethAddress.slice(2).toLowerCase(),\n    };\n    const accountScriptHash = utils.computeScriptHash(layer2Lock);\n\n    return {\n      script: {\n        code_hash: SCRIPTS.withdrawal_lock.script_type_hash,\n        hash_type: \"type\" as HashType,\n        args: `${ROLLUP_CONFIG.rollup_type_hash}${accountScriptHash.slice(2)}`,\n      },\n      script_type: \"lock\",\n    };\n  }\n\n  withdrawWithEvent(payload: WithdrawalEventEmitterPayload): WithdrawalEventEmitter {\n    const eventEmitter = new EventEmitter();\n    this.withdraw(eventEmitter, payload);\n    return eventEmitter;\n  }\n\n  async withdraw(eventEmitter: EventEmitter, payload: WithdrawalEventEmitterPayload): Promise<void> {\n    eventEmitter.emit(\"sending\");\n    const rollupTypeHash = ROLLUP_CONFIG.rollup_type_hash;\n    const ethAccountTypeHash = SCRIPTS.eth_account_lock.script_type_hash;\n    console.log(\" helpers.parseAddress(payload.withdrawal_address || this.provider.l1Address)\", payload, this.provider);\n\n    const ownerLock = helpers.parseAddress(payload.withdrawal_address || this.provider.l1Address);\n    const ownerLockHash = utils.computeScriptHash(ownerLock);\n    const ethAddress = this.provider.l2Address;\n    const l2AccountScript: Script = {\n      code_hash: ethAccountTypeHash,\n      hash_type: \"type\",\n      args: rollupTypeHash + ethAddress.slice(2),\n    };\n    const accountScriptHash = utils.computeScriptHash(l2AccountScript);\n    console.log(\"account script hash:\", accountScriptHash);\n    const fromId = await this.provider.godwokenClient.getAccountIdByScriptHash(accountScriptHash);\n    if (!fromId) {\n      throw new Error(\"account not found\");\n    }\n    const isSudt = payload.sudt_script_hash !== \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n    const minCapacity = this.minimalWithdrawalCapacity(isSudt);\n    if (BigInt(payload.capacity) < BigInt(minCapacity)) {\n      throw new Error(\n        `Withdrawal required ${BigInt(minCapacity)} shannons at least, provided ${BigInt(payload.capacity)}.`,\n      );\n    }\n    const nonce: HexNumber = await this.provider.godwokenClient.getNonce(fromId);\n    console.log(\"nonce:\", nonce);\n    const sellCapacity: HexNumber = \"0x0\";\n    const sellAmount: HexNumber = \"0x0\";\n    const paymentLockHash: HexNumber = \"0x\" + \"00\".repeat(32);\n    const feeSudtId: HexNumber = \"0x1\";\n    const feeAmount: HexNumber = \"0x0\";\n    const rawWithdrawalRequest: RawWithdrawalRequest = {\n      nonce: \"0x\" + BigInt(nonce).toString(16),\n      capacity: \"0x\" + BigInt(payload.capacity).toString(16),\n      amount: \"0x\" + BigInt(payload.amount).toString(16),\n      sudt_script_hash: payload.sudt_script_hash,\n      account_script_hash: accountScriptHash,\n      sell_amount: sellAmount,\n      sell_capacity: sellCapacity,\n      owner_lock_hash: ownerLockHash,\n      payment_lock_hash: paymentLockHash,\n      fee: {\n        sudt_id: feeSudtId,\n        amount: feeAmount,\n      },\n    };\n    console.log(\"rawWithdrawalRequest:\", rawWithdrawalRequest);\n    const message = this.generateWithdrawalMessageToSign(rawWithdrawalRequest, rollupTypeHash);\n    console.log(\"message:\", message);\n    const signatureMetamaskPersonalSign: HexString = await this.signMessageMetamaskPersonalSign(message);\n    console.log(\"signatureMetamaskPersonalSign:\", signatureMetamaskPersonalSign);\n    const withdrawalRequest: WithdrawalRequest = {\n      raw: rawWithdrawalRequest,\n      signature: signatureMetamaskPersonalSign,\n    };\n    console.log(\"withdrawalRequest:\", withdrawalRequest);\n    // using RPC `submitWithdrawalRequest` to submit withdrawal request to godwoken\n    let result: unknown;\n    try {\n      result = await this.provider.godwokenClient.submitWithdrawalRequest(withdrawalRequest);\n    } catch (e) {\n      eventEmitter.emit(\"error\", e);\n      return;\n    }\n    eventEmitter.emit(\"sent\", result);\n    console.log(\"withdrawal request result:\", result);\n    const maxLoop = 100;\n    let loop = 0;\n    const nIntervId = setInterval(async () => {\n      loop++;\n      const withdrawal: any = await this.getWithdrawal(result as unknown as Hash);\n      if (withdrawal && withdrawal.status === \"pending\") {\n        console.log(\"withdrawal pending:\", withdrawal);\n        eventEmitter.emit(\"pending\", result);\n      }\n      if (withdrawal && withdrawal.status === \"committed\") {\n        console.log(\"withdrawal committed:\", withdrawal);\n        eventEmitter.emit(\"success\", result);\n        clearInterval(nIntervId);\n      }\n      if (withdrawal === null && loop > maxLoop) {\n        eventEmitter.emit(\"fail\", result);\n        clearInterval(nIntervId);\n      }\n    }, 10000);\n  }\n\n  async getWithdrawal(txHash: Hash): Promise<unknown> {\n    const result = await this.provider.godwokenClient.getWithdrawal(txHash);\n    console.log(\"getWithdrawal result:\", result);\n    return result;\n  }\n\n  async signMessageMetamaskPersonalSign(message: Hash): Promise<HexString> {\n    let signedMessage = await this.provider.ethereum.request({\n      method: \"personal_sign\",\n      params: [this.provider.l2Address, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    return signedMessage;\n  }\n\n  async signMessageMetamaskEthSign(message: Hash): Promise<HexString> {\n    let signedMessage = await this.provider.ethereum.request({\n      method: \"eth_sign\",\n      params: [this.provider.l2Address, message],\n    });\n    let v = Number.parseInt(signedMessage.slice(-2), 16);\n    if (v >= 27) v -= 27;\n    signedMessage = \"0x\" + signedMessage.slice(2, -2) + v.toString(16).padStart(2, \"0\");\n    return signedMessage;\n  }\n\n  signMessage(message: Hash, privateKey: HexString): HexString {\n    const signObject = secp256k1.ecdsaSign(\n      new Uint8Array(new toolkit.Reader(message).toArrayBuffer()),\n      new Uint8Array(new toolkit.Reader(privateKey).toArrayBuffer()),\n    );\n    const signatureBuffer = new ArrayBuffer(65);\n    const signatureArray = new Uint8Array(signatureBuffer);\n    signatureArray.set(signObject.signature, 0);\n    let v = signObject.recid;\n    if (v >= 27) {\n      v -= 27;\n    }\n    signatureArray.set([v], 64);\n\n    const signature = new toolkit.Reader(signatureBuffer).serializeJson();\n    return signature;\n  }\n\n  generateWithdrawalMessageToSign(rawWithdrawalRequest: RawWithdrawalRequest, rollupTypeHash: Hash): Hash {\n    const serializedRawWithdrawalRequest: HexString = new toolkit.Reader(\n      SerializeRawWithdrawalRequest(NormalizeRawWithdrawalRequest(rawWithdrawalRequest)),\n    ).serializeJson();\n    const data = new toolkit.Reader(rollupTypeHash + serializedRawWithdrawalRequest.slice(2)).toArrayBuffer();\n    const message = utils.ckbHash(data).serializeJson();\n    return message;\n  }\n\n  minimalWithdrawalCapacity(isSudt: boolean): HexNumber {\n    // fixed size, the specific value is not important.\n    const dummyHash: Hash = \"0x\" + \"00\".repeat(32);\n    const dummyHexNumber: HexNumber = \"0x0\";\n    const dummyRollupTypeHash: Hash = dummyHash;\n    const dummyWithdrawalLockArgs: WithdrawalLockArgs = {\n      account_script_hash: dummyHash,\n      withdrawal_block_hash: dummyHash,\n      withdrawal_block_number: dummyHexNumber,\n      sudt_script_hash: dummyHash,\n      sell_amount: dummyHexNumber,\n      sell_capacity: dummyHexNumber,\n      owner_lock_hash: dummyHash,\n      payment_lock_hash: dummyHash,\n    };\n    const serialized: HexString = new toolkit.Reader(\n      SerializeWithdrawalLockArgs(NormalizeWithdrawalLockArgs(dummyWithdrawalLockArgs)),\n    ).serializeJson();\n    const args = dummyRollupTypeHash + serialized.slice(2);\n    const lock: Script = {\n      code_hash: dummyHash,\n      hash_type: \"data\",\n      args,\n    };\n    let type: Script | undefined = undefined;\n    let data = \"0x\";\n    if (isSudt) {\n      type = {\n        code_hash: dummyHash,\n        hash_type: \"data\",\n        args: dummyHash,\n      };\n      data = \"0x\" + \"00\".repeat(16);\n    }\n    const cell: Cell = {\n      cell_output: {\n        lock,\n        type,\n        capacity: dummyHexNumber,\n      },\n      data,\n    };\n    const capacity: bigint = helpers.minimalCellCapacity(cell);\n    return \"0x\" + capacity.toString(16);\n  }\n\n  async getL2CkbBalance(payload?: GetL2CkbBalancePayload): Promise<HexNumber> {\n    const balance = await this.provider.web3.eth.getBalance(payload?.l2Address || this.provider.l2Address);\n    return \"0x\" + Number(balance).toString(16);\n  }\n\n  getBuiltinErc20List(): L1MappedErc20[] {\n    const map: L1MappedErc20[] = [];\n    TOKEN_LIST.forEach((token) => {\n      const tokenL1Script: Script = {\n        code_hash: token.l1Lock.code_hash,\n        args: token.l1Lock.args,\n        hash_type: token.l1Lock.hash_type as HashType,\n      };\n      const tokenScriptHash = utils.computeScriptHash(tokenL1Script);\n      map.push({\n        name: token.name,\n        symbol: token.symbol,\n        decimals: token.decimals,\n        address: token.address,\n        tokenURI: token.tokenURI,\n        sudt_script_hash: tokenScriptHash,\n      });\n    });\n    return map;\n  }\n\n  async getErc20Balances(payload: GetErc20Balances): Promise<GetErc20BalancesResult> {\n    const result: GetErc20BalancesResult = { balances: [] };\n    let promises = [];\n    for (let index = 0; index < payload.addresses.length; index++) {\n      const address = payload.addresses[index];\n      const usdcContract = new this.provider.web3.eth.Contract(POLYJUICE_CONFIG.abiItems, address);\n      const usdcBalancePromise = usdcContract.methods.balanceOf(this.provider.l2Address).call();\n      promises.push(usdcBalancePromise);\n    }\n    await Promise.all(promises).then((values) => {\n      values.forEach((value) => {\n        result.balances.push(\"0x\" + Number(value).toString(16));\n      });\n    });\n    return result;\n  }\n\n  async injectCapacity(\n    tx: helpers.TransactionSkeletonType,\n    fromScript: Script,\n    capacity: bigint,\n  ): Promise<helpers.TransactionSkeletonType> {\n    // additional 0.001 ckb for tx fee\n    // the tx fee could calculated by tx size\n    // this is just a simple example\n    const neededCapacity = capacity + BigInt(100000);\n    let collectedSum = BigInt(0);\n    const collectedCells: Cell[] = [];\n    const collector = this.provider.ckbIndexer.collector({ lock: fromScript, type: \"empty\" });\n    for await (const cell of collector.collect()) {\n      if (!cell.data || cell.data === \"0x\" || cell.data === \"0x0\" || cell.data === \"0x00\") {\n        collectedSum += BigInt(cell.cell_output.capacity);\n        collectedCells.push(cell);\n        if (collectedSum >= neededCapacity) break;\n      }\n    }\n    if (collectedSum < neededCapacity) {\n      throw new Error(`Not enough CKB, expected: ${neededCapacity}, actual: ${collectedSum} `);\n    }\n    const changeOutput: Cell = {\n      cell_output: {\n        capacity: \"0x\" + BigInt(collectedSum - neededCapacity).toString(16),\n        lock: fromScript,\n      },\n      data: \"0x\",\n    };\n    tx = tx.update(\"inputs\", (inputs) => inputs.push(...collectedCells));\n    tx = tx.update(\"outputs\", (outputs) => outputs.push(changeOutput));\n    return tx;\n  }\n}\n","import detectEthereumProvider from \"@metamask/detect-provider\";\nimport React, { createContext, useEffect, useState } from \"react\";\nimport { LightGodwoken } from \"../light-godwoken\";\nimport DefaultLightGodwoken from \"../light-godwoken/lightGodwoken\";\nimport DefaultLightGodwokenProvider from \"../light-godwoken/lightGodwokenProvider\";\n\nexport const LightGodwokenContext = createContext<LightGodwoken | null>(null);\n\nexport const Provider: React.FC = (props) => {\n  const [lightGodwoken, setLightGodwoken] = useState<LightGodwoken>();\n\n  useEffect(() => {\n    detectEthereumProvider().then((ethereum: any) => {\n      ethereum.request({ method: \"eth_accounts\" }).then((accounts: string[]) => {\n        if (!accounts || !accounts[0]) return;\n\n        const instance = new DefaultLightGodwoken(new DefaultLightGodwokenProvider(accounts[0], ethereum));\n        setLightGodwoken(instance);\n      });\n\n      ethereum.on(\"accountsChanged\", (accounts: string[] | undefined) => {\n        if (!accounts || !accounts[0]) return setLightGodwoken(undefined);\n\n        const provider = new DefaultLightGodwoken(new DefaultLightGodwokenProvider(ethereum.selectedAddress, ethereum));\n        setLightGodwoken(provider);\n      });\n    });\n  }, []);\n\n  return <LightGodwokenContext.Provider value={lightGodwoken || null}>{props.children}</LightGodwokenContext.Provider>;\n};\n","import { useContext } from \"react\";\nimport { LightGodwokenContext } from \"../contexts/LightGodwokenContext\";\nimport { LightGodwoken } from \"../light-godwoken\";\n\nexport const useLightGodwoken = (): LightGodwoken | null => {\n  const lightGodwoken = useContext(LightGodwokenContext);\n\n  return lightGodwoken;\n};\n","export const getDisplayAmount = (balance: BigInt, decimals = 8) => {\n  const valueStr = balance.toString();\n  if (decimals === 0) {\n    return valueStr;\n  }\n\n  const intPart = valueStr.slice(0, -decimals) || \"0\";\n  const unit = intPart === \"0\" ? 1e8 : 1e4;\n  let decPart = valueStr\n    .slice(-decimals)\n    .padStart(decimals, \"0\")\n    .slice(0, intPart === \"0\" ? 9 : 5);\n  decPart = (Math.round(Number(`0.${decPart}`) * unit) / unit)\n    .toFixed(intPart === \"0\" ? 8 : 4)\n    .replace(/(\\d)0+$/, \"$1\")\n    .slice(2);\n\n  return `${intPart}${decPart === \"0\" ? \"\" : `.${decPart}`}`;\n};\n\nexport const getFullDisplayAmount = (value: BigInt, decimals = 8, options: { maxDecimalPlace?: number } = {}) => {\n  const { maxDecimalPlace = 4 } = options;\n\n  const valueStr = value.toString();\n  if (decimals === 0) {\n    return valueStr;\n  }\n\n  const intPart = valueStr.slice(0, -decimals) || \"0\";\n  const decPart = valueStr\n    .slice(-decimals)\n    .padStart(decimals, \"0\")\n    .replace(/(\\d)0+$/, \"$1\")\n    .slice(0, maxDecimalPlace);\n\n  return `${intPart}${decPart === \"0\" ? \"\" : `.${decPart}`}`;\n};\n","import React from 'react'\nimport styled from 'styled-components'\n\nconst StyledInput = styled.input<{ error?: boolean; fontSize?: string; align?: string }>`\n  width: 0;\n  position: relative;\n  font-weight: 500;\n  outline: none;\n  border: none;\n  flex: 1 1 auto;\n  background-color: transparent;\n  font-size: 16px;\n  text-align: ${({ align }) => align && align};\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  padding: 0px;\n  -webkit-appearance: textfield;\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  [type='number'] {\n    -moz-appearance: textfield;\n  }\n\n  ::-webkit-outer-spin-button,\n  ::-webkit-inner-spin-button {\n    -webkit-appearance: none;\n  }\n\n  :disabled {\n    cursor: text;\n  }\n`\n\nexport function escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n}\nconst inputRegex = RegExp(`^\\\\d*(?:\\\\\\\\[.])?\\\\d*$`) // match escaped \".\" characters via in a non-capturing group\n\nexport const Input = React.memo(function InnerInput({\n  value,\n  onUserInput,\n  placeholder,\n  ...rest\n}: {\n  value: string | number\n  onUserInput: (input: string) => void\n  error?: boolean\n  fontSize?: string\n  align?: 'right' | 'left'\n} & Omit<React.HTMLProps<HTMLInputElement>, 'ref' | 'onChange' | 'as'>) {\n  const enforcer = (nextUserInput: string) => {\n    if (nextUserInput === '' || inputRegex.test(escapeRegExp(nextUserInput))) {\n      onUserInput(nextUserInput)\n    }\n  }\n\n\n  return (\n    <StyledInput\n      {...rest}\n      value={value}\n      onChange={(event) => {\n        // replace commas with periods, because we exclusively uses period as the decimal separator\n        enforcer(event.target.value.replace(/,/g, '.'))\n      }}\n      // universal input options\n      inputMode=\"decimal\"\n      title='Token Amount'\n      autoComplete=\"off\"\n      autoCorrect=\"off\"\n      // text-specific options\n      type=\"text\"\n      pattern=\"^[0-9]*[.,]?[0-9]*$\"\n      placeholder={placeholder || '0.0'}\n      minLength={1}\n      maxLength={79}\n      spellCheck=\"false\"\n    />\n  )\n})\n\nexport default Input\n","import { Typography } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nimport { getDisplayAmount } from \"../utils/formatTokenAmount\";\nimport NumericalInput from \"./NumericalInput\";\n\nconst StyleWrapper = styled.div`\n  font-size: 14px;\n  border-radius: 16px;\n  background-color: rgb(60, 58, 75);\n  box-shadow: rgb(74 74 104 / 10%) 0px 2px 2px -1px;\n  .first-row {\n    margin-bottom: 3px;\n    padding: 0.75rem 1rem 0px;\n  }\n  .anticon {\n    font-size: 12px;\n  }\n\n  .input-wrapper {\n    padding: 0.75rem 0.5rem 0.75rem 1rem;\n  }\n`;\nconst Row = styled.div`\n  display: flex;\n  justify-content: space-between;\n  .ant-typography {\n    color: white;\n    font-size: 16px;\n    font-weight: 400;\n    line-height: 1.5;\n  }\n  .ckb-logo {\n    height: 24px;\n    width: 24px;\n    margin-right: 8px;\n  }\n  .max-button {\n    height: 32px;\n    padding: 0px 16px;\n    background-color: transparent;\n    color: rgb(255, 67, 66);\n    font-weight: 600;\n    &:hover {\n      cursor: pointer;\n    }\n  }\n`;\n\ninterface CKBInputPanelProps {\n  value: string;\n  onUserInput: (value: string) => void;\n  label?: string;\n}\nexport default function CKBInputPanel({ value, onUserInput, label }: CKBInputPanelProps) {\n  const [showMaxButton, setShowMaxButton] = useState(true);\n  const [l2CkbBalance, setL2CkbBalance] = useState(\"\");\n  const lightGodwoken = useLightGodwoken();\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const balance = (await lightGodwoken?.getL2CkbBalance()) || \"\";\n      setL2CkbBalance(balance);\n    };\n    fetchData();\n  }, [lightGodwoken]);\n\n  useEffect(() => {\n    if (value !== getDisplayAmount(BigInt(l2CkbBalance), 8)) {\n      setShowMaxButton(true);\n    } else {\n      setShowMaxButton(false);\n    }\n  }, [value, l2CkbBalance]);\n\n  const handelMaxClick = () => {\n    onUserInput(getDisplayAmount(BigInt(l2CkbBalance), 8));\n    setShowMaxButton(false);\n  };\n  return (\n    <StyleWrapper>\n      <Row className=\"first-row\">\n        <Typography.Text>{label}</Typography.Text>\n        <Typography.Text>Balance: {getDisplayAmount(BigInt(l2CkbBalance), 8) || \"\"}</Typography.Text>\n      </Row>\n      <Row className=\"input-wrapper\">\n        <NumericalInput\n          className=\"token-amount-input\"\n          value={value}\n          placeholder=\"Minimum 400 CKB\"\n          onUserInput={(val) => {\n            onUserInput(val);\n          }}\n        />\n        {showMaxButton && (\n          <Typography.Text className=\"max-button\" onClick={handelMaxClick}>\n            MAX\n          </Typography.Text>\n        )}\n        <img className=\"ckb-logo\" src=\"/static/ckb.svg\" alt=\"\" />\n        <Typography.Text>CKB</Typography.Text>\n      </Row>\n    </StyleWrapper>\n  );\n}\n","const MINUTE_IN_SECONDS = 60\nconst HOUR_IN_SECONDS = 3600\nconst DAY_IN_SECONDS = 86400\nconst MONTH_IN_SECONDS = 2629800\nconst YEAR_IN_SECONDS = 31557600\n\n/**\n * Format number of seconds into year, month, day, hour, minute, seconds\n *\n * @param seconds\n */\nconst getTimePeriods = (seconds: number) => {\n  let delta = Math.abs(seconds)\n  const timeLeft = {\n    years: 0,\n    months: 0,\n    days: 0,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n  }\n\n  if (delta >= YEAR_IN_SECONDS) {\n    timeLeft.years = Math.floor(delta / YEAR_IN_SECONDS)\n    delta -= timeLeft.years * YEAR_IN_SECONDS\n  }\n\n  if (delta >= MONTH_IN_SECONDS) {\n    timeLeft.months = Math.floor(delta / MONTH_IN_SECONDS)\n    delta -= timeLeft.months * MONTH_IN_SECONDS\n  }\n\n  if (delta >= DAY_IN_SECONDS) {\n    timeLeft.days = Math.floor(delta / DAY_IN_SECONDS)\n    delta -= timeLeft.days * DAY_IN_SECONDS\n  }\n\n  if (delta >= HOUR_IN_SECONDS) {\n    timeLeft.hours = Math.floor(delta / HOUR_IN_SECONDS)\n    delta -= timeLeft.hours * HOUR_IN_SECONDS\n  }\n\n  if (delta >= MINUTE_IN_SECONDS) {\n    timeLeft.minutes = Math.floor(delta / MINUTE_IN_SECONDS)\n    delta -= timeLeft.minutes * MINUTE_IN_SECONDS\n  }\n\n  timeLeft.seconds = Math.floor(delta)\n\n  return timeLeft\n}\n\nexport default getTimePeriods\n","import React, {useState, useCallback, useEffect, useMemo} from 'react';\nimport styled from \"styled-components\";\nimport {DownOutlined, UpOutlined} from '@ant-design/icons';\nimport { Button, Popconfirm, Typography, notification } from 'antd';\nimport getTimePeriods from '../utils/getTimePeriods';\nimport { getDisplayAmount, getFullDisplayAmount } from '../utils/formatTokenAmount';\nimport { Cell, HexNumber } from '@ckb-lumos/lumos';\nimport { L1MappedErc20 } from '../light-godwoken/lightGodwokenType';\nimport { useLightGodwoken } from '../hooks/useLightGodwoken';\nimport { Link } from 'react-router-dom';\nconst { Text } = Typography;\nconst StyleWrapper = styled.div`\n  background: rgb(39, 37, 52);\n  padding: 16px;\n  border-radius: 12px;\n  .header {\n      display: flex;\n      flex-direction: row;\n      justify-content: space-between;\n      font-weight: 400;\n    line-height: 1.5;\n    font-size: 14px;\n  }\n  .icons {\n    display: flex;\n    img {\n      width: 20px;\n      height: 20px;\n      margin-right: 5px;\n    }\n  }\n  .ckb-icon {\n      width: 20px;\n      height: 20px;\n      background: url(./static/ckb.svg) no-repeat no-repeat;\n      background-size: contain;\n  }\n  .number {\n    margin-top: 3px;\n  }\n  .time {\n    align-self: center;\n    display: flex;\n    height: 40px;\n    align-items: center;\n    .ant-typography {\n        padding-right: 5px;\n    }\n  }\n  .ant-typography {\n    color: white;\n  }\n  .list-detail {\n    padding-top: 10px;\n  }\n  .withdraw-button {\n    align-items: center;\n    border: 0px;\n    border-radius: 16px;\n    box-shadow: rgb(14 14 44 / 40%) 0px -1px 0px 0px inset;\n    cursor: pointer;\n    display: inline-flex;\n    font-family: inherit;\n    font-size: 16px;\n    font-weight: 600;\n    -webkit-box-pack: center;\n    justify-content: center;\n    letter-spacing: 0.03em;\n    line-height: 1;\n    opacity: 1;\n    outline: 0px;\n    transition: background-color 0.2s ease 0s, opacity 0.2s ease 0s;\n    height: 32px;\n    padding: 0px 16px;\n    background-color: rgb(255, 67, 66);\n    color: white;\n    margin-left: 4px;\n    margin-top: 8px;\n  }\n`\n\nexport const FixedHeightRow = styled.div`\n  height: 24px;\n  display: flex;\n  justify-content: space-between;\n  .ant-typography {\n    color: white;\n    font-size: 16px;\n    font-weight: 400;\n    line-height: 1.5;\n  }\n`\n\nexport interface IWithdrawalRequestCardProps {\n  remainingBlockNumber: number,\n  capacity: HexNumber,\n  amount: HexNumber,\n  cell: Cell,\n  erc20?: L1MappedErc20,\n  now?: number\n}\n\nconst WithdrawalRequestCard = ({\n   remainingBlockNumber, capacity, amount, erc20, now = 0, cell}: IWithdrawalRequestCardProps) => {\n  const [shouldShowMore, setShouldShowMore] = useState(false)\n  const [blockProduceTime, setBlockProduceTime] = useState(0)\n  const lightGodwoken = useLightGodwoken();\n\n  const handleToggleShowMore = useCallback(() => {\n    setShouldShowMore((value) => !value)\n  }, [])\n  useEffect(() => {\n    const fetchBlockProduceTime =  async () => {\n      const result:number= await lightGodwoken?.getBlockProduceTime() || 0\n      setBlockProduceTime(result);\n    }\n    fetchBlockProduceTime()\n  }, [lightGodwoken])\n\n  const estimatedArrivalDate = useMemo(() => Date.now() + remainingBlockNumber * blockProduceTime, [blockProduceTime, remainingBlockNumber])\n  const estimatedSecondsLeft = useMemo(() => Math.max(0, estimatedArrivalDate - now), [now, estimatedArrivalDate])\n  const isMature = useMemo(() => remainingBlockNumber === 0, [remainingBlockNumber])\n\n  const {\n    days: daysLeft,\n    hours: hoursLeft,\n    minutes: minutesLeft,\n    seconds: secondsLeft,\n  } = useMemo(() => getTimePeriods(estimatedSecondsLeft / 1000), [estimatedSecondsLeft])\n  const [ckbAmount, ckbFullAmount] = useMemo(() => {\n    if (capacity === '0') {\n      console.error('[warn] a withdrawal request cell with zero capacity')\n      return ['', '']\n    }\n    const capacityBI = BigInt(capacity)\n    return [\n      `${getDisplayAmount(capacityBI, 8)} CKB`,\n      `${getFullDisplayAmount(capacityBI, 8)} CKB`,\n    ]\n  }, [capacity])\n\n  const [sudtAmount, sudtFullAmount] = useMemo(() => {\n    if (amount === '' || !erc20) {\n      return ['', '']\n    }\n    const amountBI = BigInt(amount)\n\n    return [`${getDisplayAmount(amountBI, erc20.decimals)} ${erc20.symbol}`, `${getFullDisplayAmount(amountBI, erc20.decimals)} ${erc20.symbol}`]\n  }, [amount, erc20])\n\n  const unlock = async () => {\n    const txHash = await lightGodwoken?.unlock({cell})\n    const linkToExplorer = () => {\n      window.open(`https://explorer.nervos.org/aggron/transaction/${txHash}`, '_blank')\n    }\n    notification.success({ message: `Unlock Tx(${txHash}) is successful`, onClick: linkToExplorer });\n  }\n\n    return (\n      <StyleWrapper onClick={isMature ? undefined : handleToggleShowMore}>\n          <div className=\"header\">\n              <div className=\"amount\">\n                  <div className=\"icons\">\n                    {erc20?.tokenURI ? <img src={erc20?.tokenURI} alt=\"\" /> : ''}\n                    <div className=\"ckb-icon\"></div>\n                  </div>\n                  <div className=\"number\">{sudtAmount}\n            {sudtAmount === '' ? '' : ' and '}\n            {ckbAmount}</div>\n              </div>\n              {isMature \n                ? \n                <Popconfirm placement=\"top\" title='Confirm unlock withdrawal' onConfirm={unlock} okText=\"Confirm\" cancelText=\"Cancel\">\n                  <Button className='withdraw-button'>withdraw</Button> \n                </Popconfirm> \n                : (\n                  shouldShowMore ? (\n                    <div className=\"time\"><UpOutlined /></div>\n                  ) : (\n                    <div className=\"time\">\n                        <Text title=\"Estimated time left\">\n                  {daysLeft > 0\n                    ? `${daysLeft}${daysLeft > 1 ? ' days' : ' day'}`\n                    : `${hoursLeft > 0 ? `${hoursLeft.toString().padStart(2, '0')}:` : ''}${minutesLeft\n                        .toString()\n                        .padStart(2, '0')}:${secondsLeft.toString().padStart(2, '0')}`}\n                </Text>\n                        <DownOutlined/>\n                     </div>\n                  )\n              )}\n          </div>\n          {\n                  shouldShowMore && (\n                      <div className=\"list-detail\">\n                      <FixedHeightRow>\n                          <Text>Blocks remaining:</Text>\n                          <Text>{remainingBlockNumber}</Text>\n                      </FixedHeightRow>\n                      <FixedHeightRow>\n                          <Text>Estimated time left:</Text>\n                          <Text>\n                            {`${daysLeft > 0 ? `${daysLeft}${daysLeft > 1 ? ' days ' : ' day '}` : ''}${hoursLeft\n                              .toString()\n                              .padStart(2, '0')}:${minutesLeft.toString().padStart(2, '0')}:${secondsLeft\n                              .toString()\n                              .padStart(2, '0')}`}\n                            </Text>\n                      </FixedHeightRow>\n                      </div>\n\n                  )\n              }\n      </StyleWrapper>\n    )\n}\n\nexport default WithdrawalRequestCard","import styled from \"styled-components\"\nimport {Typography, Modal, List} from 'antd'\nimport { FixedHeightRow } from \"./WithdrawalRequestCard\"\nimport NumericalInput from './NumericalInput'\nimport { DownOutlined } from \"@ant-design/icons\"\nimport React, { useState, useEffect } from \"react\"\nimport { L1MappedErc20 } from \"../types/type\"\nimport {getFullDisplayAmount} from \"../utils/formatTokenAmount\"\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\"\nconst {Text} = Typography;\nconst StyleWrapper = styled.div`\n    border-radius: 16px;\n    background-color: rgb(60, 58, 75);\n    box-shadow: rgb(74 74 104 / 10%) 0px 2px 2px -1px;\n    .first-row {\n      margin-bottom: 3px;\n    }\n    .anticon {\n      font-size: 12px;\n    }\n    .max-button {\n      height: 32px;\n      line-height: 32px;\n      padding: 0px 16px;\n      background-color: transparent;\n      color: rgb(255, 67, 66);\n      font-weight: 600;\n    }\n    .token-list {\n      height: 390px;\n      overflow-y: auto;\n    }\n    .first-row {\n      margin-bottom: 3px;\n      padding: 0.75rem 1rem 0px;\n    }\n    .input-wrapper {\n      height: 56px;\n      padding: 0.75rem 0.5rem 0.75rem 1rem;\n      display: flex;\n      align-items: center;\n    }\n    .currency-wrapper {\n      display: flex;\n      align-items: center;\n    }\n    .anticon {\n      margin-left: 10px;\n    }\n`\n\nconst TokenList = styled.div`\n   height: 390px;\n    overflow-y: auto;\n`\n\nconst TokenListModal = styled(Modal)`\n  color: white;\n  .ant-modal-content {\n    border-radius: 32px;\n    background: rgb(39, 37, 52);\n    box-shadow: rgb(14 14 44 / 10%) 0px 20px 36px -8px, rgb(0 0 0 / 5%) 0px 1px 1px;\n    border: 1px solid rgb(60, 58, 75);\n    color: white;\n  }\n  .ant-modal-header {\n    background: rgb(39, 37, 52);\n    border: 1px solid rgb(60, 58, 75);\n    border-top-left-radius: 32px;\n    border-top-right-radius: 32px;\n    padding: 12px 24px;\n    height: 73px;\n    display: flex;\n    align-items: center;\n  }\n  .ant-modal-title, .ant-list-item {\n    color: white;\n  }\n  .ant-modal-body {\n    padding: 0px;\n  }\n  .ant-modal-close-x {\n    color: white;\n  }\n  .ant-list-item {\n    border-bottom: none;\n    padding: 4px 20px;\n    height: 56px;\n    &:hover {\n      background-color: rgb(60, 58, 75);\n      cursor: pointer;\n    }\n    &.selected {\n      background-color: rgb(60, 58, 75);\n    }\n  }\n  .currency-item {\n    width: 100%;\n    .info {\n      display: flex;\n      flex-direction: row;\n      align-items: center;\n    }\n    .icon {\n      width: 24px;\n      height: 24px;\n      margin-right: 10px;\n    }\n    .symbol-name {\n      display: flex;\n      flex-direction: column;\n      .symbol {\n        font-size: 16px;\n        font-weight: 600;\n        line-height: 1.5;\n      }\n      .name {\n        font-size: 14px;\n        line-height: 1.5;\n      }\n    }\n  }\n`\nconst Row = styled.div`\n  display: flex;\n  justify-content: space-between;\n  .ant-typography {\n    color: white;\n    font-size: 16px;\n    font-weight: 400;\n    line-height: 1.5;\n  }\n  .ckb-logo {\n    height:24px;\n    width: 24px;\n    margin-right: 8px;\n  }\n  .max-button {\n      height: 32px;\n      padding: 0px 16px;\n      background-color: transparent;\n      color: rgb(255, 67, 66);\n      font-weight: 600;\n    }\n`\n\ninterface CurrencyInputPanelProps {\n    value: string\n    onUserInput: (value: string) => void\n    label?: string\n    disableCurrencySelect?: boolean\n    hideBalance?: boolean\n    hideInput?: boolean\n    showCommonBases?: boolean\n    disableInput?: boolean\n    autoFocus?: boolean\n    transparent?: boolean,\n    onSelectedChange: (value: L1MappedErc20) => void\n  }\nexport default function CurrencyInputPanel({autoFocus, disableInput, value, onUserInput, label, onSelectedChange}: CurrencyInputPanelProps) {\n  const [selectedCurrencyBalance, setCurrencyBalance] = useState('');\n  const [showMaxButton, setShowMaxButton] = useState(false);\n  const [erc20List, setErc20List] = useState<L1MappedErc20[]>([])\n  const [balancesList, setBalancesList] = useState<string[]>([])\n  const [selectedCurrency, setSelectedCurrency] = useState<L1MappedErc20>()\n  const [selectedIndex, setSelectedIndex] = useState<number>()\n  const lightGodwoken = useLightGodwoken();\n  const showCurrencySelectModal = () => {\n    setIsModalVisible(true)\n  }\n  const [isModalVisible, setIsModalVisible] = useState(false);\n  useEffect(() => {\n    const fetchData =  async () => {\n      if(lightGodwoken) {\n        const results: L1MappedErc20[] = lightGodwoken.getBuiltinErc20List();\n        setErc20List(results);\n        const addressList = results.map(erc20 => (erc20.address))\n        const balances = await lightGodwoken.getErc20Balances({addresses: addressList})\n        setBalancesList(balances.balances);\n      }\n    }\n    fetchData()\n  }, [lightGodwoken])\n\n  useEffect(() => {\n    if(selectedCurrency && \n      (value !== selectedCurrencyBalance || value === '')) {\n      setShowMaxButton(true);\n    } else {\n      setShowMaxButton(false);\n    }\n  }, [value, selectedCurrencyBalance, selectedCurrency])\n\n  useEffect(() => {\n    if(balancesList && balancesList.length && selectedIndex !== undefined && selectedCurrency) {\n      const balance = balancesList[selectedIndex];\n      const currencyBalance = getFullDisplayAmount(BigInt(balance), selectedCurrency.decimals)\n      setCurrencyBalance(currencyBalance);\n    }\n  }, [selectedIndex, balancesList, selectedCurrency])\n\n  const handleOk = () => {\n    setIsModalVisible(false);\n  };\n\n  const handleCancel = () => {\n    setIsModalVisible(false);\n  };\n  const handleErc20Selected = (index: number, erc20: L1MappedErc20) => {\n    setSelectedCurrency(erc20);\n    onSelectedChange(erc20);\n    setIsModalVisible(false)\n    setShowMaxButton(true);\n    onUserInput('')\n    setSelectedIndex(index);\n  }\n  const handelMaxClick = () => {\n    onUserInput(selectedCurrencyBalance)\n    setShowMaxButton(false);\n  }\n    return (\n      <StyleWrapper>\n          <Row className=\"first-row\">\n            <Typography.Text>{label}</Typography.Text>\n            <Typography.Text>{selectedCurrencyBalance || ''}</Typography.Text>\n          </Row>\n          <Row className=\"input-wrapper\">\n            <NumericalInput\n                  autoFocus={autoFocus}\n                  disabled={disableInput}\n                  className=\"token-amount-input\"\n                  value={value}\n                  onUserInput={(val) => {\n                    onUserInput(val)\n                  }}\n                />\n                {showMaxButton && (<div className=\"max-button\" onClick={handelMaxClick}>MAX</div>)}\n                <div className=\"currency-wrapper\" onClick={showCurrencySelectModal}>\n                  {selectedCurrency\n                   ? <div className=\"currency-icon\">\n                        <img className=\"ckb-logo\" src={selectedCurrency.tokenURI} alt=\"\" />\n                        <Typography.Text >{selectedCurrency.symbol}</Typography.Text>\n                      </div>\n                    : <Text>Select a currency </Text>}\n                  <DownOutlined />\n                </div>\n          </Row>\n          <TokenListModal title=\"Select a Token\" visible={isModalVisible} onOk={handleOk} onCancel={handleCancel} footer={null}>\n            <TokenList className=\"token-list\">\n              <List\n                dataSource={erc20List}\n                renderItem={(erc20, index) => \n                <List.Item className={erc20.address === selectedCurrency?.address ? 'selected' : ''} onClick={() => handleErc20Selected(index, erc20)}>\n                  <FixedHeightRow className=\"currency-item\">\n                    <div className=\"info\">\n                      <img className=\"icon\" src={erc20.tokenURI} alt=\"\" />\n                      <div className=\"symbol-name\">\n                        <Text className=\"symbol\">{erc20.symbol}</Text>\n                        <Text className=\"name\">{erc20.name}</Text>\n                      </div>\n                    </div>\n                    <div>{balancesList.length ? getFullDisplayAmount(BigInt(balancesList[index]), erc20.decimals) : ''}</div>\n                  </FixedHeightRow>  \n                </List.Item>}\n              ></List>\n            </TokenList>\n          </TokenListModal>\n      </StyleWrapper>\n    )\n  }","import { CopyOutlined } from \"@ant-design/icons\";\nimport { Button, Input, Tooltip } from \"antd\";\nimport React, { useMemo } from \"react\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../../hooks/useLightGodwoken\";\n\nconst TipWrapper = styled.div`\n  color: #fff;\n  .text-pair {\n    display: flex;\n    justify-content: space-between;\n  }\n`;\n\nfunction truncateMiddle(str: string, first = 6, last = 4): string {\n  return str.substring(0, first) + \"...\" + str.substring(str.length - last);\n}\n\nexport const Address: React.FC = () => {\n  const lightGodwoken = useLightGodwoken();\n\n  const l2Address = useMemo(() => {\n    if (!lightGodwoken) return undefined;\n    return lightGodwoken.provider.getL2Address();\n  }, [lightGodwoken]);\n\n  if (!lightGodwoken || !l2Address) return null;\n\n  return (\n    <Tooltip\n      title={\n        <TipWrapper>\n          <div className=\"address-content\">\n            <label htmlFor=\"\">ETH ADDRESS</label>\n            <Input.Group compact>\n              <Input style={{ width: \"calc(100% - 33px)\" }} value={lightGodwoken.provider.getL2Address()} />\n              <Tooltip title=\"copy git url\">\n                <Button icon={<CopyOutlined />} />\n              </Tooltip>\n            </Input.Group>\n          </div>\n          {/* <div className=\"text-pair\">\n            <Text>L2 CKB Balance</Text>\n            <Text>{getFullDisplayAmount(BigInt(l2CkbBalance), 8)}</Text>\n          </div> */}\n          <div className=\"address-content\">\n            <label htmlFor=\"\">L1 WALLET ADDRESS</label>\n            <Input.Group compact>\n              <Input style={{ width: \"calc(100% - 33px)\" }} value={lightGodwoken.provider.getL1Address()} />\n              <Tooltip title=\"copy git url\">\n                <Button icon={<CopyOutlined />} />\n              </Tooltip>\n            </Input.Group>\n          </div>\n        </TipWrapper>\n      }\n    >\n      {truncateMiddle(l2Address)}\n    </Tooltip>\n  );\n};\n","import detectEthereumProvider from \"@metamask/detect-provider\";\nimport { Button } from \"antd\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../../hooks/useLightGodwoken\";\nimport { Address } from \"../Address\";\nconst StyleWrapper = styled(Button)`\n  &.ant-btn-primary {\n    background: rgb(60,58,75);\n    border: none;\n  }\n`\nexport const ConnectButton: React.FC = () => {\n  const lightGodwoken = useLightGodwoken();\n\n  function connectWallet() {\n    if (lightGodwoken) return;\n\n    detectEthereumProvider().then((ethereum: any) => {\n      ethereum.request({ method: \"eth_requestAccounts\" });\n    });\n  }\n\n  return (\n    <StyleWrapper type=\"primary\" onClick={connectWallet}>\n      {lightGodwoken ? <Address /> : \"Connect\"}\n    </StyleWrapper>\n  );\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport { ConnectButton } from \"../components/ConnectButton\";\n\nconst StyledPage = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n  padding: 16px;\n  background: radial-gradient(89.56% 89.56% at 50.04% 10.44%, rgb(60, 58, 75) 0%, rgb(28, 27, 37) 92.56%);\n  margin-bottom: 20px;\n  color: white;\n  .address:hover {\n    cursor: pointer;\n  }\n`;\n\nconst PageHeader: React.FC<React.HTMLAttributes<HTMLDivElement>> = () => {\n  return (\n    <StyledPage>\n      <div className=\"icon\"></div>\n      <div className=\"title\">Withdrawal</div>\n      <div className=\"address\">\n        <ConnectButton />\n      </div>\n    </StyledPage>\n  );\n};\n\nexport default PageHeader;\n","import React from 'react'\nimport styled from 'styled-components'\nimport PageHeader from './PageHeader'\n\nconst StyledPage = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 100%;\n  min-height: calc(100vh);\n  background: radial-gradient(89.56% 89.56% at 50.04% 10.44%, rgb(60, 58, 75) 0%, rgb(28, 27, 37) 92.56%);\n`\n\nconst Page: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ children, ...props }) => {\n  return (\n    <StyledPage {...props}>\n      <PageHeader></PageHeader>\n      {children}\n    </StyledPage>\n  )\n}\n\nexport default Page\n","import { ArrowLeftOutlined, PlusOutlined, QuestionCircleOutlined } from \"@ant-design/icons\";\nimport { Button, Modal, notification, Typography } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport styled from \"styled-components\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nimport { WithdrawalEventEmitter } from \"../light-godwoken/lightGodwokenType\";\nimport { L1MappedErc20 } from \"../types/type\";\nimport CKBInputPanel from \"./CKBInputPanel\";\nimport CurrencyInputPanel from \"./CurrencyInputPanel\";\nimport Page from \"./Page\";\n\nconst { Text } = Typography;\n\nconst PageContent = styled.div`\n  width: 436px;\n  background: rgb(39, 37, 52);\n  border-radius: 24px;\n  color: white;\n`;\nconst PageHeader = styled.div`\n  display: flex;\n  justify-content: space-between;\n  padding: 24px;\n  align-items: center;\n  a,\n  .ant-typography {\n    color: white;\n  }\n`;\nconst PageMain = styled.div`\n  padding: 24px;\n  grid-auto-rows: auto;\n  row-gap: 8px;\n  .icon {\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    padding-top: 8px;\n    padding-bottom: 8px;\n  }\n`;\nconst WithDrawalButton = styled.div`\n  margin-top: 20px;\n  display: flex;\n  justify-content: center;\n  .submit-button {\n    align-items: center;\n    border: 0px;\n    border-radius: 16px;\n    box-shadow: rgb(14 14 44 / 40%) 0px -1px 0px 0px inset;\n    cursor: pointer;\n    display: inline-flex;\n    font-family: inherit;\n    font-size: 16px;\n    font-weight: 600;\n    -webkit-box-pack: center;\n    justify-content: center;\n    letter-spacing: 0.03em;\n    line-height: 1;\n    opacity: 1;\n    outline: 0px;\n    transition: background-color 0.2s ease 0s, opacity 0.2s ease 0s;\n    height: 48px;\n    padding: 0px 24px;\n    background-color: rgb(255, 67, 66);\n    color: white;\n    width: 100%;\n    &:disabled {\n      background-color: rgb(60, 55, 66);\n      border-color: rgb(60, 55, 66);\n      box-shadow: none;\n      color: rgb(104, 102, 123);\n      cursor: not-allowed;\n    }\n  }\n  button:hover {\n    cursor: pointer;\n  }\n`;\nconst ConfirmModal = styled(Modal)`\n  color: white;\n  .ant-modal-content {\n    border-radius: 32px;\n    background: rgb(39, 37, 52);\n    box-shadow: rgb(14 14 44 / 10%) 0px 20px 36px -8px, rgb(0 0 0 / 5%) 0px 1px 1px;\n    border: 1px solid rgb(60, 58, 75);\n    color: white;\n  }\n  .ant-modal-header {\n    background: rgb(39, 37, 52);\n    border: 1px solid rgb(60, 58, 75);\n    border-top-left-radius: 32px;\n    border-top-right-radius: 32px;\n    padding: 12px 24px;\n    height: 73px;\n    display: flex;\n    align-items: center;\n  }\n  .ant-modal-title,\n  .ant-list-item {\n    color: white;\n  }\n  .ant-modal-body {\n    padding: 24px;\n  }\n  .ant-modal-close-x {\n    color: white;\n  }\n  .ant-typography {\n    color: white;\n    justify-content: space-between;\n  }\n  .text-pair {\n    padding-top: 5px;\n    display: flex;\n    justify-content: space-between;\n    font-size: 24px;\n  }\n  .tips {\n    margin: 24px 0;\n  }\n`;\nexport default function RequestWithdrawal() {\n  const [ckbInput, setCkbInput] = useState(\"\");\n  const [outputValue, setOutputValue] = useState(\"\");\n  const [isModalVisible, setIsModalVisible] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [submitButtonDisable, setSubmitButtonDisable] = useState(true);\n  const [selectedSudt, setSelectedSudt] = useState<L1MappedErc20>();\n  const lightGodwoken = useLightGodwoken();\n\n  const showModal = () => {\n    setIsModalVisible(true);\n  };\n\n  const handleCancel = () => {\n    setIsModalVisible(false);\n  };\n\n  useEffect(() => {\n    if (Number(ckbInput) >= 400) {\n      setSubmitButtonDisable(false);\n    } else {\n      setSubmitButtonDisable(true);\n    }\n  }, [ckbInput]);\n\n  const sendWithDrawal = () => {\n    setLoading(true);\n    const capacity = BigInt(ckbInput) * BigInt(Math.pow(10, 8));\n    let amount = \"0x0\";\n    let sudt_script_hash = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n    if (selectedSudt) {\n      amount = \"0x\" + BigInt(Number(outputValue) * Math.pow(10, selectedSudt.decimals)).toString(16);\n      sudt_script_hash = selectedSudt.sudt_script_hash;\n    }\n    if (!lightGodwoken) {\n      return;\n    }\n    let e: WithdrawalEventEmitter;\n    try {\n      e = lightGodwoken.withdrawWithEvent({\n        capacity: \"0x\" + capacity.toString(16),\n        amount: amount,\n        sudt_script_hash: sudt_script_hash,\n      });\n    } catch (e) {\n      console.log(\"withdrawal error:\", e);\n      return;\n    }\n\n    e.on(\"sent\", (txHash) => {\n      setIsModalVisible(false);\n      notification.info({ message: `Withdrawal Tx(${txHash}) has sent` });\n      setLoading(false);\n    });\n\n    e.on(\"pending\", (result) => {\n      console.log(\"pending triggerd\", result);\n    });\n\n    e.on(\"success\", (txHash) => {\n      setIsModalVisible(false);\n      notification.success({ message: `Withdrawal Tx(${txHash}) is successful` });\n    });\n\n    e.on(\"error\", (result: unknown) => {\n      setLoading(false);\n      notification.error({ message: result instanceof Error ? result.message : JSON.stringify(result) });\n    });\n  };\n\n  return (\n    <Page>\n      <PageContent>\n        <PageHeader className=\"header\">\n          <Link to=\"/\">\n            <ArrowLeftOutlined />\n          </Link>\n          <Text>Request Withdrawal</Text>\n          <QuestionCircleOutlined />\n        </PageHeader>\n        <PageMain className=\"main\">\n          <CKBInputPanel value={ckbInput} onUserInput={setCkbInput} label=\"Withdraw\"></CKBInputPanel>\n          <div className=\"icon\">\n            <PlusOutlined />\n          </div>\n          <CurrencyInputPanel\n            value={outputValue}\n            onUserInput={setOutputValue}\n            label=\"sUDT(optional)\"\n            onSelectedChange={setSelectedSudt}\n          ></CurrencyInputPanel>\n          <WithDrawalButton>\n            <Button className=\"submit-button\" disabled={submitButtonDisable} onClick={showModal}>\n              Request Withdrawal\n            </Button>\n          </WithDrawalButton>\n        </PageMain>\n        <div className=\"footer\">\n          {/* <ProgressStepper currentStep={0} steps={withdrawalSteps}></ProgressStepper> */}\n        </div>\n      </PageContent>\n      <ConfirmModal title=\"Confirm Request\" visible={isModalVisible} onCancel={handleCancel} footer={null}>\n        <div className=\"text-pair\">\n          <Text>Block wait</Text>\n          <Text>10000</Text>\n        </div>\n        <div className=\"text-pair\">\n          <Text>Estimated time</Text>\n          <Text>5 days</Text>\n        </div>\n        <div className=\"tips\">\n          Layer 2 assets will be locked in Withdrawal Request, available to withdraw to Layer 1 after maturity. Request\n          Withdrawal\n        </div>\n        <WithDrawalButton>\n          <Button className=\"submit-button\" loading={loading} onClick={sendWithDrawal}>\n            Request Withdrawal\n          </Button>\n        </WithDrawalButton>\n      </ConfirmModal>\n    </Page>\n  );\n}\n","import Page from \"./Page\";\nimport styled from \"styled-components\";\nimport WithdrawalRequestCard from \"./WithdrawalRequestCard\";\nimport { useEffect, useState } from \"react\";\nimport { WithdrawResult } from \"../types/type\";\nimport { Link } from \"react-router-dom\";\nimport { useLightGodwoken } from \"../hooks/useLightGodwoken\";\nimport { useClock } from \"../hooks/useClock\";\nconst PageContent = styled.div`\n  width: 436px;\n  background: rgb(39, 37, 52);\n  border-radius: 24px;\n  color: white;\n  .request-withdrawal {\n    padding: 24px;\n  }\n  .title {\n    font-size: 20px;\n    font-weight: 600;\n    line-height: 1.1;\n    margin-bottom: 8px;\n  }\n  .description {\n    font-weight: 400;\n    line-height: 1.5;\n    font-size: 14px;\n  }\n  .button-container {\n    margin-top: 16px\n  }\n  .request-button {\n    -webkit-box-align: center;\n    align-items: center;\n    border: 0px;\n    border-radius: 16px;\n    box-shadow: rgb(14 14 44 / 40%) 0px -1px 0px 0px inset;\n    cursor: pointer;\n    display: inline-flex;\n    font-family: inherit;\n    font-size: 16px;\n    font-weight: 600;\n    -webkit-box-pack: center;\n    justify-content: center;\n    letter-spacing: 0.03em;\n    line-height: 1;\n    opacity: 1;\n    outline: 0px;\n    transition: background-color 0.2s ease 0s, opacity 0.2s ease 0s;\n    height: 48px;\n    padding: 0px 24px;\n    background-color: rgb(255, 67, 66);\n    color: white;\n  }\n`\n\nconst ResultList = styled.div`\n  >.header {\n    -webkit-box-align: center;\n    align-items: center;\n    -webkit-box-pack: justify;\n    justify-content: space-between;\n    padding: 24px;\n    width: 100%;\n    border-bottom: 1px solid rgb(60, 58, 75);\n    border-top: 1px solid rgb(60, 58, 75);\n    font-size: 16px;\n    font-weight: 600;\n    line-height: 1.5;\n  }\n  .list {\n    max-height: calc(100vh - 400px);\n    overflow-y: auto;\n    background-color: rgb(16, 12, 24);\n    padding: 24px;\n    border-bottom-left-radius: 24px;\n    border-bottom-right-radius: 24px;\n    &>div {\n      margin-bottom: 16px;\n    }\n  }\n`\n\nconst Withdrawal: React.FC<React.HTMLAttributes<HTMLDivElement>> = () => {\n  const [withdrawList, setWithdrawList] = useState<WithdrawResult[]>([])\n  const lightGodwoken = useLightGodwoken();\n  const now = useClock()\n  useEffect(() => {\n    const fetchWithdrawList =  async () => {\n      if(lightGodwoken) {\n        const results: WithdrawResult[] = await lightGodwoken?.listWithdraw()\n        setWithdrawList(results);\n      }\n    }\n    fetchWithdrawList();\n  }, [lightGodwoken])\n    return (\n      <Page>\n        <PageContent className=\"content\">\n          <div className=\"request-withdrawal\">\n            <div className=\"title\">Withdrawal</div>\n            <div className=\"description\">To withdraw assets back to Layer 1, you need to have CKB balance in your L1 Wallet Address</div>\n            <div className=\"button-container\">\n              <Link to=\"/request-withdrawal\" className=\"request-button\">Request Withdrawal</Link >\n            </div>\n          </div>\n          <ResultList className=\"withdrawal-request\">\n            <div className=\"header\">Your Withdrawal Requests</div>\n            <div className=\"list\">\n              {\n                withdrawList.map((withdraw, index) => (\n                  <WithdrawalRequestCard now={now} {...withdraw} key={index}></WithdrawalRequestCard>\n                ))\n              }\n            </div>\n          </ResultList>\n        </PageContent>\n      </Page>\n    )\n}\n\nexport default Withdrawal","import { useEffect, useState } from 'react'\n\nexport function useClock(): number {\n  const [now, setTime] = useState(() => Date.now())\n\n  useEffect(() => {\n    const loop = () => {\n      setTime(Date.now())\n      setTimeout(loop, 1000)\n    }\n\n    setTimeout(loop, 1000)\n  }, [])\n\n  return now\n}\n","import \"antd/dist/antd.css\";\nimport React from \"react\";\nimport { HashRouter as Router, Route, Routes } from \"react-router-dom\";\nimport { Provider as LightGodwokenProvider } from \"./contexts/LightGodwokenContext\";\nimport RequestWithdrawal from \"./views/RequestWithdrawal\";\nimport Withdrawal from \"./views/Withdrawal\";\n\nfunction App() {\n  return (\n    <LightGodwokenProvider>\n      <Router>\n        <Routes>\n          <Route path=\"/\" element={<Withdrawal />}></Route>\n          <Route path=\"/request-withdrawal\" element={<RequestWithdrawal />}></Route>\n        </Routes>\n      </Router>\n    </LightGodwokenProvider>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport {initializeConfig,predefined} from '@ckb-lumos/config-manager'\n\ninitializeConfig((predefined.AGGRON4))\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}